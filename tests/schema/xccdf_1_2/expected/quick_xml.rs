use xsd_parser::models::schema::Namespace;
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_CDF: Namespace = Namespace::new_const(b"http://checklists.nist.gov/xccdf/1.2");
pub const NS_CPE: Namespace = Namespace::new_const(b"http://cpe.mitre.org/language/2.0");
pub const NS_CPE_4: Namespace = Namespace::new_const(b"http://cpe.mitre.org/naming/2.0");
pub mod cdf {
    use std::borrow::Cow;
    use xsd_parser::{
        quick_xml::{
            DeserializeBytes, DeserializeReader, Error, ErrorKind, RawByteStr, SerializeBytes,
            WithDeserializer, WithSerializer,
        },
        xml::{AnyAttributes, AnyElement, Mixed, Text},
    };
    /// This is the root element of the XCCDF document; it
    ///must appear exactly once. It encloses the entire benchmark, and contains both
    ///descriptive information and structural information. Note that the order of
    ///xccdf:Group and xccdf:Rule child elements may matter for the
    ///appearance of a generated document. xccdf:Group and xccdf:Rule
    ///children may be freely intermingled, but they must appear after any
    ///xccdf:Value children. All the other children must appear in the order
    ///shown.
    pub type Benchmark = BenchmarkElementType;
    #[derive(Debug)]
    pub struct BenchmarkElementType {
        ///Unique xccdf:Benchmark
        ///identifier.
        pub id: String,
        ///An identifier used for referencing elements
        ///included in an XML signature.
        pub xml_id: Option<String>,
        ///True if xccdf:Benchmark has already
        ///undergone the resolution process.
        pub resolved: bool,
        ///Name of an xccdf:Benchmark authoring
        ///style or set of conventions or constraints to which this
        ///xccdf:Benchmark conforms (e.g., “SCAP 1.2”).
        pub style: Option<String>,
        ///URL of a supplementary stylesheet or schema
        ///extension that can be used to verify conformance to the named
        ///style.
        pub style_href: Option<String>,
        pub lang: Option<String>,
        pub content: Vec<BenchmarkElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum BenchmarkElementTypeContent {
        ///Status of the xccdf:Benchmark
        ///indicating its level of maturity or consensus. If more than one
        ///xccdf:status element appears, the element's @date attribute
        ///should be included.
        Status(StatusElementType),
        ///Holds additional status information using
        ///the Dublin Core format.
        DcStatus(DcStatusType),
        ///Title of the xccdf:Benchmark; an
        ///xccdf:Benchmark should have an
        ///xccdf:title.
        Title(TextType),
        ///Text that describes the
        ///xccdf:Benchmark; an xccdf:Benchmark should have an
        ///xccdf:description.
        Description(HtmlTextWithSubType),
        ///Legal notices (licensing information, terms
        ///of use, etc.), copyright statements, warnings, and other advisory
        ///notices about this xccdf:Benchmark and its
        ///use.
        Notice(NoticeType),
        ///Introductory matter for the beginning of
        ///the xccdf:Benchmark document; intended for use during Document
        ///Generation.
        FrontMatter(HtmlTextWithSubType),
        ///Concluding material for the end of the
        ///xccdf:Benchmark document; intended for use during Document
        ///Generation.
        RearMatter(HtmlTextWithSubType),
        ///Supporting references for the
        ///xccdf:Benchmark document.
        Reference(ReferenceType),
        ///Definitions for reusable text blocks, each
        ///with a unique identifier.
        PlainText(PlainTextType),
        ///A list of identifiers for complex platform
        ///definitions, written in CPE applicability language format. Authors may
        ///define complex platforms within this element, and then use their locally
        ///unique identifiers anywhere in the xccdf:Benchmark element in
        ///place of a CPE name.
        PlatformSpecification(super::cpe::PlatformSpecificationType),
        ///Applicable platforms for this
        ///xccdf:Benchmark. Authors should use the element to identify the
        ///systems or products to which the xccdf:Benchmark
        ///applies.
        Platform(Cpe2IdrefType),
        ///Version number of the
        ///xccdf:Benchmark.
        Version(VersionType),
        ///XML metadata for the
        ///xccdf:Benchmark. Metadata allows many additional pieces of
        ///information, including authorship, publisher, support, and other similar
        ///details, to be embedded in an
        ///xccdf:Benchmark.
        Metadata(MetadataType),
        ///URIs of suggested scoring models to be used
        ///when computing a score for this xccdf:Benchmark. A suggested
        ///list of scoring models and their URIs is provided in the XCCDF
        ///specification.
        Model(ModelElementType),
        ///xccdf:Profile elements that
        ///reference and customize sets of items in the
        ///xccdf:Benchmark.
        Profile(ProfileType),
        ///Parameter xccdf:Value elements that
        ///support xccdf:Rule elements and descriptions in the
        ///xccdf:Benchmark.
        Value(ValueType),
        ///xccdf:Group elements that
        ///comprise the xccdf:Benchmark; each may contain additional
        ///xccdf:Value, xccdf:Rule, and other
        ///xccdf:Group elements.
        Group(GroupType),
        ///xccdf:Rule elements that
        ///comprise the xccdf:Benchmark.
        Rule(RuleType),
        ///xccdf:Benchmark test result records
        ///(one per xccdf:Benchmark run).
        TestResult(TestResultType),
        ///A digital signature asserting authorship
        ///and allowing verification of the integrity of the
        ///xccdf:Benchmark.
        Signature(SignatureType),
    }
    impl BenchmarkElementType {
        #[must_use]
        pub fn default_resolved() -> bool {
            false
        }
    }
    impl WithSerializer for BenchmarkElementType {
        type Serializer<'x> = quick_xml_serialize::BenchmarkElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::BenchmarkElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::BenchmarkElementTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:Benchmark"),
                is_root,
            })
        }
    }
    impl WithSerializer for BenchmarkElementTypeContent {
        type Serializer<'x> = quick_xml_serialize::BenchmarkElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::BenchmarkElementTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::BenchmarkElementTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for BenchmarkElementType {
        type Deserializer = quick_xml_deserialize::BenchmarkElementTypeDeserializer;
    }
    impl WithDeserializer for BenchmarkElementTypeContent {
        type Deserializer = quick_xml_deserialize::BenchmarkElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct StatusElementType {
        ///The date the parent element achieved
        ///the indicated status.
        pub date: Option<String>,
        pub content: StatusType,
    }
    impl WithSerializer for StatusElementType {
        type Serializer<'x> = quick_xml_serialize::StatusElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::StatusElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::StatusElementTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:status"),
                is_root,
            })
        }
    }
    impl WithDeserializer for StatusElementType {
        type Deserializer = quick_xml_deserialize::StatusElementTypeDeserializer;
    }
    ///Data type element for the xccdf:dc-status element, which
    ///holds status information about its parent element using the Dublin Core format,
    ///expressed as elements of the DCMI Simple DC Element specification.
    #[derive(Debug)]
    pub struct DcStatusType {
        pub any: Vec<AnyElement>,
    }
    impl WithSerializer for DcStatusType {
        type Serializer<'x> = quick_xml_serialize::DcStatusTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::DcStatusTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::DcStatusTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:dc-statusType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for DcStatusType {
        type Deserializer = quick_xml_deserialize::DcStatusTypeDeserializer;
    }
    ///Type for a simple text string with an @override
    ///attribute for controlling inheritance.
    #[derive(Debug)]
    pub struct TextType {
        pub lang: Option<String>,
        ///Used to manage inheritance.
        pub override_: bool,
        pub content: String,
    }
    impl TextType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
    }
    impl WithSerializer for TextType {
        type Serializer<'x> = quick_xml_serialize::TextTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TextTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TextTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:textType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TextType {
        type Deserializer = quick_xml_deserialize::TextTypeDeserializer;
    }
    /// The type for a string with optional XHTML elements,
    ///and an @xml:lang attribute.
    #[derive(Debug)]
    pub struct HtmlTextWithSubType {
        pub lang: Option<String>,
        ///Used to manage inheritance.
        pub override_: bool,
        pub content: Vec<HtmlTextWithSubTypeContent>,
    }
    /// The type for a string with optional XHTML elements,
    ///and an @xml:lang attribute.
    #[derive(Debug)]
    pub enum HtmlTextWithSubTypeContent {
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text
        ///substitution
        Sub(SubType),
        Any(AnyElement),
        Text(Text),
    }
    impl HtmlTextWithSubType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
    }
    impl WithSerializer for HtmlTextWithSubType {
        type Serializer<'x> = quick_xml_serialize::HtmlTextWithSubTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::HtmlTextWithSubTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::HtmlTextWithSubTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:htmlTextWithSubType"),
                is_root,
            })
        }
    }
    impl WithSerializer for HtmlTextWithSubTypeContent {
        type Serializer<'x> = quick_xml_serialize::HtmlTextWithSubTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::HtmlTextWithSubTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::HtmlTextWithSubTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for HtmlTextWithSubType {
        type Deserializer = quick_xml_deserialize::HtmlTextWithSubTypeDeserializer;
    }
    impl WithDeserializer for HtmlTextWithSubTypeContent {
        type Deserializer = quick_xml_deserialize::HtmlTextWithSubTypeContentDeserializer;
    }
    ///Data type for an xccdf:notice element.
    ///xccdf:notice elements are used to include legal notices (licensing
    ///information, terms of use, etc.), copyright statements, warnings, and other advisory
    ///notices about this xccdf:Benchmark and its use. This information may be
    ///expressed using XHTML or may be a simply text expression. Each xccdf:notice
    ///element must have a unique identifier.
    #[derive(Debug)]
    pub struct NoticeType {
        ///The unique identifier for this
        ///xccdf:notice.
        pub id: Option<String>,
        pub base: Option<String>,
        pub lang: Option<String>,
        pub text_before: Option<Text>,
        pub any: Vec<Mixed<AnyElement>>,
    }
    impl WithSerializer for NoticeType {
        type Serializer<'x> = quick_xml_serialize::NoticeTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::NoticeTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::NoticeTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:noticeType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for NoticeType {
        type Deserializer = quick_xml_deserialize::NoticeTypeDeserializer;
    }
    /// This element provides supplementary descriptive text
    ///for a XCCDF elements. When used, it has either a simple string value or a value
    ///consisting of simple Dublin Core elements. If a bare string appears, then it is
    ///taken to be the string content for a Dublin Core title element. Multiple
    ///xccdf:reference elements may appear; a document generation processing tool
    ///may concatenate them, or put them into a reference list, and may choose to number
    ///them.
    #[derive(Debug)]
    pub struct ReferenceType {
        ///A URL pointing to the referenced
        ///resource.
        pub href: Option<String>,
        ///Used to manage inheritance
        ///processing.
        pub override_: Option<bool>,
        pub text_before: Option<Text>,
        pub any: Vec<Mixed<AnyElement>>,
    }
    impl WithSerializer for ReferenceType {
        type Serializer<'x> = quick_xml_serialize::ReferenceTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ReferenceTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ReferenceTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:referenceType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ReferenceType {
        type Deserializer = quick_xml_deserialize::ReferenceTypeDeserializer;
    }
    ///The data type for an xccdf:plain-text element,
    ///which is a reusable text block for reference by the xccdf:sub element. This
    ///allows text to be defined once and then reused multiple times. Each
    ///xccdf:plain-text element mush have a unique id.
    #[derive(Debug)]
    pub struct PlainTextType {
        ///The unique identifier for this
        ///xccdf:plain-text element.
        pub id: String,
        pub content: String,
    }
    impl WithSerializer for PlainTextType {
        type Serializer<'x> = quick_xml_serialize::PlainTextTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PlainTextTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::PlainTextTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:plainTextType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PlainTextType {
        type Deserializer = quick_xml_deserialize::PlainTextTypeDeserializer;
    }
    /// Data type for xccdf:platform elements that do
    ///not need @override attributes. (I.e., xccdf:platform elements that are in
    ///structures that cannot be extended, such as xccdf:TestResult and
    ///xccdf:Benchmark elements.) This is used to identify the applicable target
    ///platform for its respective parent elements.
    #[derive(Debug)]
    pub struct Cpe2IdrefType {
        ///Should be a CPE 2.3 Applicability Language
        ///identifier using the Formatted String binding or the value of a
        ///cpe:platform-specification element's @id attribute, the latter acting as
        ///a reference to some expression defined using the CPE schema in the
        ///xccdf:Benchmark element's cpe:platform-specification element.
        ///The @idref may be a CPE Applicability Language identifier using the URI binding,
        ///although this is less preferred.
        pub idref: String,
    }
    impl WithSerializer for Cpe2IdrefType {
        type Serializer<'x> = quick_xml_serialize::Cpe2IdrefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::Cpe2IdrefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::Cpe2IdrefTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:CPE2idrefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for Cpe2IdrefType {
        type Deserializer = quick_xml_deserialize::Cpe2IdrefTypeDeserializer;
    }
    /// Type for most xccdf:version elements.
    #[derive(Debug)]
    pub struct VersionType {
        ///The time that this version of the
        ///associated element was completed.
        pub time: Option<String>,
        ///A URI indicating a location where updates
        ///to the associated element may be obtained.
        pub update: Option<String>,
        pub content: String,
    }
    impl WithSerializer for VersionType {
        type Serializer<'x> = quick_xml_serialize::VersionTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::VersionTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::VersionTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:versionType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for VersionType {
        type Deserializer = quick_xml_deserialize::VersionTypeDeserializer;
    }
    /// Data type that supports inclusion of metadata about a
    ///document or element. This is particularly useful for facilitating the discovery and
    ///retrieval of XCCDF checklists from public repositories. When used, the contents of
    ///the xccdf:metadata element are expressed in XML. The xccdf:Benchmark
    ///element's metadata should contain information formatted using the Dublin Core
    ///Metadata Initiative (DCMI) Simple DC Element specification, as described in [DCES]
    ///and [DCXML]. Benchmark consumers should be prepared to process Dublin Core metadata
    ///in the xccdf:metadata element. Other metadata schemes, including ad-hoc
    ///elements, are also allowed, both in the xccdf:Benchmark and in other
    ///elements.
    #[derive(Debug)]
    pub struct MetadataType {
        pub any: Vec<AnyElement>,
    }
    impl WithSerializer for MetadataType {
        type Serializer<'x> = quick_xml_serialize::MetadataTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::MetadataTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::MetadataTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:metadataType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for MetadataType {
        type Deserializer = quick_xml_deserialize::MetadataTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ModelElementType {
        ///A URI designating a scoring
        ///model.
        pub system: String,
        ///Parameters provided as input to the
        ///designated scoring model.
        pub param: Vec<ParamType>,
    }
    impl WithSerializer for ModelElementType {
        type Serializer<'x> = quick_xml_serialize::ModelElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ModelElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ModelElementTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:model"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ModelElementType {
        type Deserializer = quick_xml_deserialize::ModelElementTypeDeserializer;
    }
    /// Data type for the xccdf:Profile element, which
    ///holds a specific tailoring of the xccdf:Benchmark. The main part of an
    ///xccdf:Profile is the selectors: xccdf:select,
    ///xccdf:set-value, xccdf:set-complex-value, xccdf:refine-rule,
    ///and xccdf:refine-value. An xccdf:Profile may also be signed with an
    ///XML-Signature.
    #[derive(Debug)]
    pub struct ProfileType {
        ///Unique identifier for this
        ///xccdf:Profile.
        pub id: String,
        ///Whether or not products should prohibit changes to
        ///this xccdf:Profile.
        pub prohibit_changes: bool,
        ///If true, then this xccdf:Profile exists
        ///solely to be extended by other xccdf:Profile elements.
        pub abstract_: bool,
        ///Tag identifier to specify which
        ///xccdf:profile-note element from an xccdf:Rule should be
        ///associated with this xccdf:Profile.
        pub note_tag: Option<String>,
        ///The id of an xccdf:Profile on which to base
        ///this xccdf:Profile.
        pub extends: Option<String>,
        pub base: Option<String>,
        ///An identifier used for referencing elements
        ///included in an XML signature.
        pub xml_id: Option<String>,
        pub content: Vec<ProfileTypeContent>,
    }
    /// Data type for the xccdf:Profile element, which
    ///holds a specific tailoring of the xccdf:Benchmark. The main part of an
    ///xccdf:Profile is the selectors: xccdf:select,
    ///xccdf:set-value, xccdf:set-complex-value, xccdf:refine-rule,
    ///and xccdf:refine-value. An xccdf:Profile may also be signed with an
    ///XML-Signature.
    #[derive(Debug)]
    pub enum ProfileTypeContent {
        ///Status of the xccdf:Profile and date at
        ///which it attained that status. Authors may use this element to record the
        ///maturity or consensus level of an xccdf:Profile. If the
        ///xccdf:status is not given explicitly, then the xccdf:Profile
        ///is taken to have the same status as its parent
        ///xccdf:Benchmark.
        Status(StatusElementType),
        ///Holds additional status information using the
        ///Dublin Core format.
        DcStatus(DcStatusType),
        ///Version information about this
        ///xccdf:Profile.
        Version(VersionType),
        ///Title of the xccdf:Profile.
        Title(TextWithSubType),
        ///Text that describes the xccdf:Profile.
        Description(HtmlTextWithSubType),
        ///A reference where the user can learn more about
        ///the subject of this xccdf:Profile.
        Reference(ReferenceType),
        ///A target platform for this
        ///xccdf:Profile.
        Platform(OverrideableCpe2IdrefType),
        ///Select or deselect xccdf:Group and
        ///xccdf:Rule elements.
        Select(ProfileSelectType),
        ///Set the value of an xccdf:Value to
        ///a list.
        SetComplexValue(ProfileSetComplexValueType),
        ///Set the value of an xccdf:Value to
        ///a simple data value.
        SetValue(ProfileSetValueType),
        ///Customize the properties of an
        ///xccdf:Value.
        RefineValue(ProfileRefineValueType),
        ///Customize the properties of an
        ///xccdf:Rule or xccdf:Group.
        RefineRule(ProfileRefineRuleType),
        ///Metadata associated with this
        ///xccdf:Profile.
        Metadata(MetadataType),
        ///A digital signature asserting authorship and
        ///allowing verification of the integrity of the
        ///xccdf:Profile.
        Signature(SignatureType),
    }
    impl ProfileType {
        #[must_use]
        pub fn default_prohibit_changes() -> bool {
            false
        }
        #[must_use]
        pub fn default_abstract_() -> bool {
            false
        }
    }
    impl WithSerializer for ProfileType {
        type Serializer<'x> = quick_xml_serialize::ProfileTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileType"),
                is_root,
            })
        }
    }
    impl WithSerializer for ProfileTypeContent {
        type Serializer<'x> = quick_xml_serialize::ProfileTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::ProfileTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for ProfileType {
        type Deserializer = quick_xml_deserialize::ProfileTypeDeserializer;
    }
    impl WithDeserializer for ProfileTypeContent {
        type Deserializer = quick_xml_deserialize::ProfileTypeContentDeserializer;
    }
    /// Data type for the xccdf:Value element, which
    ///is a named parameter that can be substituted into properties of other elements
    ///within the xccdf:Benchmark, including the interior of structured check
    ///specifications and fix scripts.
    #[derive(Debug)]
    pub struct ValueType {
        ///If true, then this item is abstract and exists only
        ///to be extended. The use of this attribute for xccdf:Group elements is
        ///deprecated and should be avoided.
        pub abstract_: bool,
        ///An identifier to be used as a means to identify
        ///(refer to) related items. It designates membership in a cluster of items, which
        ///are used for controlling items via xccdf:Profile elements. All the items
        ///with the same cluster identifier belong to the same cluster. A selector in an
        ///xccdf:Profile may refer to a cluster, thus making it easier for authors
        ///to create and maintain xccdf:Profile elements in a complex
        ///xccdf:Benchmark.
        pub cluster_id: Option<String>,
        ///The identifier of an item on which to base this
        ///item. If present, it must have a value equal to the @id attribute of another
        ///item. The use of this attribute for xccdf:Group elements is deprecated
        ///and should be avoided.
        pub extends: Option<String>,
        ///If this item should be excluded from any generated
        ///documents although it may still be used during assessments.
        pub hidden: bool,
        ///If benchmark producers should prohibit changes to
        ///this item during tailoring. An author should use this when they do not want to
        ///allow end users to change the item.
        pub prohibit_changes: bool,
        pub lang: Option<String>,
        pub base: Option<String>,
        ///An identifier used for referencing elements
        ///included in an XML signature
        pub xml_id: Option<String>,
        ///The unique identifier for this element.
        pub id: String,
        ///The data type of the xccdf:Value. A
        ///tool may choose any convenient form to store an xccdf:Value
        ///element’s xccdf:value element, but the @type attribute conveys
        ///how the xccdf:Value should be treated for user input validation
        ///purposes during tailoring processing. The @type attribute may also be
        ///used to give additional guidance to the user or to validate the user’s
        ///input. In the case of a list of values, the @type attribute, if present,
        ///applies to all elements of the list individually.
        pub type_: ValueTypeType,
        ///The operator to be used for comparing this
        ///xccdf:Value to some part of the test system’s configuration
        ///during xccdf:Rule checking.
        pub operator: ValueOperatorType,
        ///Whether tailoring for this
        ///xccdf:Value should be performed during xccdf:Benchmark
        ///application. The benchmark consumer may ignore the attribute if asking
        ///the user is not feasible or not supported.
        pub interactive: bool,
        ///A hint or recommendation to a benchmark
        ///consumer or producer about how the user might select or adjust the
        ///xccdf:Value.
        pub interface_hint: Option<InterfaceHintType>,
        pub content: Vec<ValueTypeContent>,
    }
    /// Data type for the xccdf:Value element, which
    ///is a named parameter that can be substituted into properties of other elements
    ///within the xccdf:Benchmark, including the interior of structured check
    ///specifications and fix scripts.
    #[derive(Debug)]
    pub enum ValueTypeContent {
        ///Status of the item and date at which it
        ///attained that status. xccdf:Benchmark authors may use this element
        ///to record the maturity or consensus level for elements in the
        ///xccdf:Benchmark. If an item does not have an explicit
        ///xccdf:status given, then its status is that of its
        ///parent.
        Status(StatusElementType),
        ///Holds additional status information using the
        ///Dublin Core format.
        DcStatus(DcStatusType),
        ///Version information about this item.
        Version(VersionType),
        ///Title of the item. Every item should have an
        ///xccdf:title, because this helps people understand the purpose of the
        ///item.
        Title(TextWithSubType),
        ///Text that describes the item.
        Description(HtmlTextWithSubType),
        ///A note or caveat about the item intended to
        ///convey important cautionary information for the xccdf:Benchmark user
        ///(e.g., “Complying with this rule will cause the system to reject all IP
        ///packets”). If multiple xccdf:warning elements appear, benchmark
        ///consumers should concatenate them for generating reports or documents.
        ///Benchmark consumers may present this information in a special manner in
        ///generated documents.
        Warning(WarningType),
        ///Interrogative text to present to the user
        ///during tailoring. It may also be included into a generated document. For
        ///xccdf:Rule and xccdf:Group elements, the
        ///xccdf:question text should be a simple binary (yes/no) question
        ///because it is supporting the selection aspect of tailoring. For
        ///xccdf:Value elements, the xccdf:question should solicit the
        ///user to provide a specific value. Tools may also display constraints on
        ///values and any defaults as specified by the other xccdf:Value
        ///properties.
        Question(TextType),
        ///References where the user can learn more about
        ///the subject of this item.
        Reference(ReferenceType),
        ///XML metadata associated with this item, such as
        ///sources, special information, or other details.
        Metadata(MetadataType),
        ///A simple (number, string, or
        ///boolean) value associated with this xccdf:Value. At any
        ///time an xccdf:Value has one active (simple or complex)
        ///value. If a selector value has been provided under
        ///xccdf:Profile selection or tailoring then the active
        ///xccdf:value/xccdf:complex-value is the one with
        ///a matching @selector. If there is no provided selector or if the
        ///provided selector does not match the @selector attribute of any
        ///xccdf:value or xccdf:complex-value, the active
        ///xccdf:value/xccdf:complex-value is the one with
        ///an empty or absent @selector or, failing that, the first
        ///xccdf:value or xccdf:complex-value in the XML.
        ///When an xccdf:Value is exported or used in text
        ///substitution, it is the currently active xccdf:value or
        ///xccdf:complex-value that is actually used. If there are
        ///multiple xccdf:value and/or xccdf:complex-value
        ///elements, only one may omit a @selector attribute and no two may
        ///have the same @selector value.
        Value(SelStringType),
        ///A complex (list) value associated
        ///with this xccdf:Value. See the description of the
        ///xccdf:value property for xccdf:Rule elements
        ///regarding activation of an xccdf:complex-value.
        ComplexValue(SelComplexValueType),
        ///The default value displayed to the
        ///user as a suggestion by benchmark producers during tailoring of
        ///this xccdf:Value element. (This is not the default value
        ///of an xccdf:Value; it is just the default display.) If
        ///there are multiple xccdf:default and/or
        ///xccdf:complex-default elements, only one may omit a
        ///@selector attribute and no two may have the same @selector
        ///value.
        Default(SelStringType),
        ///The default
        ///xccdf:complex-value displayed to the user as a
        ///suggestion by benchmark producers during tailoring of this
        ///xccdf:Value element. (This is not the default value of
        ///an xccdf:Value; it is just the default display.) If
        ///there are multiple xccdf:default and
        ///xccdf:complex-default elements, only one may omit a
        ///@selector attribute and no two may have the same @selector
        ///value.
        ComplexDefault(SelComplexValueType),
        ///A Perl Compatible Regular Expression
        ///that a benchmark producer may apply during tailoring to validate a
        ///user’s input for the xccdf:Value. It uses implicit
        ///anchoring. It applies only when the @type property is “string” or
        ///“number” or a list of strings and/or numbers.
        Match(SelStringType),
        ///Minimum legal value for this
        ///xccdf:Value. It is used to constrain value input during
        ///tailoring, when the @type property is “number”. Values supplied by
        ///the user for tailoring the xccdf:Benchmark must be equal to
        ///or greater than this number.
        LowerBound(SelNumType),
        ///Maximum legal value for this
        ///xccdf:Value. It is used to constrain value input during
        ///tailoring, when the @type is “number”. Values supplied by the user
        ///for tailoring the xccdf:Benchmark must be less than or equal
        ///to than this number.
        UpperBound(SelNumType),
        ///A list of legal or suggested choices
        ///(values) for an xccdf:Value element, to be used during
        ///tailoring and document generation.
        Choices(SelChoicesType),
        ///URI indicating where the tool may
        ///acquire values, value bounds, or value choices for this
        ///xccdf:Value element. XCCDF does not attach any meaning to
        ///the URI; it may be an arbitrary community or tool-specific value, or
        ///a pointer directly to a resource. If several instances of the
        ///xccdf:source property appear, then they represent
        ///alternative means or locations for obtaining the value in descending
        ///order of preference (i.e., most preferred first).
        Source(UriRefType),
        ///A digital signature asserting
        ///authorship and allowing verification of the integrity of the
        ///xccdf:Value.
        Signature(SignatureType),
    }
    impl ValueType {
        #[must_use]
        pub fn default_abstract_() -> bool {
            false
        }
        #[must_use]
        pub fn default_hidden() -> bool {
            false
        }
        #[must_use]
        pub fn default_prohibit_changes() -> bool {
            false
        }
        #[must_use]
        pub fn default_type_() -> ValueTypeType {
            ValueTypeType::String
        }
        #[must_use]
        pub fn default_operator() -> ValueOperatorType {
            ValueOperatorType::Equals
        }
        #[must_use]
        pub fn default_interactive() -> bool {
            false
        }
    }
    impl WithSerializer for ValueType {
        type Serializer<'x> = quick_xml_serialize::ValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ValueTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ValueTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:valueType"),
                is_root,
            })
        }
    }
    impl WithSerializer for ValueTypeContent {
        type Serializer<'x> = quick_xml_serialize::ValueTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::ValueTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ValueTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for ValueType {
        type Deserializer = quick_xml_deserialize::ValueTypeDeserializer;
    }
    impl WithDeserializer for ValueTypeContent {
        type Deserializer = quick_xml_deserialize::ValueTypeContentDeserializer;
    }
    /// Data type for the xccdf:Group element. A
    ///xccdf:Group element contains descriptive information about a portion of an
    ///xccdf:Benchmark, as well as xccdf:Rule, xccdf:Value, and/or
    ///other xccdf:Group elements
    #[derive(Debug)]
    pub struct GroupType {
        ///If true, then this item is abstract and exists only
        ///to be extended. The use of this attribute for xccdf:Group elements is
        ///deprecated and should be avoided.
        pub abstract_: bool,
        ///An identifier to be used as a means to identify
        ///(refer to) related items. It designates membership in a cluster of items, which
        ///are used for controlling items via xccdf:Profile elements. All the items
        ///with the same cluster identifier belong to the same cluster. A selector in an
        ///xccdf:Profile may refer to a cluster, thus making it easier for authors
        ///to create and maintain xccdf:Profile elements in a complex
        ///xccdf:Benchmark.
        pub cluster_id: Option<String>,
        ///The identifier of an item on which to base this
        ///item. If present, it must have a value equal to the @id attribute of another
        ///item. The use of this attribute for xccdf:Group elements is deprecated
        ///and should be avoided.
        pub extends: Option<String>,
        ///If this item should be excluded from any generated
        ///documents although it may still be used during assessments.
        pub hidden: bool,
        ///If benchmark producers should prohibit changes to
        ///this item during tailoring. An author should use this when they do not want to
        ///allow end users to change the item.
        pub prohibit_changes: bool,
        pub lang: Option<String>,
        pub base: Option<String>,
        ///An identifier used for referencing elements
        ///included in an XML signature
        pub xml_id: Option<String>,
        ///If true, this
        ///xccdf:Group/xccdf:Rule is selected to be processed as
        ///part of the xccdf:Benchmark when it is applied to a target
        ///system. An unselected xccdf:Group does not get processed, and
        ///its contents are not processed either (i.e., all descendants of an
        ///unselected xccdf:Group are implicitly unselected). An unselected
        ///xccdf:Rule is not checked and does not contribute to scoring.
        pub selected: bool,
        ///The relative scoring weight of this
        ///xccdf:Group/xccdf:Rule, for computing a score, expressed
        ///as a non-negative real number. It denotes the importance of an
        ///xccdf:Group/xccdf:Rule. Under some scoring models,
        ///scoring is computed independently for each collection of sibling
        ///xccdf:Group and xccdf:Rule elements, then normalized as
        ///part of the overall scoring process.
        pub weight: f64,
        ///Unique element identifier; used by other
        ///elements to refer to this element.
        pub id: String,
        pub content: Vec<GroupTypeContent>,
    }
    /// Data type for the xccdf:Group element. A
    ///xccdf:Group element contains descriptive information about a portion of an
    ///xccdf:Benchmark, as well as xccdf:Rule, xccdf:Value, and/or
    ///other xccdf:Group elements
    #[derive(Debug)]
    pub enum GroupTypeContent {
        ///Status of the item and date at which it
        ///attained that status. xccdf:Benchmark authors may use this element
        ///to record the maturity or consensus level for elements in the
        ///xccdf:Benchmark. If an item does not have an explicit
        ///xccdf:status given, then its status is that of its
        ///parent.
        Status(StatusElementType),
        ///Holds additional status information using the
        ///Dublin Core format.
        DcStatus(DcStatusType),
        ///Version information about this item.
        Version(VersionType),
        ///Title of the item. Every item should have an
        ///xccdf:title, because this helps people understand the purpose of the
        ///item.
        Title(TextWithSubType),
        ///Text that describes the item.
        Description(HtmlTextWithSubType),
        ///A note or caveat about the item intended to
        ///convey important cautionary information for the xccdf:Benchmark user
        ///(e.g., “Complying with this rule will cause the system to reject all IP
        ///packets”). If multiple xccdf:warning elements appear, benchmark
        ///consumers should concatenate them for generating reports or documents.
        ///Benchmark consumers may present this information in a special manner in
        ///generated documents.
        Warning(WarningType),
        ///Interrogative text to present to the user
        ///during tailoring. It may also be included into a generated document. For
        ///xccdf:Rule and xccdf:Group elements, the
        ///xccdf:question text should be a simple binary (yes/no) question
        ///because it is supporting the selection aspect of tailoring. For
        ///xccdf:Value elements, the xccdf:question should solicit the
        ///user to provide a specific value. Tools may also display constraints on
        ///values and any defaults as specified by the other xccdf:Value
        ///properties.
        Question(TextType),
        ///References where the user can learn more about
        ///the subject of this item.
        Reference(ReferenceType),
        ///XML metadata associated with this item, such as
        ///sources, special information, or other details.
        Metadata(MetadataType),
        ///Descriptive text giving rationale or
        ///motivations for abiding by this
        ///xccdf:Group/xccdf:Rule (i.e., why it is important to
        ///the security of the target platform).
        Rationale(HtmlTextWithSubType),
        ///Platforms to which this
        ///xccdf:Group/xccdf:Rule applies.
        Platform(OverrideableCpe2IdrefType),
        ///The identifiers of other
        ///xccdf:Group or xccdf:Rule elements that must be
        ///selected for this xccdf:Group/xccdf:Rule to be
        ///evaluated and scored properly. Each xccdf:requires element
        ///specifies a list of one or more required items by their identifiers.
        ///If at least one of the specified xccdf:Group or
        ///xccdf:Rule elements is selected, the requirement is met.
        Requires(IdrefListType),
        ///The identifier of another
        ///xccdf:Group or xccdf:Rule that must be unselected
        ///for this xccdf:Group/xccdf:Rule to be evaluated and
        ///scored properly. Each xccdf:conflicts element specifies a
        ///single conflicting item using its idref attribute. If the specified
        ///xccdf:Group or xccdf:Rule element is not selected,
        ///the requirement is met.
        Conflicts(IdrefType),
        ///xccdf:Value elements that
        ///belong to this xccdf:Group.
        Value(ValueType),
        ///Sub-xccdf:Groups under this
        ///xccdf:Group.
        Group(GroupType),
        ///xccdf:Rule elements that
        ///belong to this xccdf:Group.
        Rule(RuleType),
        ///A digital signature asserting
        ///authorship and allowing verification of the integrity of the
        ///xccdf:Group.
        Signature(SignatureType),
    }
    impl GroupType {
        #[must_use]
        pub fn default_abstract_() -> bool {
            false
        }
        #[must_use]
        pub fn default_hidden() -> bool {
            false
        }
        #[must_use]
        pub fn default_prohibit_changes() -> bool {
            false
        }
        #[must_use]
        pub fn default_selected() -> bool {
            true
        }
        #[must_use]
        pub fn default_weight() -> f64 {
            1f64
        }
    }
    impl WithSerializer for GroupType {
        type Serializer<'x> = quick_xml_serialize::GroupTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::GroupTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::GroupTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:groupType"),
                is_root,
            })
        }
    }
    impl WithSerializer for GroupTypeContent {
        type Serializer<'x> = quick_xml_serialize::GroupTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::GroupTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::GroupTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for GroupType {
        type Deserializer = quick_xml_deserialize::GroupTypeDeserializer;
    }
    impl WithDeserializer for GroupTypeContent {
        type Deserializer = quick_xml_deserialize::GroupTypeContentDeserializer;
    }
    /// Data type for the xccdf:Rule element that
    ///represents a specific xccdf:Benchmark test.
    #[derive(Debug)]
    pub struct RuleType {
        ///If true, then this item is abstract and exists only
        ///to be extended. The use of this attribute for xccdf:Group elements is
        ///deprecated and should be avoided.
        pub abstract_: bool,
        ///An identifier to be used as a means to identify
        ///(refer to) related items. It designates membership in a cluster of items, which
        ///are used for controlling items via xccdf:Profile elements. All the items
        ///with the same cluster identifier belong to the same cluster. A selector in an
        ///xccdf:Profile may refer to a cluster, thus making it easier for authors
        ///to create and maintain xccdf:Profile elements in a complex
        ///xccdf:Benchmark.
        pub cluster_id: Option<String>,
        ///The identifier of an item on which to base this
        ///item. If present, it must have a value equal to the @id attribute of another
        ///item. The use of this attribute for xccdf:Group elements is deprecated
        ///and should be avoided.
        pub extends: Option<String>,
        ///If this item should be excluded from any generated
        ///documents although it may still be used during assessments.
        pub hidden: bool,
        ///If benchmark producers should prohibit changes to
        ///this item during tailoring. An author should use this when they do not want to
        ///allow end users to change the item.
        pub prohibit_changes: bool,
        pub lang: Option<String>,
        pub base: Option<String>,
        ///An identifier used for referencing elements
        ///included in an XML signature
        pub xml_id: Option<String>,
        ///If true, this
        ///xccdf:Group/xccdf:Rule is selected to be processed as
        ///part of the xccdf:Benchmark when it is applied to a target
        ///system. An unselected xccdf:Group does not get processed, and
        ///its contents are not processed either (i.e., all descendants of an
        ///unselected xccdf:Group are implicitly unselected). An unselected
        ///xccdf:Rule is not checked and does not contribute to scoring.
        pub selected: bool,
        ///The relative scoring weight of this
        ///xccdf:Group/xccdf:Rule, for computing a score, expressed
        ///as a non-negative real number. It denotes the importance of an
        ///xccdf:Group/xccdf:Rule. Under some scoring models,
        ///scoring is computed independently for each collection of sibling
        ///xccdf:Group and xccdf:Rule elements, then normalized as
        ///part of the overall scoring process.
        pub weight: f64,
        ///Unique element identifier used by other
        ///elements to refer to this element.
        pub id: String,
        ///The xccdf:Rule element’s role in
        ///scoring and reporting.
        pub role: RoleEnumType,
        ///Severity level code to be used for metrics
        ///and tracking.
        pub severity: SeverityEnumType,
        ///Applicable in cases where there are
        ///multiple instances of a target. For example, an xccdf:Rule may
        ///provide a recommendation about the configuration of application user
        ///accounts, but an application may have many user accounts. Each account
        ///would be considered an instance of the broader assessment target of user
        ///accounts. If the @multiple attribute is set to true, each instance of
        ///the target to which the xccdf:Rule can apply should be tested
        ///separately and the results should be recorded separately. If @multiple
        ///is set to false, the test results of such instances should be combined.
        ///If the checking system does not combine these results automatically, the
        ///results of each instance should be ANDed together to produce a single
        ///result. If the benchmark consumer cannot perform multiple instantiation,
        ///or if multiple instantiation of the xccdf:Rule is not applicable
        ///for the target system, then the benchmark consumer may ignore this
        ///attribute.
        pub multiple: bool,
        pub content: Vec<RuleTypeContent>,
    }
    /// Data type for the xccdf:Rule element that
    ///represents a specific xccdf:Benchmark test.
    #[derive(Debug)]
    pub enum RuleTypeContent {
        ///Status of the item and date at which it
        ///attained that status. xccdf:Benchmark authors may use this element
        ///to record the maturity or consensus level for elements in the
        ///xccdf:Benchmark. If an item does not have an explicit
        ///xccdf:status given, then its status is that of its
        ///parent.
        Status(StatusElementType),
        ///Holds additional status information using the
        ///Dublin Core format.
        DcStatus(DcStatusType),
        ///Version information about this item.
        Version(VersionType),
        ///Title of the item. Every item should have an
        ///xccdf:title, because this helps people understand the purpose of the
        ///item.
        Title(TextWithSubType),
        ///Text that describes the item.
        Description(HtmlTextWithSubType),
        ///A note or caveat about the item intended to
        ///convey important cautionary information for the xccdf:Benchmark user
        ///(e.g., “Complying with this rule will cause the system to reject all IP
        ///packets”). If multiple xccdf:warning elements appear, benchmark
        ///consumers should concatenate them for generating reports or documents.
        ///Benchmark consumers may present this information in a special manner in
        ///generated documents.
        Warning(WarningType),
        ///Interrogative text to present to the user
        ///during tailoring. It may also be included into a generated document. For
        ///xccdf:Rule and xccdf:Group elements, the
        ///xccdf:question text should be a simple binary (yes/no) question
        ///because it is supporting the selection aspect of tailoring. For
        ///xccdf:Value elements, the xccdf:question should solicit the
        ///user to provide a specific value. Tools may also display constraints on
        ///values and any defaults as specified by the other xccdf:Value
        ///properties.
        Question(TextType),
        ///References where the user can learn more about
        ///the subject of this item.
        Reference(ReferenceType),
        ///XML metadata associated with this item, such as
        ///sources, special information, or other details.
        Metadata(MetadataType),
        ///Descriptive text giving rationale or
        ///motivations for abiding by this
        ///xccdf:Group/xccdf:Rule (i.e., why it is important to
        ///the security of the target platform).
        Rationale(HtmlTextWithSubType),
        ///Platforms to which this
        ///xccdf:Group/xccdf:Rule applies.
        Platform(OverrideableCpe2IdrefType),
        ///The identifiers of other
        ///xccdf:Group or xccdf:Rule elements that must be
        ///selected for this xccdf:Group/xccdf:Rule to be
        ///evaluated and scored properly. Each xccdf:requires element
        ///specifies a list of one or more required items by their identifiers.
        ///If at least one of the specified xccdf:Group or
        ///xccdf:Rule elements is selected, the requirement is met.
        Requires(IdrefListType),
        ///The identifier of another
        ///xccdf:Group or xccdf:Rule that must be unselected
        ///for this xccdf:Group/xccdf:Rule to be evaluated and
        ///scored properly. Each xccdf:conflicts element specifies a
        ///single conflicting item using its idref attribute. If the specified
        ///xccdf:Group or xccdf:Rule element is not selected,
        ///the requirement is met.
        Conflicts(IdrefType),
        ///A globally meaningful identifier for
        ///this xccdf:Rule. This may be the name or identifier of a
        ///security configuration issue or vulnerability that the
        ///xccdf:Rule assesses.
        Ident(IdentType),
        ///The potential impact of failure to
        ///conform to the xccdf:Rule, expressed as a CVSS 2.0 base
        ///vector.
        ImpactMetric(String),
        ///Text that describes special aspects of
        ///the xccdf:Rule related to one or more xccdf:Profile
        ///elements. This allows an author to document things within
        ///xccdf:Rule elements that are specific to a given
        ///xccdf:Profile, and then select the appropriate text based on
        ///the selected xccdf:Profile and display it to the
        ///reader.
        ProfileNote(ProfileNoteType),
        ///Data that describes how to bring a
        ///target system into compliance with this
        ///xccdf:Rule.
        Fixtext(FixTextType),
        ///A command string, script, or other
        ///system modification statement that, if executed on the target
        ///system, can bring it into full, or at least better, compliance with
        ///this xccdf:Rule.
        Fix(FixType),
        ///The definition of, or a reference
        ///to, the target system check needed to test compliance with this
        ///xccdf:Rule. Sibling xccdf:check elements must
        ///have different values for the combination of their @selector and
        ///@system attributes, and must have different values for their @id
        ///attribute (if any).
        Check(CheckType),
        ///A boolean expression composed of
        ///operators (and, or, not) and individual
        ///checks.
        ComplexCheck(ComplexCheckType),
        ///A digital signature asserting
        ///authorship and allowing verification of the integrity of the
        ///xccdf:Rule.
        Signature(SignatureType),
    }
    impl RuleType {
        #[must_use]
        pub fn default_abstract_() -> bool {
            false
        }
        #[must_use]
        pub fn default_hidden() -> bool {
            false
        }
        #[must_use]
        pub fn default_prohibit_changes() -> bool {
            false
        }
        #[must_use]
        pub fn default_selected() -> bool {
            true
        }
        #[must_use]
        pub fn default_weight() -> f64 {
            1f64
        }
        #[must_use]
        pub fn default_role() -> RoleEnumType {
            RoleEnumType::Full
        }
        #[must_use]
        pub fn default_severity() -> SeverityEnumType {
            SeverityEnumType::Unknown
        }
        #[must_use]
        pub fn default_multiple() -> bool {
            false
        }
    }
    impl WithSerializer for RuleType {
        type Serializer<'x> = quick_xml_serialize::RuleTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::RuleTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::RuleTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:ruleType"),
                is_root,
            })
        }
    }
    impl WithSerializer for RuleTypeContent {
        type Serializer<'x> = quick_xml_serialize::RuleTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::RuleTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::RuleTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for RuleType {
        type Deserializer = quick_xml_deserialize::RuleTypeDeserializer;
    }
    impl WithDeserializer for RuleTypeContent {
        type Deserializer = quick_xml_deserialize::RuleTypeContentDeserializer;
    }
    /// Data type for the xccdf:TestResult element,
    ///which holds the results of one application of the xccdf:Benchmark. The
    ///xccdf:TestResult element normally appears as the child of the
    ///xccdf:Benchmark element, although it may also appear as the top-level
    ///element of an XCCDF results document. XCCDF is not intended to be a database format
    ///for detailed results; the xccdf:TestResult element offers a way to store the
    ///results of individual tests in modest detail, with the ability to reference
    ///lower-level testing data. Although several of the child elements of this type
    ///technically support the @override attribute, the xccdf:TestResult element
    ///cannot be extended. Therefore, @override has no meaning within an
    ///xccdf:TestResult element and its children, and should not be used for
    ///them.
    #[derive(Debug)]
    pub struct TestResultType {
        ///Unique identifier for this
        ///element.
        pub id: String,
        ///Time when testing began.
        pub start_time: Option<String>,
        ///Time when testing was completed and the results
        ///recorded.
        pub end_time: String,
        ///Name of the benchmark consumer program that
        ///generated this xccdf:TestResult element; should be either a CPE name or
        ///a CPE applicability language expression.
        pub test_system: Option<String>,
        ///The version number string copied from the
        ///xccdf:Benchmark used to direct this assessment.
        pub version: Option<String>,
        ///An identifier used for referencing elements
        ///included in an XML signature.
        pub xml_id: Option<String>,
        pub content: Vec<TestResultTypeContent>,
    }
    /// Data type for the xccdf:TestResult element,
    ///which holds the results of one application of the xccdf:Benchmark. The
    ///xccdf:TestResult element normally appears as the child of the
    ///xccdf:Benchmark element, although it may also appear as the top-level
    ///element of an XCCDF results document. XCCDF is not intended to be a database format
    ///for detailed results; the xccdf:TestResult element offers a way to store the
    ///results of individual tests in modest detail, with the ability to reference
    ///lower-level testing data. Although several of the child elements of this type
    ///technically support the @override attribute, the xccdf:TestResult element
    ///cannot be extended. Therefore, @override has no meaning within an
    ///xccdf:TestResult element and its children, and should not be used for
    ///them.
    #[derive(Debug)]
    pub enum TestResultTypeContent {
        ///Reference to the xccdf:Benchmark for
        ///which the xccdf:TestResult records results. This property is
        ///required if this xccdf:TestResult element is the top-level element
        ///and optional otherwise.
        Benchmark(BenchmarkReferenceType),
        ///The tailoring file element contains attributes
        ///used to identify an xccdf:Tailoring element used to guide the
        ///assessment reported on in this xccdf:TestResult. The tailoring
        ///element is required in an xccdf:TestResult if and only if an
        ///xccdf:Tailoring element guided the assessment recorded in the
        ///xccdf:TestResult or if the xccdf:Tailoring element records
        ///manual tailoring actions applied to this assessment.
        TailoringFile(TailoringReferenceType),
        ///Title of the test.
        Title(TextType),
        ///A remark about the test, possibly supplied by
        ///the person administering the xccdf:Benchmark
        ///assessment
        Remark(TextType),
        ///The name of the organization or other entity
        ///responsible for applying this xccdf:Benchmark and generating this
        ///result. When multiple xccdf:organization elements are used to
        ///indicate multiple organization names in a hierarchical organization, the
        ///highest-level organization should appear first.
        Organization(String),
        ///Information about the system identity or user
        ///employed during application of the xccdf:Benchmark. If used,
        ///specifies the name of the authenticated identity.
        Identity(IdentityType),
        ///The xccdf:profile element holds the
        ///value of the @id attribute value of the xccdf:Profile selected to be
        ///used in the assessment reported on by this xccdf:TestResult. This
        ///xccdf:Profile might be from the xccdf:Benchmark or from an
        ///xccdf:Tailoring file, if used. This element should appear if and
        ///only if an xccdf:Profile was selected to guide the
        ///assessment.
        Profile(IdrefType),
        ///Name or description of the target system whose
        ///test results are recorded in the xccdf:TestResult element (the
        ///system to which an xccdf:Benchmark test was applied). Each
        ///appearance of the element supplies a name by which the target host or device
        ///was identified at the time the test was run. The name may be any string, but
        ///applications should include the fully qualified DNS name whenever possible.
        Target(String),
        ///Network address of the target system to which
        ///an xccdf:Benchmark test was applied. Typical forms for the address
        ///include IP version 4 (IPv4), IP version 6 (IPv6), and Ethernet media access
        ///control (MAC).
        TargetAddress(String),
        ///A list of named facts about the target system
        ///or platform.
        TargetFacts(TargetFactsType),
        ///References to external structures with
        ///identifying information about the target of this
        ///assessment.
        TargetIdRef(TargetIdRefType),
        Any(AnyElement),
        ///A platform on the target system. There should
        ///be one instance of this property for every platform that the target system
        ///was found to meet.
        Platform(Cpe2IdrefType),
        ///Specific setting for a single
        ///xccdf:Value element used during the test.
        SetValue(ProfileSetValueType),
        ///Specific setting for a single
        ///xccdf:Value element used during the test when the given value is
        ///set to a complex type, such as a list.
        SetComplexValue(ProfileSetComplexValueType),
        ///The result of a single instance of an
        ///xccdf:Rule application against the target. The
        ///xccdf:TestResult must include at least one xccdf:rule-result
        ///record for each xccdf:Rule that was selected in the resolved
        ///xccdf:Benchmark.
        RuleResult(RuleResultType),
        ///An overall score for this
        ///xccdf:Benchmark test.
        Score(ScoreType),
        ///XML metadata associated with this
        ///xccdf:TestResult.
        Metadata(MetadataType),
        ///A digital signature asserting authorship and
        ///allowing verification of the integrity of the xccdf:TestResult.
        Signature(SignatureType),
    }
    impl WithSerializer for TestResultType {
        type Serializer<'x> = quick_xml_serialize::TestResultTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TestResultTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TestResultTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:testResultType"),
                is_root,
            })
        }
    }
    impl WithSerializer for TestResultTypeContent {
        type Serializer<'x> = quick_xml_serialize::TestResultTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::TestResultTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TestResultTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for TestResultType {
        type Deserializer = quick_xml_deserialize::TestResultTypeDeserializer;
    }
    impl WithDeserializer for TestResultTypeContent {
        type Deserializer = quick_xml_deserialize::TestResultTypeContentDeserializer;
    }
    /// The type of an XMLDSig:signature element,
    ///which holds an enveloped digital signature asserting authorship and allowing
    ///verification of the integrity of associated data (e.g., its parent element, other
    ///documents, portions of other documents).
    #[derive(Debug)]
    pub struct SignatureType {
        pub any: AnyElement,
    }
    impl WithSerializer for SignatureType {
        type Serializer<'x> = quick_xml_serialize::SignatureTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SignatureTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SignatureTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:signatureType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SignatureType {
        type Deserializer = quick_xml_deserialize::SignatureTypeDeserializer;
    }
    /// The statusType represents the possible levels of
    ///maturity or consensus level for its parent element as recorded by an
    ///xccdf:status element.
    #[derive(Debug)]
    pub enum StatusType {
        ///Released as final
        Accepted,
        ///No longer needed
        Deprecated,
        ///Released in draft state
        Draft,
        ///Under initial development
        Incomplete,
        ///Revised and in the process of being
        ///finalized
        Interim,
    }
    impl SerializeBytes for StatusType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Accepted => Ok(Some(Cow::Borrowed("accepted"))),
                Self::Deprecated => Ok(Some(Cow::Borrowed("deprecated"))),
                Self::Draft => Ok(Some(Cow::Borrowed("draft"))),
                Self::Incomplete => Ok(Some(Cow::Borrowed("incomplete"))),
                Self::Interim => Ok(Some(Cow::Borrowed("interim"))),
            }
        }
    }
    impl DeserializeBytes for StatusType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"accepted" => Ok(Self::Accepted),
                b"deprecated" => Ok(Self::Deprecated),
                b"draft" => Ok(Self::Draft),
                b"incomplete" => Ok(Self::Incomplete),
                b"interim" => Ok(Self::Interim),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    ///The type used for xccdf:sub elements. The
    ///xccdf:sub element identifies replacement content that should appear in place
    ///of the xccdf:sub element during text substitution. The subType consists of a
    ///regular idrefType with an additional @use attribute to dictate the behavior of the
    ///xccdf:sub element under substitution. When the @idref is to an
    ///xccdf:Value, the @use attribute indicates whether the xccdf:Value
    ///element's title or value should replace the xccdf:sub element. The @use
    ///attribute is ignored when the @idref is to an xccdf:plain-text element; the
    ///body of the xccdf:plain-text element is always used to replace the
    ///xccdf:sub element.
    #[derive(Debug)]
    pub struct SubType {
        ///The id value of another XCCDF
        ///element
        pub idref: String,
        ///Dictates the nature of the content inserted
        ///under text substitution processing.
        pub use_: SubUseEnumType,
    }
    impl SubType {
        #[must_use]
        pub fn default_use_() -> SubUseEnumType {
            SubUseEnumType::Value
        }
    }
    impl WithSerializer for SubType {
        type Serializer<'x> = quick_xml_serialize::SubTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SubTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SubTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:subType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SubType {
        type Deserializer = quick_xml_deserialize::SubTypeDeserializer;
    }
    /// Type for a parameter used in the xccdf:model
    ///element, which records scoring model information. The contents of this type
    ///represent a name-value pair, where the name is recorded in the @name attribute and
    ///the value appears in the element body. xccdf:param elements with equal
    ///values for the @name attribute may not appear as children of the same
    ///xccdf:model element.
    #[derive(Debug)]
    pub struct ParamType {
        ///The name associated with the contained
        ///value.
        pub name: String,
        pub content: String,
    }
    impl WithSerializer for ParamType {
        type Serializer<'x> = quick_xml_serialize::ParamTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ParamTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ParamTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:paramType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ParamType {
        type Deserializer = quick_xml_deserialize::ParamTypeDeserializer;
    }
    /// Type for a string with embedded xccdf:Value
    ///substitutions and an @override attribute to help manage inheritance.
    #[derive(Debug)]
    pub struct TextWithSubType {
        pub lang: Option<String>,
        ///Used to manage inheritance.
        pub override_: bool,
        pub text_before: Option<Text>,
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text substitution.
        pub sub: Vec<Mixed<SubType>>,
    }
    impl TextWithSubType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
    }
    impl WithSerializer for TextWithSubType {
        type Serializer<'x> = quick_xml_serialize::TextWithSubTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TextWithSubTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TextWithSubTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:textWithSubType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TextWithSubType {
        type Deserializer = quick_xml_deserialize::TextWithSubTypeDeserializer;
    }
    ///Data type for xccdf:platform elements that need
    ///@override attributes. (I.e., xccdf:platform elements that are in structures
    ///that can be extended, such as Items and xccdf:Profile elements.) This is
    ///used to identify the applicable target platform for its respective parent elements.
    #[derive(Debug)]
    pub struct OverrideableCpe2IdrefType {
        ///Should be a CPE 2.3 Applicability Language
        ///identifier using the Formatted String binding or the value of a
        ///cpe:platform-specification element's @id attribute, the latter acting as
        ///a reference to some expression defined using the CPE schema in the
        ///xccdf:Benchmark element's cpe:platform-specification element.
        ///The @idref may be a CPE Applicability Language identifier using the URI binding,
        ///although this is less preferred.
        pub idref: String,
        ///Used to manage inheritance.
        pub override_: bool,
    }
    impl OverrideableCpe2IdrefType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
    }
    impl WithSerializer for OverrideableCpe2IdrefType {
        type Serializer<'x> = quick_xml_serialize::OverrideableCpe2IdrefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::OverrideableCpe2IdrefTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::OverrideableCpe2IdrefTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("cdf:overrideableCPE2idrefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for OverrideableCpe2IdrefType {
        type Deserializer = quick_xml_deserialize::OverrideableCpe2IdrefTypeDeserializer;
    }
    /// Type for the xccdf:select element in an
    ///xccdf:Profile. This element designates an xccdf:Rule,
    ///xccdf:Group, or cluster of xccdf:Rule and xccdf:Group
    ///elements and overrides the @selected attribute on the designated items, providing a
    ///means for including or excluding xccdf:Rule elements from an
    ///assessment.
    #[derive(Debug)]
    pub struct ProfileSelectType {
        ///The @id value of an xccdf:Rule or
        ///xccdf:Group, or the @cluster-id value of one or more xccdf:Rule
        ///or xccdf:Group elements.
        pub idref: String,
        ///The new value for the indicated item's @selected
        ///property.
        pub selected: bool,
        ///Explanatory material or other
        ///prose.
        pub remark: Vec<TextType>,
    }
    impl WithSerializer for ProfileSelectType {
        type Serializer<'x> = quick_xml_serialize::ProfileSelectTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileSelectTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileSelectTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileSelectType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ProfileSelectType {
        type Deserializer = quick_xml_deserialize::ProfileSelectTypeDeserializer;
    }
    /// Type for the xccdf:set-complex-value element
    ///in an xccdf:Profile. This element supports the direct specification of
    ///complex value types such as lists. Zero or more xccdf:item elements may
    ///appear as children of this element; if no child elements are present, this element
    ///represents an empty list. This overrides the xccdf:value and
    ///xccdf:complex-value element(s) of an xccdf:Value
    ///element.
    #[derive(Debug)]
    pub struct ProfileSetComplexValueType {
        ///The @id value of an xccdf:Value or
        ///the @cluster-id value of one or more xccdf:Value elements
        pub idref: String,
        ///A single item in the list of values.
        pub item: Vec<String>,
    }
    impl WithSerializer for ProfileSetComplexValueType {
        type Serializer<'x> = quick_xml_serialize::ProfileSetComplexValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileSetComplexValueTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ProfileSetComplexValueTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("cdf:profileSetComplexValueType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ProfileSetComplexValueType {
        type Deserializer = quick_xml_deserialize::ProfileSetComplexValueTypeDeserializer;
    }
    /// Type for the xccdf:set-value element in an
    ///xccdf:Profile. This element upports the direct specification of simple value
    ///types such as numbers, strings, and boolean values. This overrides the
    ///xccdf:value and xccdf:complex-value element(s) of an
    ///xccdf:Value element.
    #[derive(Debug)]
    pub struct ProfileSetValueType {
        ///The @id value of an xccdf:Value or
        ///the @cluster-id value of one or more xccdf:Value elements
        pub idref: String,
        pub content: String,
    }
    impl WithSerializer for ProfileSetValueType {
        type Serializer<'x> = quick_xml_serialize::ProfileSetValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileSetValueTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileSetValueTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileSetValueType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ProfileSetValueType {
        type Deserializer = quick_xml_deserialize::ProfileSetValueTypeDeserializer;
    }
    /// Type for the xccdf:refine-value element in an
    ///xccdf:Profile. This element designates the xccdf:Value constraints
    ///to be applied during tailoring for an xccdf:Value element or the
    ///xccdf:Value members of a cluster.
    #[derive(Debug)]
    pub struct ProfileRefineValueType {
        ///The @id value of an xccdf:Value or the
        ///@cluster-id value of one or more xccdf:Value elements
        pub idref: String,
        ///Holds a selector value corresponding to the value
        ///of a @selector property in an xccdf:Value element's child properties.
        ///Properties with a matching @selector are considered active and all other
        ///properties are inactive. This may mean that, after selector application, some
        ///classes of xccdf:Value properties will be completely inactive because
        ///none of those properties had a matching @selector. The only exception is the
        ///xccdf:value and xccdf:complex-value properties of an
        ///xccdf:Value element - if there is no xccdf:value or
        ///xccdf:complex-value property with a matching @selector value then the
        ///xccdf:value/xccdf:complex-value property with an empty or absent
        ///@selector attribute becomes active. If there is no such xccdf:value or
        ///xccdf:complex-value, then the first xccdf:value or
        ///xccdf:complex-value listed in the XML becomes active. This reflects the
        ///fact that all xccdf:Value elements require an active value property at
        ///all times.
        pub selector: Option<String>,
        ///The new value for the identified
        ///xccdf:Value element's @operator property.
        pub operator: Option<ValueOperatorType>,
        ///Explanatory material or other
        ///prose.
        pub remark: Vec<TextType>,
    }
    impl WithSerializer for ProfileRefineValueType {
        type Serializer<'x> = quick_xml_serialize::ProfileRefineValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileRefineValueTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileRefineValueTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileRefineValueType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ProfileRefineValueType {
        type Deserializer = quick_xml_deserialize::ProfileRefineValueTypeDeserializer;
    }
    /// Type for the xccdf:refine-rule element in an
    ///xccdf:Profile. A xccdf:refine-rule element allows the author to
    ///select xccdf:check statements and override the @weight, @severity, and @role
    ///of an xccdf:Rule, xccdf:Group, or cluster of xccdf:Rule and
    ///xccdf:Group elements. Despite the name, this selector does apply for
    ///xccdf:Group elements and for clusters that include xccdf:Group
    ///elements, but it only affects their @weight attribute.
    #[derive(Debug)]
    pub struct ProfileRefineRuleType {
        ///The @id value of an xccdf:Rule or
        ///xccdf:Group, or the @cluster-id value of one or more xccdf:Rule
        ///or xccdf:Group elements.
        pub idref: String,
        ///The new value for the identified element's @weight
        ///property.
        pub weight: Option<f64>,
        ///Holds a selector value corresponding to the value
        ///of a @selector property in an xccdf:Rule element's xccdf:check
        ///element. If the selector specified does not match any of the @selector
        ///attributes specified on any of the xccdf:check children of an
        ///xccdf:Rule, then the xccdf:check child element without a
        ///@selector attribute is used. If there is no child without a @selector attribute,
        ///then that Rule would have no effective xccdf:check
        ///element.
        pub selector: Option<String>,
        ///The new value for the identified xccdf:Rule
        ///element's @severity property.
        pub severity: Option<SeverityEnumType>,
        ///The new value for the identified xccdf:Rule
        ///element's @role property.
        pub role: Option<RoleEnumType>,
        ///Explanatory material or other
        ///prose.
        pub remark: Vec<TextType>,
    }
    impl WithSerializer for ProfileRefineRuleType {
        type Serializer<'x> = quick_xml_serialize::ProfileRefineRuleTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileRefineRuleTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileRefineRuleTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileRefineRuleType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ProfileRefineRuleType {
        type Deserializer = quick_xml_deserialize::ProfileRefineRuleTypeDeserializer;
    }
    ///Allowed data types for xccdf:Value elements,
    ///string, numeric, and boolean. A tool may choose any convenient form to store an
    ///xccdf:Value element’s xccdf:value element, but the @type conveys how
    ///the value should be treated for user input validation purposes during tailoring
    ///processing. The @type may also be used to give additional guidance to the user or to
    ///validate the user’s input. For example, if an xccdf:value element’s @type
    ///attribute is “number”, then a tool might choose to reject user tailoring input that
    ///is not composed of digits. In the case of a list of values, the @type applies to all
    ///elements of the list individually. Note that checking systems may have their own
    ///understanding of data types that may not be identical to the typing indicated in
    ///XCCDF
    #[derive(Debug)]
    pub enum ValueTypeType {
        ///A numeric value. This may be decimal or
        ///integer.
        Number,
        ///Any character data
        String,
        ///True/false
        Boolean,
    }
    impl SerializeBytes for ValueTypeType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Number => Ok(Some(Cow::Borrowed("number"))),
                Self::String => Ok(Some(Cow::Borrowed("string"))),
                Self::Boolean => Ok(Some(Cow::Borrowed("boolean"))),
            }
        }
    }
    impl DeserializeBytes for ValueTypeType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"number" => Ok(Self::Number),
                b"string" => Ok(Self::String),
                b"boolean" => Ok(Self::Boolean),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// This type enumerates allowed values of the @operator
    ///property of xccdf:Value elements. The specific interpretation of these
    ///operators depends on the checking system used.
    #[derive(Debug)]
    pub enum ValueOperatorType {
        Equals,
        NotEqual,
        GreaterThan,
        LessThan,
        GreaterThanOrEqual,
        LessThanOrEqual,
        PatternMatch,
    }
    impl SerializeBytes for ValueOperatorType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Equals => Ok(Some(Cow::Borrowed("equals"))),
                Self::NotEqual => Ok(Some(Cow::Borrowed("not equal"))),
                Self::GreaterThan => Ok(Some(Cow::Borrowed("greater than"))),
                Self::LessThan => Ok(Some(Cow::Borrowed("less than"))),
                Self::GreaterThanOrEqual => Ok(Some(Cow::Borrowed("greater than or equal"))),
                Self::LessThanOrEqual => Ok(Some(Cow::Borrowed("less than or equal"))),
                Self::PatternMatch => Ok(Some(Cow::Borrowed("pattern match"))),
            }
        }
    }
    impl DeserializeBytes for ValueOperatorType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"equals" => Ok(Self::Equals),
                b"not equal" => Ok(Self::NotEqual),
                b"greater than" => Ok(Self::GreaterThan),
                b"less than" => Ok(Self::LessThan),
                b"greater than or equal" => Ok(Self::GreaterThanOrEqual),
                b"less than or equal" => Ok(Self::LessThanOrEqual),
                b"pattern match" => Ok(Self::PatternMatch),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Allowed interface hint values. xccdf:Value
    ///elements may contain a hint or recommendation to a benchmark consumer or producer
    ///about how the user might select or adjust the xccdf:Value. This type
    ///enumerates the possible values of this hint.
    #[derive(Debug)]
    pub enum InterfaceHintType {
        ///Multiple choice
        Choice,
        ///Multiple lines of text
        Textline,
        ///Single line of text
        Text,
        ///Date
        Date,
        ///Date and time
        Datetime,
    }
    impl SerializeBytes for InterfaceHintType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Choice => Ok(Some(Cow::Borrowed("choice"))),
                Self::Textline => Ok(Some(Cow::Borrowed("textline"))),
                Self::Text => Ok(Some(Cow::Borrowed("text"))),
                Self::Date => Ok(Some(Cow::Borrowed("date"))),
                Self::Datetime => Ok(Some(Cow::Borrowed("datetime"))),
            }
        }
    }
    impl DeserializeBytes for InterfaceHintType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"choice" => Ok(Self::Choice),
                b"textline" => Ok(Self::Textline),
                b"text" => Ok(Self::Text),
                b"date" => Ok(Self::Date),
                b"datetime" => Ok(Self::Datetime),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Data type for the xccdf:warning element under
    ///the xccdf:Rule element. This element holds a note or caveat about the item
    ///intended to convey important cautionary information for the xccdf:Benchmark
    ///user.
    #[derive(Debug)]
    pub struct WarningType {
        pub lang: Option<String>,
        ///Used to manage inheritance.
        pub override_: bool,
        ///A hint as to the nature of the
        ///warning.
        pub category: WarningCategoryEnumType,
        pub content: Vec<WarningTypeContent>,
    }
    /// Data type for the xccdf:warning element under
    ///the xccdf:Rule element. This element holds a note or caveat about the item
    ///intended to convey important cautionary information for the xccdf:Benchmark
    ///user.
    #[derive(Debug)]
    pub enum WarningTypeContent {
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text
        ///substitution
        Sub(SubType),
        Any(AnyElement),
        Text(Text),
    }
    impl WarningType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
        #[must_use]
        pub fn default_category() -> WarningCategoryEnumType {
            WarningCategoryEnumType::General
        }
    }
    impl WithSerializer for WarningType {
        type Serializer<'x> = quick_xml_serialize::WarningTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::WarningTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::WarningTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:warningType"),
                is_root,
            })
        }
    }
    impl WithSerializer for WarningTypeContent {
        type Serializer<'x> = quick_xml_serialize::WarningTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::WarningTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::WarningTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for WarningType {
        type Deserializer = quick_xml_deserialize::WarningTypeDeserializer;
    }
    impl WithDeserializer for WarningTypeContent {
        type Deserializer = quick_xml_deserialize::WarningTypeContentDeserializer;
    }
    /// This type is for an element that has string content
    ///and a @selector attribute for use in tailoring.
    #[derive(Debug)]
    pub struct SelStringType {
        ///This may be referenced from
        ///xccdf:Profile selection elements or used during manual tailoring
        ///to refine the application of this property. If no selectors are
        ///specified for a given property by xccdf:Profile elements or
        ///manual tailoring, properties with empty or non-existent @selector
        ///attributes are activated. If a selector is applied that does not match
        ///the @selector attribute of any of a given type of property, then no
        ///property of that type is considered activated. The only exception is the
        ///xccdf:value and xccdf:complex-value properties of an
        ///xccdf:Value element - if there is no xccdf:value or
        ///xccdf:complex-value property with a matching @selector value
        ///then the xccdf:value/xccdf:complex-value property with
        ///an empty or absent @selector attribute becomes active. If there is no
        ///such xccdf:value or xccdf:complex-value, then the first
        ///xccdf:value or xccdf:complex-value listed in the XML
        ///becomes active. This reflects the fact that all xccdf:Value
        ///elements require an active value property at all
        ///times.
        pub selector: String,
        pub content: String,
    }
    impl SelStringType {
        #[must_use]
        pub fn default_selector() -> String {
            String::from("")
        }
    }
    impl WithSerializer for SelStringType {
        type Serializer<'x> = quick_xml_serialize::SelStringTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SelStringTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SelStringTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:selStringType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SelStringType {
        type Deserializer = quick_xml_deserialize::SelStringTypeDeserializer;
    }
    /// Data type that supports values that are lists of
    ///simple types with an associated @selector attribute used in tailoring.
    #[derive(Debug)]
    pub struct SelComplexValueType {
        ///This may be referenced from
        ///xccdf:Profile selection elements or used during manual tailoring
        ///to refine the application of this property. If no selectors are
        ///specified for a given item by xccdf:Profile elements or manual
        ///tailoring, properties with empty or non-existent @selector attributes
        ///are activated. If a selector is applied that does not match the
        ///@selector attribute of any of a given type of property, then no
        ///xccdf:choices element is considered activated. The only
        ///exception is the xccdf:value and xccdf:complex-value
        ///properties of an xccdf:Value element - if there is no
        ///xccdf:value or xccdf:complex-value property with a
        ///matching @selector value then the
        ///xccdf:value/xccdf:complex-value property with an empty
        ///or absent @selector attribute becomes active. If there is no such
        ///xccdf:value or xccdf:complex-value, then the first
        ///xccdf:value or xccdf:complex-value listed becomes
        ///active. This reflects the fact that all xccdf:Value elements
        ///require an active value property at all times.
        pub selector: String,
        ///A single item in the list of values.
        pub item: Vec<String>,
    }
    impl SelComplexValueType {
        #[must_use]
        pub fn default_selector() -> String {
            String::from("")
        }
    }
    impl WithSerializer for SelComplexValueType {
        type Serializer<'x> = quick_xml_serialize::SelComplexValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SelComplexValueTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SelComplexValueTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:selComplexValueType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SelComplexValueType {
        type Deserializer = quick_xml_deserialize::SelComplexValueTypeDeserializer;
    }
    /// This type is for an element that has numeric content
    ///and a @selector attribute for use during tailoring.
    #[derive(Debug)]
    pub struct SelNumType {
        ///This may be referenced from
        ///xccdf:Profile selection elements or used during manual tailoring
        ///to refine the application of this property. If no selectors are
        ///specified for a given property by xccdf:Profile elements or
        ///manual tailoring, properties with empty or non-existent @selector
        ///attributes are activated. If a selector is applied that does not match
        ///the @selector attribute of any of a given type of property, then no
        ///property of that type considered activated.
        pub selector: String,
        pub content: f64,
    }
    impl SelNumType {
        #[must_use]
        pub fn default_selector() -> String {
            String::from("")
        }
    }
    impl WithSerializer for SelNumType {
        type Serializer<'x> = quick_xml_serialize::SelNumTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SelNumTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SelNumTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:selNumType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SelNumType {
        type Deserializer = quick_xml_deserialize::SelNumTypeDeserializer;
    }
    /// The type of the xccdf:choice element, which
    ///specifies a list of legal or suggested choices for an xccdf:Value object.
    #[derive(Debug)]
    pub struct SelChoicesType {
        ///True if the listed choices are the only permissible
        ///settings for the given xccdf:Value. False if choices not specified in
        ///this xccdf:choices element are acceptable settings for this
        ///xccdf:Value.
        pub must_match: Option<bool>,
        ///This may be referenced from xccdf:Profile
        ///selection elements or used during manual tailoring to refine the application of
        ///the xccdf:Rule. If no selectors are specified for a given
        ///xccdf:Value by xccdf:Profile elements or manual tailoring, an
        ///xccdf:choice element with an empty or non-existent @selector attribute
        ///is activated. If a selector is applied that does not match the @selector
        ///attribute of any xccdf:choices element, then no xccdf:choices
        ///element is considered activated.
        pub selector: String,
        pub content: Vec<SelChoicesTypeContent>,
    }
    /// The type of the xccdf:choice element, which
    ///specifies a list of legal or suggested choices for an xccdf:Value object.
    #[derive(Debug)]
    pub enum SelChoicesTypeContent {
        ///A single choice holding a simple type. (I.e.,
        ///number, string, or boolean.)
        Choice(String),
        ///A single choice holding a list of simple
        ///types.
        ComplexChoice(ComplexValueType),
    }
    impl SelChoicesType {
        #[must_use]
        pub fn default_selector() -> String {
            String::from("")
        }
    }
    impl WithSerializer for SelChoicesType {
        type Serializer<'x> = quick_xml_serialize::SelChoicesTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SelChoicesTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SelChoicesTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:selChoicesType"),
                is_root,
            })
        }
    }
    impl WithSerializer for SelChoicesTypeContent {
        type Serializer<'x> = quick_xml_serialize::SelChoicesTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::SelChoicesTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SelChoicesTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for SelChoicesType {
        type Deserializer = quick_xml_deserialize::SelChoicesTypeDeserializer;
    }
    impl WithDeserializer for SelChoicesTypeContent {
        type Deserializer = quick_xml_deserialize::SelChoicesTypeContentDeserializer;
    }
    /// Data type for elements that have no content and a
    ///single @uri attribute.
    #[derive(Debug)]
    pub struct UriRefType {
        ///A URI.
        pub uri: String,
    }
    impl WithSerializer for UriRefType {
        type Serializer<'x> = quick_xml_serialize::UriRefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::UriRefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::UriRefTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:uriRefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for UriRefType {
        type Deserializer = quick_xml_deserialize::UriRefTypeDeserializer;
    }
    /// Data type for elements contain list of references to
    ///other XCCDF elements
    #[derive(Debug)]
    pub struct IdrefListType {
        ///A space-separated list of id values from other
        ///XCCDF elements
        pub idref: super::xs::EntitiesType,
    }
    impl WithSerializer for IdrefListType {
        type Serializer<'x> = quick_xml_serialize::IdrefListTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::IdrefListTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::IdrefListTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:idrefListType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for IdrefListType {
        type Deserializer = quick_xml_deserialize::IdrefListTypeDeserializer;
    }
    /// Data type for elements that contain a reference to
    ///another XCCDF element
    #[derive(Debug)]
    pub struct IdrefType {
        ///The id value of another XCCDF
        ///element
        pub idref: String,
    }
    impl WithSerializer for IdrefType {
        type Serializer<'x> = quick_xml_serialize::IdrefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::IdrefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::IdrefTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:idrefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for IdrefType {
        type Deserializer = quick_xml_deserialize::IdrefTypeDeserializer;
    }
    ///Allowed checking and scoring roles for an
    ///xccdf:Rule.
    #[derive(Debug)]
    pub enum RoleEnumType {
        ///If the xccdf:Rule is selected, then
        ///check it and let the result contribute to the score and appear in reports
        ///(default).
        Full,
        ///If the xccdf:Rule is selected, then
        ///check it and include it in the test report, but give the result a status of
        ///informational and do not use the result in score computations.
        Unscored,
        ///Do not check the xccdf:Rule; just force
        ///the result status to notchecked.
        Unchecked,
    }
    impl SerializeBytes for RoleEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Full => Ok(Some(Cow::Borrowed("full"))),
                Self::Unscored => Ok(Some(Cow::Borrowed("unscored"))),
                Self::Unchecked => Ok(Some(Cow::Borrowed("unchecked"))),
            }
        }
    }
    impl DeserializeBytes for RoleEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"full" => Ok(Self::Full),
                b"unscored" => Ok(Self::Unscored),
                b"unchecked" => Ok(Self::Unchecked),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    ///Allowed severity values for the @severity attribute of
    ///an xccdf:Rule. The value of this attribute provides an indication of the
    ///importance of the xccdf:Rule element's recommendation. This information is
    ///informative only and does not affect scoring.
    #[derive(Debug)]
    pub enum SeverityEnumType {
        ///Severity not defined (default).
        Unknown,
        ///xccdf:Rule is informational and failure
        ///does not represent a problem.
        Info,
        ///Not a serious problem.
        Low,
        ///Fairly serious problem.
        Medium,
        ///A grave or critical problem.
        High,
    }
    impl SerializeBytes for SeverityEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Unknown => Ok(Some(Cow::Borrowed("unknown"))),
                Self::Info => Ok(Some(Cow::Borrowed("info"))),
                Self::Low => Ok(Some(Cow::Borrowed("low"))),
                Self::Medium => Ok(Some(Cow::Borrowed("medium"))),
                Self::High => Ok(Some(Cow::Borrowed("high"))),
            }
        }
    }
    impl DeserializeBytes for SeverityEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"unknown" => Ok(Self::Unknown),
                b"info" => Ok(Self::Info),
                b"low" => Ok(Self::Low),
                b"medium" => Ok(Self::Medium),
                b"high" => Ok(Self::High),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Data type for the xccdf:ident element, a
    ///globally meaningful identifier for an xccdf:Rule. The body of
    ///xccdf:ident element is the name or identifier of a security configuration
    ///issue or vulnerability that the xccdf:Rule addresses. It has an associated
    ///URI that denotes the organization or naming scheme that assigned the name. By
    ///setting an xccdf:ident element on an xccdf:Rule, the
    ///xccdf:Benchmark author effectively declares that the xccdf:Rule
    ///instantiates, implements, or remediates the issue for which the name was assigned.
    #[derive(Debug)]
    pub struct IdentType {
        ///Denotes the organization or naming scheme
        ///that assigned the identifier.
        pub system: String,
        pub any_attribute: AnyAttributes,
        pub content: String,
    }
    impl WithSerializer for IdentType {
        type Serializer<'x> = quick_xml_serialize::IdentTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::IdentTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::IdentTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:identType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for IdentType {
        type Deserializer = quick_xml_deserialize::IdentTypeDeserializer;
    }
    /// Type for an xccdf:profile-note within an
    ///xccdf:Rule. This element contains text that describes special aspects of an
    ///xccdf:Rule relative to one or more xccdf:Profile elements. This
    ///allows an author to document things within xccdf:Rule elements that are
    ///specific to a given xccdf:Profile. This information might then be displayed
    ///to a reader based on the selection of a particular xccdf:Profile. The body
    ///text may include XHTML mark-up as well as xccdf:sub elements.
    #[derive(Debug)]
    pub struct ProfileNoteType {
        pub lang: Option<String>,
        ///The identifier of this note.
        pub tag: String,
        pub content: Vec<ProfileNoteTypeContent>,
    }
    /// Type for an xccdf:profile-note within an
    ///xccdf:Rule. This element contains text that describes special aspects of an
    ///xccdf:Rule relative to one or more xccdf:Profile elements. This
    ///allows an author to document things within xccdf:Rule elements that are
    ///specific to a given xccdf:Profile. This information might then be displayed
    ///to a reader based on the selection of a particular xccdf:Profile. The body
    ///text may include XHTML mark-up as well as xccdf:sub elements.
    #[derive(Debug)]
    pub enum ProfileNoteTypeContent {
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text
        ///substitution
        Sub(SubType),
        Any(AnyElement),
        Text(Text),
    }
    impl WithSerializer for ProfileNoteType {
        type Serializer<'x> = quick_xml_serialize::ProfileNoteTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ProfileNoteTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileNoteTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:profileNoteType"),
                is_root,
            })
        }
    }
    impl WithSerializer for ProfileNoteTypeContent {
        type Serializer<'x> = quick_xml_serialize::ProfileNoteTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::ProfileNoteTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ProfileNoteTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for ProfileNoteType {
        type Deserializer = quick_xml_deserialize::ProfileNoteTypeDeserializer;
    }
    impl WithDeserializer for ProfileNoteTypeContent {
        type Deserializer = quick_xml_deserialize::ProfileNoteTypeContentDeserializer;
    }
    /// Data type for the xccdf:fixtext element, which
    ///contains data that describes how to bring a target system into compliance with an
    ///xccdf:Rule. Each xccdf:fixtext element may be associated with one or
    ///more xccdf:fix elements through the @fixref attribute. The body holds
    ///explanatory text about the fix procedures.
    #[derive(Debug)]
    pub struct FixTextType {
        pub lang: Option<String>,
        ///Used to manage inheritance.
        pub override_: bool,
        ///A reference to the @id of an
        ///xccdf:fix element.
        pub fixref: Option<String>,
        ///True if a reboot is known to be required
        ///and false otherwise.
        pub reboot: bool,
        ///The method or approach for making the
        ///described fix.
        pub strategy: FixStrategyEnumType,
        ///An estimate of the potential for disruption
        ///or operational degradation that the application of this fix will impose
        ///on the target.
        pub disruption: RatingEnumType,
        ///The estimated complexity or difficulty of
        ///applying the fix to the target.
        pub complexity: RatingEnumType,
        pub content: Vec<FixTextTypeContent>,
    }
    /// Data type for the xccdf:fixtext element, which
    ///contains data that describes how to bring a target system into compliance with an
    ///xccdf:Rule. Each xccdf:fixtext element may be associated with one or
    ///more xccdf:fix elements through the @fixref attribute. The body holds
    ///explanatory text about the fix procedures.
    #[derive(Debug)]
    pub enum FixTextTypeContent {
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text
        ///substitution
        Sub(SubType),
        Any(AnyElement),
        Text(Text),
    }
    impl FixTextType {
        #[must_use]
        pub fn default_override_() -> bool {
            false
        }
        #[must_use]
        pub fn default_reboot() -> bool {
            false
        }
        #[must_use]
        pub fn default_strategy() -> FixStrategyEnumType {
            FixStrategyEnumType::Unknown
        }
        #[must_use]
        pub fn default_disruption() -> RatingEnumType {
            RatingEnumType::Unknown
        }
        #[must_use]
        pub fn default_complexity() -> RatingEnumType {
            RatingEnumType::Unknown
        }
    }
    impl WithSerializer for FixTextType {
        type Serializer<'x> = quick_xml_serialize::FixTextTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::FixTextTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::FixTextTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:fixTextType"),
                is_root,
            })
        }
    }
    impl WithSerializer for FixTextTypeContent {
        type Serializer<'x> = quick_xml_serialize::FixTextTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::FixTextTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::FixTextTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for FixTextType {
        type Deserializer = quick_xml_deserialize::FixTextTypeDeserializer;
    }
    impl WithDeserializer for FixTextTypeContent {
        type Deserializer = quick_xml_deserialize::FixTextTypeContentDeserializer;
    }
    /// Data type for the xccdf:fix element. The body
    ///of this element contains a command string, script, or other system modification
    ///statement that, if executed on the target system, can bring it into full, or at
    ///least better, compliance with this xccdf:Rule.
    #[derive(Debug)]
    pub struct FixType {
        ///A local identifier for the element. It is optional
        ///for the @id to be unique; multiple xccdf:fix elements may have the same
        ///@id but different values for their other attributes. It is used primarily to
        ///allow xccdf:fixtext elements to be associated with one or more
        ///xccdf:fix elements
        pub id: Option<String>,
        ///True if a reboot is known to be required and false
        ///otherwise.
        pub reboot: bool,
        ///The method or approach for making the described
        ///fix.
        pub strategy: FixStrategyEnumType,
        ///An estimate of the potential for disruption or
        ///operational degradation that the application of this fix will impose on the
        ///target.
        pub disruption: RatingEnumType,
        ///The estimated complexity or difficulty of applying
        ///the fix to the target.
        pub complexity: RatingEnumType,
        ///A URI that identifies the scheme, language, engine,
        ///or process for which the fix contents are written. Table 17 in the XCCDF
        ///specification defines several general-purpose URNs that may be used for this,
        ///and tool vendors and system providers may define and use target-specific
        ///URNs.
        pub system: Option<String>,
        ///In case different fix scripts or procedures are
        ///required for different target platform types (e.g., different patches for
        ///Windows Vista and Windows 7), this attribute allows a CPE name or CPE
        ///applicability language expression to be associated with an xccdf:fix
        ///element. This should appear on an xccdf:fix when the content applies to
        ///only one platform out of several to which the xccdf:Rule could apply.
        pub platform: Option<String>,
        pub content: Vec<FixTypeContent>,
    }
    /// Data type for the xccdf:fix element. The body
    ///of this element contains a command string, script, or other system modification
    ///statement that, if executed on the target system, can bring it into full, or at
    ///least better, compliance with this xccdf:Rule.
    #[derive(Debug)]
    pub enum FixTypeContent {
        ///Specifies an xccdf:Value or
        ///xccdf:plain-text element to be used for text substitution
        Sub(SubType),
        ///Designates a spot where the name of the
        ///instance should be substituted into the fix template to generate the final
        ///fix data. If the @context attribute is omitted, the value of the @context
        ///defaults to “undefined”.
        Instance(InstanceFixType),
        Text(Text),
    }
    impl FixType {
        #[must_use]
        pub fn default_reboot() -> bool {
            false
        }
        #[must_use]
        pub fn default_strategy() -> FixStrategyEnumType {
            FixStrategyEnumType::Unknown
        }
        #[must_use]
        pub fn default_disruption() -> RatingEnumType {
            RatingEnumType::Unknown
        }
        #[must_use]
        pub fn default_complexity() -> RatingEnumType {
            RatingEnumType::Unknown
        }
    }
    impl WithSerializer for FixType {
        type Serializer<'x> = quick_xml_serialize::FixTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::FixTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::FixTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:fixType"),
                is_root,
            })
        }
    }
    impl WithSerializer for FixTypeContent {
        type Serializer<'x> = quick_xml_serialize::FixTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::FixTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::FixTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for FixType {
        type Deserializer = quick_xml_deserialize::FixTypeDeserializer;
    }
    impl WithDeserializer for FixTypeContent {
        type Deserializer = quick_xml_deserialize::FixTypeContentDeserializer;
    }
    /// Data type for the xccdf:check element. The
    ///xccdf:check element identifies instructions for tests to determine
    ///compliance with the xccdf:Rule as well as parameters controlling the
    ///reporting of those test results. The xccdf:check element must have at least
    ///one child element.
    #[derive(Debug)]
    pub struct CheckType {
        ///The URI for a checking system. If the checking
        ///system uses XML namespaces, then the system attribute for the system should be
        ///its namespace.
        pub system: String,
        ///If set to true, the final result of the
        ///xccdf:check is negated according to the truth table given below.
        pub negate: bool,
        ///Unique identifier for this element. Optional, but
        ///must be globally unique if present.
        pub id: Option<String>,
        ///This may be referenced from xccdf:Profile
        ///selection elements or used during manual tailoring to refine the application of
        ///the xccdf:Rule. If no selector values are specified for a given
        ///xccdf:Rule by xccdf:Profile elements or manual tailoring, all
        ///xccdf:check elements with non-empty @selector attributes are ignored. If
        ///an xccdf:Rule has multiple xccdf:check elements with the same
        ///@selector attribute, each must employ a different checking system, as identified
        ///by the @system attribute of the xccdf:check element.
        pub selector: String,
        ///Applicable in cases where multiple checks are
        ///executed to determine compliance with a single xccdf:Rule. This
        ///situation can arise when an xccdf:check includes an
        ///xccdf:check-content-ref element that does not include a @name attribute.
        ///The default behavior of a nameless xccdf:check-content-ref is to execute
        ///all checks in the referenced check content location and AND their results
        ///together into a single xccdf:rule-result using the AND truth table
        ///below. This corresponds to a @multi-check attribute value of “false”. If,
        ///however, the @multi-check attribute is set to "true" and a nameless
        ///xccdf:check-content-ref is used, the xccdf:Rule produces a
        ///separate xccdf:rule-result for each check.
        pub multi_check: bool,
        pub base: Option<String>,
        ///Identifies a value to be retrieved from the
        ///checking system during testing of a target system. This element's body must
        ///be empty within an xccdf:check. After the associated check results
        ///have been collected, the result structure returned by the checking engine is
        ///processed to collect the named information. This information is then
        ///recorded in the check-import element in the corresponding
        ///xccdf:rule-result.
        pub check_import: Vec<CheckImportType>,
        ///A mapping from an xccdf:Value element
        ///to a checking system variable (i.e., external name or id for use by the
        ///checking system). This supports export of tailoring values from the XCCDF
        ///processing environment to the checking system.
        pub check_export: Vec<CheckExportType>,
        ///Points to code for a detached check in another
        ///location that uses the language or system specified by the
        ///xccdf:check element’s @system attribute. If multiple
        ///xccdf:check-content-ref elements appear, they represent alternative
        ///locations from which a benchmark consumer may obtain the check content.
        ///Benchmark consumers should process the alternatives in the order in which
        ///they appear in the XML. The first xccdf:check-content-ref from which
        ///content can be successfully retrieved should be used.
        pub check_content_ref: Vec<CheckContentRefType>,
        ///Holds the actual code of a check, in the
        ///language or system specified by the xccdf:check element’s @system
        ///attribute. If both xccdf:check-content-ref and
        ///xccdf:check-content elements appear in a single xccdf:check
        ///element, benchmark consumers should use the xccdf:check-content
        ///element only if none of the references can be resolved to provide
        ///content.
        pub check_content: Option<CheckContentType>,
    }
    impl CheckType {
        #[must_use]
        pub fn default_negate() -> bool {
            false
        }
        #[must_use]
        pub fn default_selector() -> String {
            String::from("")
        }
        #[must_use]
        pub fn default_multi_check() -> bool {
            false
        }
    }
    impl WithSerializer for CheckType {
        type Serializer<'x> = quick_xml_serialize::CheckTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:checkType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CheckType {
        type Deserializer = quick_xml_deserialize::CheckTypeDeserializer;
    }
    /// The type for an element that contains a boolean
    ///combination of xccdf:checks. This element can have only
    ///xccdf:complex-check and xccdf:check elements as children. Child
    ///elements may appear in any order but at least one child element must be present. It
    ///has two attributes, @operator and @negate, which dictate how xccdf:check or
    ///xccdf:complex-check child elements are to be combined. Truth tables for
    ///these operations appear below.
    #[derive(Debug)]
    pub struct ComplexCheckType {
        ///Indicates whether the child xccdf:check
        ///and/or xccdf:complex-check elements of this xccdf:complex-check
        ///should be combined using an AND or OR operation
        pub operator: CcOperatorEnumType,
        ///If true, negate the final result of this
        ///xccdf:complex-check after the child elements are combined using the
        ///identified operator.
        pub negate: bool,
        pub content: Vec<ComplexCheckTypeContent>,
    }
    /// The type for an element that contains a boolean
    ///combination of xccdf:checks. This element can have only
    ///xccdf:complex-check and xccdf:check elements as children. Child
    ///elements may appear in any order but at least one child element must be present. It
    ///has two attributes, @operator and @negate, which dictate how xccdf:check or
    ///xccdf:complex-check child elements are to be combined. Truth tables for
    ///these operations appear below.
    #[derive(Debug)]
    pub enum ComplexCheckTypeContent {
        ///Instructions for a single
        ///test.
        Check(CheckType),
        ///A child xccdf:complex-check, allowing
        ///another level of logic in combining component checks.
        ComplexCheck(ComplexCheckType),
    }
    impl ComplexCheckType {
        #[must_use]
        pub fn default_negate() -> bool {
            false
        }
    }
    impl WithSerializer for ComplexCheckType {
        type Serializer<'x> = quick_xml_serialize::ComplexCheckTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ComplexCheckTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ComplexCheckTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:complexCheckType"),
                is_root,
            })
        }
    }
    impl WithSerializer for ComplexCheckTypeContent {
        type Serializer<'x> = quick_xml_serialize::ComplexCheckTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::ComplexCheckTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ComplexCheckTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for ComplexCheckType {
        type Deserializer = quick_xml_deserialize::ComplexCheckTypeDeserializer;
    }
    impl WithDeserializer for ComplexCheckTypeContent {
        type Deserializer = quick_xml_deserialize::ComplexCheckTypeContentDeserializer;
    }
    ///Type for a reference to the xccdf:Benchmark
    ///document.
    #[derive(Debug)]
    pub struct BenchmarkReferenceType {
        ///The URI of the xccdf:Benchmark document.
        pub href: String,
        ///The value of that xccdf:Benchmark element's
        ///@id attribute.
        pub id: Option<String>,
    }
    impl WithSerializer for BenchmarkReferenceType {
        type Serializer<'x> = quick_xml_serialize::BenchmarkReferenceTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::BenchmarkReferenceTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::BenchmarkReferenceTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:benchmarkReferenceType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for BenchmarkReferenceType {
        type Deserializer = quick_xml_deserialize::BenchmarkReferenceTypeDeserializer;
    }
    ///Type for the xccdf:tailoring element within an
    ///xccdf:TestResult. This element is used to indicate the identity and location
    ///of an xccdf:Tailoring file that was used to create the assessment results.
    #[derive(Debug)]
    pub struct TailoringReferenceType {
        ///The URI of the xccdf:Tailoring file's
        ///location.
        pub href: String,
        ///The xccdf:Tailoring element's @id value.
        pub id: String,
        ///The value of the xccdf:Tailoring element's
        ///xccdf:version property.
        pub version: String,
        ///The value of the @time attribute in the
        ///xccdf:Tailoring element's xccdf:version
        ///property.
        pub time: String,
    }
    impl WithSerializer for TailoringReferenceType {
        type Serializer<'x> = quick_xml_serialize::TailoringReferenceTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TailoringReferenceTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TailoringReferenceTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:tailoringReferenceType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TailoringReferenceType {
        type Deserializer = quick_xml_deserialize::TailoringReferenceTypeDeserializer;
    }
    ///Type for an xccdf:identity element in an
    ///xccdf:TestResult. It contains information about the system identity or user
    ///employed during application of the xccdf:Benchmark. If used, shall specify
    ///the name of the authenticated identity.
    #[derive(Debug)]
    pub struct IdentityType {
        ///Whether the identity was authenticated with
        ///the target system during the application of the xccdf:Benchmark.
        pub authenticated: bool,
        ///Whether the identity was granted
        ///administrative or other special privileges beyond those of a normal
        ///user.
        pub privileged: bool,
        pub content: String,
    }
    impl WithSerializer for IdentityType {
        type Serializer<'x> = quick_xml_serialize::IdentityTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::IdentityTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::IdentityTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:identityType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for IdentityType {
        type Deserializer = quick_xml_deserialize::IdentityTypeDeserializer;
    }
    /// Data type for the xccdf:target-facts elements
    ///in xccdf:TestResult elements. A xccdf:target-facts element holds a
    ///list of named facts about the target system or platform. Each fact is an element of
    ///type factType. Each xccdf:fact must have a name, but duplicate names are
    ///allowed. (For example, if you had a fact about MAC addresses, and the target system
    ///had three NICs, then you'd need three instances of the "urn:xccdf:fact:ethernet:MAC"
    ///fact.)
    #[derive(Debug)]
    pub struct TargetFactsType {
        ///A named fact about the target system or
        ///platform.
        pub fact: Vec<FactType>,
    }
    impl WithSerializer for TargetFactsType {
        type Serializer<'x> = quick_xml_serialize::TargetFactsTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TargetFactsTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TargetFactsTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:targetFactsType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TargetFactsType {
        type Deserializer = quick_xml_deserialize::TargetFactsTypeDeserializer;
    }
    ///Type for an xccdf:target-id-ref element in an
    ///xccdf:TestResult element. This element contains references to external
    ///structures with identifying information about the target of an
    ///assessment.
    #[derive(Debug)]
    pub struct TargetIdRefType {
        ///Indicates the language in which this identifying
        ///information is expressed. If the identifying language uses XML namespaces, then
        ///the @system attribute for the language should be its
        ///namespace.
        pub system: String,
        ///Points to the external resource (e.g., a file) that
        ///contains the identifying information.
        pub href: String,
        ///Identifies a specific structure within the
        ///referenced file. If the @name attribute is absent, the reference is to the
        ///entire resource indicated in the @href attribute.
        pub name: Option<String>,
    }
    impl WithSerializer for TargetIdRefType {
        type Serializer<'x> = quick_xml_serialize::TargetIdRefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TargetIdRefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TargetIdRefTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:targetIdRefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TargetIdRefType {
        type Deserializer = quick_xml_deserialize::TargetIdRefTypeDeserializer;
    }
    ///Type for the xccdf:rule-result element within
    ///an xccdf:TestResult. An xccdf:rule-result holds the result of
    ///applying an xccdf:Rule from the xccdf:Benchmark to a target system
    ///or component of a target system.
    #[derive(Debug)]
    pub struct RuleResultType {
        ///The value of the @id property of an
        ///xccdf:Rule. This xccdf:rule-result reflects the result of
        ///applying this xccdf:Rule to a target or target component.
        pub idref: String,
        ///The value of the @role property of the referenced
        ///xccdf:Rule.
        pub role: Option<RoleEnumType>,
        ///The value of the @severity property of the
        ///referenced xccdf:Rule.
        pub severity: Option<SeverityEnumType>,
        ///Time when application of this instance of the
        ///referenced xccdf:Rule was completed.
        pub time: Option<String>,
        ///The value of the @version property of the
        ///referenced xccdf:Rule.
        pub version: Option<String>,
        ///The value of the @weight property of the referenced
        ///xccdf:Rule.
        pub weight: Option<f64>,
        pub content: Vec<RuleResultTypeContent>,
    }
    ///Type for the xccdf:rule-result element within
    ///an xccdf:TestResult. An xccdf:rule-result holds the result of
    ///applying an xccdf:Rule from the xccdf:Benchmark to a target system
    ///or component of a target system.
    #[derive(Debug)]
    pub enum RuleResultTypeContent {
        ///Result of applying the referenced
        ///xccdf:Rule to a target or target component. (E.g., Pass, Fail, etc.)
        Result(ResultEnumType),
        ///An XML block explaining how and why an auditor
        ///chose to override the result.
        Override(OverrideType),
        ///A long-term globally meaningful identifier for
        ///the issue, vulnerability, platform, etc. copied from the referenced
        ///xccdf:Rule.
        Ident(IdentType),
        ///XML metadata associated with this
        ///xccdf:rule-result.
        Metadata(MetadataType),
        ///Diagnostic messages from the checking engine.
        ///These elements do not affect scoring; they are present merely to convey
        ///diagnostic information from the checking engine.
        Message(MessageType),
        ///Name of the target subsystem or component to
        ///which this result applies, for a multiply instantiated xccdf:Rule.
        ///The element is important for an xccdf:Rule that applies to
        ///components of the target system, especially when a target might have several
        ///such components, and where the @multiple attribute of the xccdf:Rule
        ///is set to true.
        Instance(InstanceResultType),
        ///Fix script for this target platform, if
        ///available (would normally appear only for result values of “fail”). It is
        ///assumed to have been ‘instantiated’ by the testing tool and any
        ///substitutions or platform selections already made.
        Fix(FixType),
        ///Encapsulated or referenced results to
        ///detailed testing output from the checking engine (if
        ///any).
        Check(CheckType),
        ///A copy of the xccdf:Rule element’s
        ///xccdf:complex-check element where each component
        ///xccdf:check element of the xccdf:complex-check element
        ///is an encapsulated or referenced results to detailed testing output from
        ///the checking engine (if any) as described in the
        ///xccdf:rule-result xccdf:check
        ///property.
        ComplexCheck(ComplexCheckType),
    }
    impl WithSerializer for RuleResultType {
        type Serializer<'x> = quick_xml_serialize::RuleResultTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::RuleResultTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::RuleResultTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:ruleResultType"),
                is_root,
            })
        }
    }
    impl WithSerializer for RuleResultTypeContent {
        type Serializer<'x> = quick_xml_serialize::RuleResultTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::RuleResultTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::RuleResultTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for RuleResultType {
        type Deserializer = quick_xml_deserialize::RuleResultTypeDeserializer;
    }
    impl WithDeserializer for RuleResultTypeContent {
        type Deserializer = quick_xml_deserialize::RuleResultTypeContentDeserializer;
    }
    ///Type for a score value in an xccdf:TestResult.
    #[derive(Debug)]
    pub struct ScoreType {
        ///A URI indicating the scoring model used to
        ///create this score.
        pub system: Option<String>,
        ///The maximum possible score value that could
        ///have been achieved under the named scoring system.
        pub maximum: Option<f64>,
        pub content: f64,
    }
    impl WithSerializer for ScoreType {
        type Serializer<'x> = quick_xml_serialize::ScoreTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ScoreTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ScoreTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:scoreType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ScoreType {
        type Deserializer = quick_xml_deserialize::ScoreTypeDeserializer;
    }
    ///This holds the possible values of the @use attribute
    ///within an xccdf:sub element. The @use attribute is only applicable with the
    ///subType's @idref attribute holds the value of the @id of an xccdf:Value
    ///element.
    #[derive(Debug)]
    pub enum SubUseEnumType {
        ///Replace with the selected xccdf:value
        ///or xccdf:complex-value of an xccdf:Value.
        Value,
        ///Replace with the xccdf:title of the
        ///xccdf:Value.
        Title,
        ///Use the context-dependent processing of
        ///xccdf:sub elements outlined in XCCDF 1.1.4.
        Legacy,
    }
    impl SerializeBytes for SubUseEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Value => Ok(Some(Cow::Borrowed("value"))),
                Self::Title => Ok(Some(Cow::Borrowed("title"))),
                Self::Legacy => Ok(Some(Cow::Borrowed("legacy"))),
            }
        }
    }
    impl DeserializeBytes for SubUseEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"value" => Ok(Self::Value),
                b"title" => Ok(Self::Title),
                b"legacy" => Ok(Self::Legacy),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Allowed warning category keywords for the
    ///xccdf:warning element used in xccdf:Rule elements.
    #[derive(Debug)]
    pub enum WarningCategoryEnumType {
        ///Broad or general-purpose warning
        ///(default)
        General,
        ///Warning about possible impacts to functionality
        ///or operational features
        Functionality,
        ///Warning about changes to target system
        ///performance or throughput
        Performance,
        ///Warning about hardware restrictions or possible
        ///impacts to hardware
        Hardware,
        ///Warning about legal
        ///implications
        Legal,
        ///Warning about regulatory obligations or
        ///compliance implications
        Regulatory,
        ///Warning about impacts to the management or
        ///administration of the target system
        Management,
        ///Warning about impacts to audit or
        ///logging
        Audit,
        ///Warning about dependencies between this element
        ///and other parts of the target system, or version
        ///dependencies
        Dependency,
    }
    impl SerializeBytes for WarningCategoryEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::General => Ok(Some(Cow::Borrowed("general"))),
                Self::Functionality => Ok(Some(Cow::Borrowed("functionality"))),
                Self::Performance => Ok(Some(Cow::Borrowed("performance"))),
                Self::Hardware => Ok(Some(Cow::Borrowed("hardware"))),
                Self::Legal => Ok(Some(Cow::Borrowed("legal"))),
                Self::Regulatory => Ok(Some(Cow::Borrowed("regulatory"))),
                Self::Management => Ok(Some(Cow::Borrowed("management"))),
                Self::Audit => Ok(Some(Cow::Borrowed("audit"))),
                Self::Dependency => Ok(Some(Cow::Borrowed("dependency"))),
            }
        }
    }
    impl DeserializeBytes for WarningCategoryEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"general" => Ok(Self::General),
                b"functionality" => Ok(Self::Functionality),
                b"performance" => Ok(Self::Performance),
                b"hardware" => Ok(Self::Hardware),
                b"legal" => Ok(Self::Legal),
                b"regulatory" => Ok(Self::Regulatory),
                b"management" => Ok(Self::Management),
                b"audit" => Ok(Self::Audit),
                b"dependency" => Ok(Self::Dependency),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    ///Data type that supports values that are lists of simple
    ///types. Each element in the list is represented by an instance of the
    ///xccdf:item child element. If there are no xccdf:item child elements
    ///then this represents an empty list.
    #[derive(Debug)]
    pub struct ComplexValueType {
        ///A single item in the list of values.
        pub item: Vec<String>,
    }
    impl WithSerializer for ComplexValueType {
        type Serializer<'x> = quick_xml_serialize::ComplexValueTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ComplexValueTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ComplexValueTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:complexValueType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ComplexValueType {
        type Deserializer = quick_xml_deserialize::ComplexValueTypeDeserializer;
    }
    /// Allowed @strategy keyword values for an
    ///xccdf:Rule element's xccdf:fix or xccdf:fixtext elements.
    ///The values indicate the method or approach for fixing non-compliance with a
    ///particular xccdf:Rule.
    #[derive(Debug)]
    pub enum FixStrategyEnumType {
        ///Strategy not defined
        ///(default)
        Unknown,
        ///Adjust target
        ///configuration/settings
        Configure,
        ///Combination of two or more
        ///approaches
        Combination,
        ///Turn off or uninstall a target component
        Disable,
        ///Turn on or install a target
        ///component
        Enable,
        ///Apply a patch, hotfix, update,
        ///etc.
        Patch,
        ///Remediation requires out-of-band adjustments to
        ///policies or procedures
        Policy,
        ///Adjust permissions, access rights, filters, or
        ///other access restrictions
        Restrict,
        ///Install, upgrade or update the
        ///system
        Update,
    }
    impl SerializeBytes for FixStrategyEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Unknown => Ok(Some(Cow::Borrowed("unknown"))),
                Self::Configure => Ok(Some(Cow::Borrowed("configure"))),
                Self::Combination => Ok(Some(Cow::Borrowed("combination"))),
                Self::Disable => Ok(Some(Cow::Borrowed("disable"))),
                Self::Enable => Ok(Some(Cow::Borrowed("enable"))),
                Self::Patch => Ok(Some(Cow::Borrowed("patch"))),
                Self::Policy => Ok(Some(Cow::Borrowed("policy"))),
                Self::Restrict => Ok(Some(Cow::Borrowed("restrict"))),
                Self::Update => Ok(Some(Cow::Borrowed("update"))),
            }
        }
    }
    impl DeserializeBytes for FixStrategyEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"unknown" => Ok(Self::Unknown),
                b"configure" => Ok(Self::Configure),
                b"combination" => Ok(Self::Combination),
                b"disable" => Ok(Self::Disable),
                b"enable" => Ok(Self::Enable),
                b"patch" => Ok(Self::Patch),
                b"policy" => Ok(Self::Policy),
                b"restrict" => Ok(Self::Restrict),
                b"update" => Ok(Self::Update),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// This type enumerates allowed rating values the
    ///disruption and complexity properties of an xccdf:Rule element's
    ///xccdf:fix or xccdf:fixtext elements.
    #[derive(Debug)]
    pub enum RatingEnumType {
        ///Rating unknown or impossible to estimate
        ///(default)
        Unknown,
        ///Little or no potential for disruption, very
        ///modest complexity
        Low,
        ///Some chance of minor disruption, substantial
        ///complexity
        Medium,
        ///Likely to cause serious disruption, very
        ///complex
        High,
    }
    impl SerializeBytes for RatingEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Unknown => Ok(Some(Cow::Borrowed("unknown"))),
                Self::Low => Ok(Some(Cow::Borrowed("low"))),
                Self::Medium => Ok(Some(Cow::Borrowed("medium"))),
                Self::High => Ok(Some(Cow::Borrowed("high"))),
            }
        }
    }
    impl DeserializeBytes for RatingEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"unknown" => Ok(Self::Unknown),
                b"low" => Ok(Self::Low),
                b"medium" => Ok(Self::Medium),
                b"high" => Ok(Self::High),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Type for an xccdf:instance element which may
    ///appear in an xccdf:fix element. The xccdf:instance element inside an
    ///xccdf:fix element designates a spot where the name of the instance should be
    ///substituted into the fix template to generate the final fix data.
    #[derive(Debug)]
    pub struct InstanceFixType {
        ///Describes the scope or significance of the instance
        ///content. The context attribute is intended to be informative and does not affect
        ///basic processing.
        pub context: String,
    }
    impl InstanceFixType {
        #[must_use]
        pub fn default_context() -> String {
            String::from("undefined")
        }
    }
    impl WithSerializer for InstanceFixType {
        type Serializer<'x> = quick_xml_serialize::InstanceFixTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::InstanceFixTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::InstanceFixTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:instanceFixType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for InstanceFixType {
        type Deserializer = quick_xml_deserialize::InstanceFixTypeDeserializer;
    }
    /// Data type for the xccdf:check-import element,
    ///which specifies a value that the xccdf:Benchmark author wishes to retrieve
    ///from the checking system during testing of a target system. The @import-name
    ///attribute identifies some structure in the checking system that is then retrieved.
    ///The mapping from the values of this attribute to specific checking system structures
    ///is beyond the scope of the XCCDF specification. When the xccdf:check-import
    ///element appears in the context of an xccdf:Rule, then it should be empty and
    ///any content must be ignored. When the xccdf:check-import element appears in
    ///the context of an xccdf:rule-result, then its body holds the imported value.
    #[derive(Debug)]
    pub struct CheckImportType {
        ///An identifier indicating some structure in the
        ///checking system to be collected.
        pub import_name: String,
        ///An XPath that is used to select specific values or
        ///structures from the imported structure. This allows further refinement of the
        ///collected data if the imported value takes the form of XML structures.
        pub import_xpath: Option<String>,
        pub text_before: Option<Text>,
        pub any: Option<AnyElement>,
        pub text_after_any_36: Option<Text>,
    }
    impl WithSerializer for CheckImportType {
        type Serializer<'x> = quick_xml_serialize::CheckImportTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckImportTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckImportTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:checkImportType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CheckImportType {
        type Deserializer = quick_xml_deserialize::CheckImportTypeDeserializer;
    }
    /// Data type for the xccdf:check-export element,
    ///which specifies a mapping from an xccdf:Value element to a checking system
    ///variable (i.e., external name or id for use by the checking system). This supports
    ///export of tailoring xccdf:Value elements from the XCCDF processing
    ///environment to the checking system. The interface between the XCCDF benchmark
    ///consumer and the checking system should support, at a minimum, passing the
    ///xccdf:value property of the xccdf:Value element, but may also
    ///support passing the xccdf:Value element's @type and @operator
    ///properties.
    #[derive(Debug)]
    pub struct CheckExportType {
        ///The id of the xccdf:Value element to
        ///export.
        pub value_id: String,
        ///An identifier indicating some structure in the
        ///checking system into which the identified xccdf:Value element's
        ///properties will be mapped.
        pub export_name: String,
    }
    impl WithSerializer for CheckExportType {
        type Serializer<'x> = quick_xml_serialize::CheckExportTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckExportTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckExportTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:checkExportType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CheckExportType {
        type Deserializer = quick_xml_deserialize::CheckExportTypeDeserializer;
    }
    /// Data type for the xccdf:check-content-ref
    ///element, which points to the code for a detached check in another file. This element
    ///has no body, just a couple of attributes: @href and @name. The @name is optional, if
    ///it does not appear then this reference is to the entire document.
    #[derive(Debug)]
    pub struct CheckContentRefType {
        ///Identifies the referenced document containing
        ///checking instructions.
        pub href: String,
        ///Identifies a particular part or element of the
        ///referenced check document.
        pub name: Option<String>,
    }
    impl WithSerializer for CheckContentRefType {
        type Serializer<'x> = quick_xml_serialize::CheckContentRefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckContentRefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckContentRefTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:checkContentRefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CheckContentRefType {
        type Deserializer = quick_xml_deserialize::CheckContentRefTypeDeserializer;
    }
    /// Data type for the xccdf:check-content element.
    ///The body of this element holds the actual code of a check, in the language or system
    ///specified by the xccdf:check element’s @system attribute. The body of this
    ///element may be any XML, but cannot contain any XCCDF elements. XCCDF tools do not
    ///process its content directly but instead pass the content directly to checking
    ///engines.
    #[derive(Debug)]
    pub struct CheckContentType {
        pub content: Vec<CheckContentTypeContent>,
    }
    /// Data type for the xccdf:check-content element.
    ///The body of this element holds the actual code of a check, in the language or system
    ///specified by the xccdf:check element’s @system attribute. The body of this
    ///element may be any XML, but cannot contain any XCCDF elements. XCCDF tools do not
    ///process its content directly but instead pass the content directly to checking
    ///engines.
    #[derive(Debug)]
    pub enum CheckContentTypeContent {
        Any(AnyElement),
        Text(Text),
    }
    impl WithSerializer for CheckContentType {
        type Serializer<'x> = quick_xml_serialize::CheckContentTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckContentTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckContentTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:checkContentType"),
                is_root,
            })
        }
    }
    impl WithSerializer for CheckContentTypeContent {
        type Serializer<'x> = quick_xml_serialize::CheckContentTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CheckContentTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CheckContentTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for CheckContentType {
        type Deserializer = quick_xml_deserialize::CheckContentTypeDeserializer;
    }
    impl WithDeserializer for CheckContentTypeContent {
        type Deserializer = quick_xml_deserialize::CheckContentTypeContentDeserializer;
    }
    /// The type for the allowed @operator names for the
    ///xccdf:complex-check operator attribute. Only AND and OR operators are
    ///supported. (The xccdf:complex-check has a separate mechanism for negation.)
    #[derive(Debug)]
    pub enum CcOperatorEnumType {
        ///The logical OR of the component terms
        Or,
        ///The logical AND of the component
        ///terms
        And,
    }
    impl SerializeBytes for CcOperatorEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Or => Ok(Some(Cow::Borrowed("OR"))),
                Self::And => Ok(Some(Cow::Borrowed("AND"))),
            }
        }
    }
    impl DeserializeBytes for CcOperatorEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"OR" => Ok(Self::Or),
                b"AND" => Ok(Self::And),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Data type for an xccdf:fact element, which
    ///holds information about a target system: a name-value pair with a type. The content
    ///of the element is the value, and the @name attribute indicates the name. The @name
    ///is in the form of a URI that indicates the nature of the fact. A table of defined
    ///fact URIs appears in section 6.6.3 of the XCCDF specification. Additional URIs may
    ///be defined by authors to indicate additional kinds of facts.
    #[derive(Debug)]
    pub struct FactType {
        ///A URI that indicates the name of the fact.
        pub name: String,
        ///The data type of the fact value.
        pub type_: ValueTypeType,
        pub content: String,
    }
    impl FactType {
        #[must_use]
        pub fn default_type_() -> ValueTypeType {
            ValueTypeType::Boolean
        }
    }
    impl WithSerializer for FactType {
        type Serializer<'x> = quick_xml_serialize::FactTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::FactTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::FactTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:factType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for FactType {
        type Deserializer = quick_xml_deserialize::FactTypeDeserializer;
    }
    ///Allowed result indicators for a
    ///test.
    #[derive(Debug)]
    pub enum ResultEnumType {
        ///The target system or system component satisfied
        ///all the conditions of the xccdf:Rule.
        Pass,
        ///The target system or system component did not
        ///satisfy all the conditions of the xccdf:Rule.
        Fail,
        ///The checking engine could not complete the
        ///evaluation; therefore the status of the target’s compliance with the
        ///xccdf:Rule is not certain. This could happen, for example, if a
        ///testing tool was run with insufficient privileges and could not gather all
        ///of the necessary information.
        Error,
        ///The testing tool encountered some problem and
        ///the result is unknown. For example, a result of ‘unknown’ might be given if
        ///the testing tool was unable to interpret the output of the checking engine
        ///(the output has no meaning to the testing tool).
        Unknown,
        ///The xccdf:Rule was not applicable to
        ///the target of the test. For example, the xccdf:Rule might have been
        ///specific to a different version of the target OS, or it might have been a
        ///test against a platform feature that was not installed.
        Notapplicable,
        ///The xccdf:Rule was not evaluated by the
        ///checking engine. This status is designed for xccdf:Rule elements
        ///that have no check. It may also correspond to a status returned by a
        ///checking engine if the checking engine does not support the indicated check
        ///code.
        Notchecked,
        ///The xccdf:Rule was not selected in the
        ///xccdf:Benchmark.
        Notselected,
        ///The xccdf:Rule was checked, but the
        ///output from the checking engine is simply information for auditors or
        ///administrators; it is not a compliance category. This status value is
        ///designed for xccdf:Rule elements whose main purpose is to extract
        ///information from the target rather than test the target.
        Informational,
        ///The xccdf:Rule had failed, but was then
        ///fixed (possibly by a tool that can automatically apply remediation, or
        ///possibly by the human auditor).
        Fixed,
    }
    impl SerializeBytes for ResultEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Pass => Ok(Some(Cow::Borrowed("pass"))),
                Self::Fail => Ok(Some(Cow::Borrowed("fail"))),
                Self::Error => Ok(Some(Cow::Borrowed("error"))),
                Self::Unknown => Ok(Some(Cow::Borrowed("unknown"))),
                Self::Notapplicable => Ok(Some(Cow::Borrowed("notapplicable"))),
                Self::Notchecked => Ok(Some(Cow::Borrowed("notchecked"))),
                Self::Notselected => Ok(Some(Cow::Borrowed("notselected"))),
                Self::Informational => Ok(Some(Cow::Borrowed("informational"))),
                Self::Fixed => Ok(Some(Cow::Borrowed("fixed"))),
            }
        }
    }
    impl DeserializeBytes for ResultEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"pass" => Ok(Self::Pass),
                b"fail" => Ok(Self::Fail),
                b"error" => Ok(Self::Error),
                b"unknown" => Ok(Self::Unknown),
                b"notapplicable" => Ok(Self::Notapplicable),
                b"notchecked" => Ok(Self::Notchecked),
                b"notselected" => Ok(Self::Notselected),
                b"informational" => Ok(Self::Informational),
                b"fixed" => Ok(Self::Fixed),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    /// Type for an xccdf:override element in an
    ///xccdf:rule-result. This element is used to record manual modification or
    ///annotation of a particular xccdf:rule-result. All attributes and child
    ///elements are required. It will not always be the case that the
    ///xccdf:new-result value will differ from the xccdf:old-result value.
    ///They might match if an authority wished to make a remark on the result without
    ///changing it. If xccdf:new-result and xccdf:old-result differ, the
    ///xccdf:result element of the enclosing xccdf:rule-result must match
    ///the xccdf:new-result value.
    #[derive(Debug)]
    pub struct OverrideType {
        ///When the override was applied.
        pub time: String,
        ///Name or other identification for the human
        ///principal authorizing the override.
        pub authority: String,
        ///The xccdf:rule-result status before
        ///this override.
        pub old_result: ResultEnumType,
        ///The new, override xccdf:rule-result
        ///status.
        pub new_result: ResultEnumType,
        ///Rationale or explanation text for why or how
        ///the override was applied.
        pub remark: TextType,
    }
    impl WithSerializer for OverrideType {
        type Serializer<'x> = quick_xml_serialize::OverrideTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::OverrideTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::OverrideTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:overrideType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for OverrideType {
        type Deserializer = quick_xml_deserialize::OverrideTypeDeserializer;
    }
    /// Type for a message generated by the checking engine or
    ///XCCDF tool during xccdf:Benchmark testing. The message is contained in
    ///string format in the body of the element.
    #[derive(Debug)]
    pub struct MessageType {
        ///Denotes the seriousness of the
        ///message.
        pub severity: MsgSevEnumType,
        pub content: String,
    }
    impl WithSerializer for MessageType {
        type Serializer<'x> = quick_xml_serialize::MessageTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::MessageTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::MessageTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:messageType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for MessageType {
        type Deserializer = quick_xml_deserialize::MessageTypeDeserializer;
    }
    ///Type for an xccdf:instance element in an
    ///xccdf:rule-result. The content is a string, but the element may also have
    ///two attributes: @context and @parentContext. Both attributes are intended to provide
    ///hints as to the nature of the substituted content. This body of this type records
    ///the details of the target system instance for multiply instantiated
    ///xccdf:Rule elements.
    #[derive(Debug)]
    pub struct InstanceResultType {
        ///Describes the scope or significance of the
        ///instance content.
        pub context: String,
        ///Used to express nested structure in
        ///instance context structures.
        pub parent_context: Option<String>,
        pub content: String,
    }
    impl InstanceResultType {
        #[must_use]
        pub fn default_context() -> String {
            String::from("undefined")
        }
    }
    impl WithSerializer for InstanceResultType {
        type Serializer<'x> = quick_xml_serialize::InstanceResultTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::InstanceResultTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::InstanceResultTypeSerializerState::Init__),
                name: name.unwrap_or("cdf:instanceResultType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for InstanceResultType {
        type Deserializer = quick_xml_deserialize::InstanceResultTypeDeserializer;
    }
    /// Allowed values to indicate the severity of messages
    ///from the checking engine. These values don't affect scoring themselves but are
    ///present merely to convey diagnostic information from the checking engine. Benchmark
    ///consumers may choose to log these messages or display them to the user.
    #[derive(Debug)]
    pub enum MsgSevEnumType {
        ///Denotes a serious problem identified; test did
        ///not run.
        Error,
        ///Denotes a possible issue; test may not have
        ///run.
        Warning,
        ///Denotes important information about the tests.
        Info,
    }
    impl SerializeBytes for MsgSevEnumType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Error => Ok(Some(Cow::Borrowed("error"))),
                Self::Warning => Ok(Some(Cow::Borrowed("warning"))),
                Self::Info => Ok(Some(Cow::Borrowed("info"))),
            }
        }
    }
    impl DeserializeBytes for MsgSevEnumType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"error" => Ok(Self::Error),
                b"warning" => Ok(Self::Warning),
                b"info" => Ok(Self::Info),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser::{
            quick_xml::{
                filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader,
                Deserializer, DeserializerArtifact, DeserializerEvent, DeserializerOutput,
                DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr,
                WithDeserializer,
            },
            xml::{AnyAttributes, AnyElement, Mixed, Text},
        };
        #[derive(Debug)]
        pub struct BenchmarkElementTypeDeserializer {
            id: String,
            xml_id: Option<String>,
            resolved: bool,
            style: Option<String>,
            style_href: Option<String>,
            lang: Option<String>,
            content: Vec<super::BenchmarkElementTypeContent>,
            state: Box<BenchmarkElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum BenchmarkElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::BenchmarkElementTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl BenchmarkElementTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                let mut xml_id: Option<String> = None;
                let mut resolved: Option<bool> = None;
                let mut style: Option<String> = None;
                let mut style_href: Option<String> = None;
                let mut lang: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"resolved")
                    ) {
                        reader.read_attrib(&mut resolved, b"resolved", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"style")
                    ) {
                        reader.read_attrib(&mut style, b"style", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"style-href")
                    ) {
                        reader.read_attrib(&mut style_href, b"style-href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    xml_id: xml_id,
                    resolved: resolved
                        .unwrap_or_else(super::BenchmarkElementType::default_resolved),
                    style: style,
                    style_href: style_href,
                    lang: lang,
                    content: Vec::new(),
                    state: Box::new(BenchmarkElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: BenchmarkElementTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let BenchmarkElementTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::BenchmarkElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::BenchmarkElementTypeContent>,
                fallback: &mut Option<BenchmarkElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(BenchmarkElementTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = BenchmarkElementTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    BenchmarkElementTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    BenchmarkElementTypeDeserializerState::Content__(deserializer),
                                );
                                *self.state = BenchmarkElementTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::BenchmarkElementType> for BenchmarkElementTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkElementType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkElementType>
            where
                R: DeserializeReader,
            {
                use BenchmarkElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: BenchmarkElementTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::BenchmarkElementType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    BenchmarkElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::BenchmarkElementType {
                    id: self.id,
                    xml_id: self.xml_id,
                    resolved: self.resolved,
                    style: self.style,
                    style_href: self.style_href,
                    lang: self.lang,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct BenchmarkElementTypeContentDeserializer {
            state: Box<BenchmarkElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum BenchmarkElementTypeContentDeserializerState {
            Init__ , Status (Option < super :: StatusElementType > , Option << super :: StatusElementType as WithDeserializer > :: Deserializer >) , DcStatus (Option < super :: DcStatusType > , Option << super :: DcStatusType as WithDeserializer > :: Deserializer >) , Title (Option < super :: TextType > , Option << super :: TextType as WithDeserializer > :: Deserializer >) , Description (Option < super :: HtmlTextWithSubType > , Option << super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer >) , Notice (Option < super :: NoticeType > , Option << super :: NoticeType as WithDeserializer > :: Deserializer >) , FrontMatter (Option < super :: HtmlTextWithSubType > , Option << super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer >) , RearMatter (Option < super :: HtmlTextWithSubType > , Option << super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer >) , Reference (Option < super :: ReferenceType > , Option << super :: ReferenceType as WithDeserializer > :: Deserializer >) , PlainText (Option < super :: PlainTextType > , Option << super :: PlainTextType as WithDeserializer > :: Deserializer >) , PlatformSpecification (Option < super :: super :: cpe :: PlatformSpecificationType > , Option << super :: super :: cpe :: PlatformSpecificationType as WithDeserializer > :: Deserializer >) , Platform (Option < super :: Cpe2IdrefType > , Option << super :: Cpe2IdrefType as WithDeserializer > :: Deserializer >) , Version (Option < super :: VersionType > , Option << super :: VersionType as WithDeserializer > :: Deserializer >) , Metadata (Option < super :: MetadataType > , Option << super :: MetadataType as WithDeserializer > :: Deserializer >) , Model (Option < super :: ModelElementType > , Option << super :: ModelElementType as WithDeserializer > :: Deserializer >) , Profile (Option < super :: ProfileType > , Option << super :: ProfileType as WithDeserializer > :: Deserializer >) , Value (Option < super :: ValueType > , Option << super :: ValueType as WithDeserializer > :: Deserializer >) , Group (Option < super :: GroupType > , Option << super :: GroupType as WithDeserializer > :: Deserializer >) , Rule (Option < super :: RuleType > , Option << super :: RuleType as WithDeserializer > :: Deserializer >) , TestResult (Option < super :: TestResultType > , Option << super :: TestResultType as WithDeserializer > :: Deserializer >) , Signature (Option < super :: SignatureType > , Option << super :: SignatureType as WithDeserializer > :: Deserializer >) , Done__ (super :: BenchmarkElementTypeContent) , Unknown__ , }
        impl BenchmarkElementTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"status")
                    ) {
                        let output =
                            <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"dc-status")
                    ) {
                        let output = <super::DcStatusType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_dc_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"description")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_description(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"notice")
                    ) {
                        let output = <super::NoticeType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_notice(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"front-matter")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_front_matter(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"rear-matter")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_rear_matter(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"reference")
                    ) {
                        let output =
                            <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_reference(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"plain-text")
                    ) {
                        let output =
                            <super::PlainTextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_plain_text(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CPE),
                        Some(b"platform-specification")
                    ) {
                        let output = < super :: super :: cpe :: PlatformSpecificationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_platform_specification(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        let output =
                            <super::Cpe2IdrefType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_platform(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        let output = <super::VersionType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_version(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"model")
                    ) {
                        let output =
                            <super::ModelElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_model(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Profile")
                    ) {
                        let output = <super::ProfileType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_profile(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Value")
                    ) {
                        let output = <super::ValueType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Group")
                    ) {
                        let output = <super::GroupType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_group(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Rule")
                    ) {
                        let output = <super::RuleType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_rule(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"TestResult")
                    ) {
                        let output =
                            <super::TestResultType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_test_result(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(BenchmarkElementTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: BenchmarkElementTypeContentDeserializerState,
            ) -> Result<super::BenchmarkElementTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use BenchmarkElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Status(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_status(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Status(
                            values.ok_or_else(|| ErrorKind::MissingElement("status".into()))?,
                        ))
                    }
                    S::DcStatus(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_dc_status(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::DcStatus(
                            values.ok_or_else(|| ErrorKind::MissingElement("dc-status".into()))?,
                        ))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Title(
                            values.ok_or_else(|| ErrorKind::MissingElement("title".into()))?,
                        ))
                    }
                    S::Description(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_description(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Description(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("description".into()))?,
                        ))
                    }
                    S::Notice(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_notice(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Notice(
                            values.ok_or_else(|| ErrorKind::MissingElement("notice".into()))?,
                        ))
                    }
                    S::FrontMatter(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_front_matter(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::FrontMatter(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("front-matter".into()))?,
                        ))
                    }
                    S::RearMatter(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rear_matter(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::RearMatter(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("rear-matter".into()))?,
                        ))
                    }
                    S::Reference(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_reference(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Reference(
                            values.ok_or_else(|| ErrorKind::MissingElement("reference".into()))?,
                        ))
                    }
                    S::PlainText(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_plain_text(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::PlainText(
                            values.ok_or_else(|| ErrorKind::MissingElement("plain-text".into()))?,
                        ))
                    }
                    S::PlatformSpecification(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform_specification(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::PlatformSpecification(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("platform-specification".into())
                            })?,
                        ))
                    }
                    S::Platform(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Platform(
                            values.ok_or_else(|| ErrorKind::MissingElement("platform".into()))?,
                        ))
                    }
                    S::Version(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_version(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Version(
                            values.ok_or_else(|| ErrorKind::MissingElement("version".into()))?,
                        ))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Metadata(
                            values.ok_or_else(|| ErrorKind::MissingElement("metadata".into()))?,
                        ))
                    }
                    S::Model(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_model(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Model(
                            values.ok_or_else(|| ErrorKind::MissingElement("model".into()))?,
                        ))
                    }
                    S::Profile(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_profile(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Profile(
                            values.ok_or_else(|| ErrorKind::MissingElement("Profile".into()))?,
                        ))
                    }
                    S::Value(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_value(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Value(
                            values.ok_or_else(|| ErrorKind::MissingElement("Value".into()))?,
                        ))
                    }
                    S::Group(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_group(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Group(
                            values.ok_or_else(|| ErrorKind::MissingElement("Group".into()))?,
                        ))
                    }
                    S::Rule(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rule(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Rule(
                            values.ok_or_else(|| ErrorKind::MissingElement("Rule".into()))?,
                        ))
                    }
                    S::TestResult(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_test_result(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::TestResult(
                            values.ok_or_else(|| ErrorKind::MissingElement("TestResult".into()))?,
                        ))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::BenchmarkElementTypeContent::Signature(
                            values.ok_or_else(|| ErrorKind::MissingElement("signature".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_status(
                values: &mut Option<super::StatusElementType>,
                value: super::StatusElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_dc_status(
                values: &mut Option<super::DcStatusType>,
                value: super::DcStatusType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"dc-status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_description(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"description",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_notice(
                values: &mut Option<super::NoticeType>,
                value: super::NoticeType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"notice",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_front_matter(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"front-matter",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rear_matter(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"rear-matter",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_reference(
                values: &mut Option<super::ReferenceType>,
                value: super::ReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"reference",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_plain_text(
                values: &mut Option<super::PlainTextType>,
                value: super::PlainTextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"plain-text",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform_specification(
                values: &mut Option<super::super::cpe::PlatformSpecificationType>,
                value: super::super::cpe::PlatformSpecificationType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform-specification",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform(
                values: &mut Option<super::Cpe2IdrefType>,
                value: super::Cpe2IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_version(
                values: &mut Option<super::VersionType>,
                value: super::VersionType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"version",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_model(
                values: &mut Option<super::ModelElementType>,
                value: super::ModelElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"model",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_profile(
                values: &mut Option<super::ProfileType>,
                value: super::ProfileType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Profile",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_value(
                values: &mut Option<super::ValueType>,
                value: super::ValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_group(
                values: &mut Option<super::GroupType>,
                value: super::GroupType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Group",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rule(
                values: &mut Option<super::RuleType>,
                value: super::RuleType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Rule")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_test_result(
                values: &mut Option<super::TestResultType>,
                value: super::TestResultType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TestResult",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::StatusElementType>,
                output: DeserializerOutput<'de, super::StatusElementType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Status(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Status(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Status(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Status(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Status(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Status(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_dc_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::DcStatusType>,
                output: DeserializerOutput<'de, super::DcStatusType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::DcStatus(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::DcStatus(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::DcStatus(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::DcStatus(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_dc_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dc_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::DcStatus(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::DcStatus(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Title(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Title(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Title(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Title(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Title(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_description<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::Description(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::Description(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Description(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_description(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_description(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Description(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_notice<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::NoticeType>,
                output: DeserializerOutput<'de, super::NoticeType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Notice(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Notice(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Notice(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Notice(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_notice(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_notice(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Notice(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Notice(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_front_matter<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::FrontMatter(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::FrontMatter(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::FrontMatter(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::FrontMatter(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_front_matter(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_front_matter(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::FrontMatter(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::FrontMatter(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rear_matter<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::RearMatter(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::RearMatter(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::RearMatter(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::RearMatter(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rear_matter(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rear_matter(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::RearMatter(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::RearMatter(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_reference<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ReferenceType>,
                output: DeserializerOutput<'de, super::ReferenceType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::Reference(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::Reference(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Reference(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_reference(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_reference(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Reference(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_plain_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::PlainTextType>,
                output: DeserializerOutput<'de, super::PlainTextType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::PlainText(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::PlainText(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::PlainText(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::PlainText(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_plain_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_plain_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::PlainText(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::PlainText(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform_specification<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::super::cpe::PlatformSpecificationType>,
                output: DeserializerOutput<'de, super::super::cpe::PlatformSpecificationType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                                values, None,
                            )
                        }
                        Some(
                            BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                                _,
                                Some(deserializer),
                            ),
                        ) => BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform_specification(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform_specification(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                                values, None,
                            ),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            BenchmarkElementTypeContentDeserializerState::PlatformSpecification(
                                values,
                                Some(deserializer),
                            );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::Cpe2IdrefType>,
                output: DeserializerOutput<'de, super::Cpe2IdrefType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::Platform(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::Platform(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Platform(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Platform(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_version<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::VersionType>,
                output: DeserializerOutput<'de, super::VersionType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Version(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Version(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Version(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Version(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_version(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_version(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Version(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Version(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::Metadata(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Metadata(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_model<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ModelElementType>,
                output: DeserializerOutput<'de, super::ModelElementType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Model(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Model(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Model(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Model(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_model(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_model(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Model(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Model(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_profile<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileType>,
                output: DeserializerOutput<'de, super::ProfileType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Profile(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Profile(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Profile(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Profile(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_profile(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_profile(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Profile(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Profile(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ValueType>,
                output: DeserializerOutput<'de, super::ValueType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Value(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Value(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Value(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Value(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Value(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Value(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_group<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::GroupType>,
                output: DeserializerOutput<'de, super::GroupType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Group(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Group(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Group(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Group(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_group(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_group(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Group(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Group(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rule<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::RuleType>,
                output: DeserializerOutput<'de, super::RuleType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => BenchmarkElementTypeContentDeserializerState::Rule(values, None),
                        Some(BenchmarkElementTypeContentDeserializerState::Rule(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Rule(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Rule(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rule(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rule(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Rule(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Rule(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_test_result<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TestResultType>,
                output: DeserializerOutput<'de, super::TestResultType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::TestResult(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::TestResult(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::TestResult(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::TestResult(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_test_result(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_test_result(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::TestResult(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::TestResult(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<BenchmarkElementTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = BenchmarkElementTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            BenchmarkElementTypeContentDeserializerState::Signature(values, None)
                        }
                        Some(BenchmarkElementTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => BenchmarkElementTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(BenchmarkElementTypeContentDeserializerState::Signature(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            BenchmarkElementTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = BenchmarkElementTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = BenchmarkElementTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::BenchmarkElementTypeContent>
            for BenchmarkElementTypeContentDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkElementTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(BenchmarkElementTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state,
                            BenchmarkElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkElementTypeContent>
            where
                R: DeserializeReader,
            {
                use BenchmarkElementTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Status(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Notice(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_notice(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::FrontMatter(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_front_matter(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RearMatter(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rear_matter(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PlainText(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_plain_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PlatformSpecification(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform_specification(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Model(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_model(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Profile(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_profile(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Group(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_group(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rule(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TestResult(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_test_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Status(values, None), event) => {
                            let output =
                                <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, None), event) => {
                            let output =
                                <super::DcStatusType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Notice(values, None), event) => {
                            let output =
                                <super::NoticeType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_notice(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::FrontMatter(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_front_matter(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RearMatter(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_rear_matter(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, None), event) => {
                            let output =
                                <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PlainText(values, None), event) => {
                            let output =
                                <super::PlainTextType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_plain_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PlatformSpecification(values, None), event) => {
                            let output = < super :: super :: cpe :: PlatformSpecificationType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_platform_specification(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, None), event) => {
                            let output =
                                <super::Cpe2IdrefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, None), event) => {
                            let output =
                                <super::VersionType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Model(values, None), event) => {
                            let output =
                                <super::ModelElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_model(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Profile(values, None), event) => {
                            let output =
                                <super::ProfileType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_profile(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, None), event) => {
                            let output =
                                <super::ValueType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Group(values, None), event) => {
                            let output =
                                <super::GroupType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_group(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rule(values, None), event) => {
                            let output = <super::RuleType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TestResult(values, None), event) => {
                            let output =
                                <super::TestResultType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_test_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::BenchmarkElementTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct StatusElementTypeDeserializer {
            date: Option<String>,
            content: Option<super::StatusType>,
            state: Box<StatusElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum StatusElementTypeDeserializerState {
            Init__,
            Content__(<super::StatusType as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl StatusElementTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut date: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"date")
                    ) {
                        reader.read_attrib(&mut date, b"date", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    date: date,
                    content: None,
                    state: Box::new(StatusElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: StatusElementTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let StatusElementTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::StatusType) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::StatusType>,
            ) -> DeserializerResult<'de, super::StatusElementType>
            where
                R: DeserializeReader,
            {
                use StatusElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::StatusElementType> for StatusElementTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::StatusElementType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::StatusElementType>
            where
                R: DeserializeReader,
            {
                use StatusElementTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::StatusElementType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    StatusElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::StatusElementType {
                    date: self.date,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DcStatusTypeDeserializer {
            any: Vec<AnyElement>,
            state: Box<DcStatusTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DcStatusTypeDeserializerState {
            Init__,
            Any(Option<<AnyElement as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl DcStatusTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    any: Vec::new(),
                    state: Box::new(DcStatusTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: DcStatusTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use DcStatusTypeDeserializerState as S;
                match state {
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_any(&mut self, value: AnyElement) -> Result<(), Error> {
                self.any.push(value);
                Ok(())
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<DcStatusTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.any.len() < 1usize {
                        *self.state = DcStatusTypeDeserializerState::Any(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        fallback.get_or_insert(DcStatusTypeDeserializerState::Any(None));
                        *self.state = DcStatusTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = DcStatusTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(DcStatusTypeDeserializerState::Any(Some(
                                    deserializer,
                                )));
                                if self.any.len().saturating_add(1) < 1usize {
                                    *self.state = DcStatusTypeDeserializerState::Any(None);
                                } else {
                                    *self.state = DcStatusTypeDeserializerState::Done__;
                                }
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    DcStatusTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::DcStatusType> for DcStatusTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DcStatusType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DcStatusType>
            where
                R: DeserializeReader,
            {
                use DcStatusTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = DcStatusTypeDeserializerState::Any(None);
                            event
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::Done__;
                                event
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::DcStatusType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, DcStatusTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::DcStatusType { any: self.any })
            }
        }
        #[derive(Debug)]
        pub struct TextTypeDeserializer {
            lang: Option<String>,
            override_: bool,
            content: Option<String>,
            state: Box<TextTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TextTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl TextTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut override_: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    override_: override_.unwrap_or_else(super::TextType::default_override_),
                    content: None,
                    state: Box::new(TextTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TextTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let TextTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                use TextTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::TextType> for TextTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                use TextTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TextType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, TextTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::TextType {
                    lang: self.lang,
                    override_: self.override_,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct HtmlTextWithSubTypeDeserializer {
            lang: Option<String>,
            override_: bool,
            content: Vec<super::HtmlTextWithSubTypeContent>,
            state: Box<HtmlTextWithSubTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum HtmlTextWithSubTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::HtmlTextWithSubTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl HtmlTextWithSubTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut override_: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    override_: override_
                        .unwrap_or_else(super::HtmlTextWithSubType::default_override_),
                    content: Vec::new(),
                    state: Box::new(HtmlTextWithSubTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: HtmlTextWithSubTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let HtmlTextWithSubTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::HtmlTextWithSubTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::HtmlTextWithSubTypeContent>,
                fallback: &mut Option<HtmlTextWithSubTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(HtmlTextWithSubTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = HtmlTextWithSubTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    HtmlTextWithSubTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    HtmlTextWithSubTypeDeserializerState::Content__(deserializer),
                                );
                                *self.state = HtmlTextWithSubTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::HtmlTextWithSubType> for HtmlTextWithSubTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::HtmlTextWithSubType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::HtmlTextWithSubType>
            where
                R: DeserializeReader,
            {
                use HtmlTextWithSubTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: HtmlTextWithSubTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::HtmlTextWithSubType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    HtmlTextWithSubTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::HtmlTextWithSubType {
                    lang: self.lang,
                    override_: self.override_,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct HtmlTextWithSubTypeContentDeserializer {
            state: Box<HtmlTextWithSubTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum HtmlTextWithSubTypeContentDeserializerState {
            Init__,
            Sub(
                Option<super::SubType>,
                Option<<super::SubType as WithDeserializer>::Deserializer>,
            ),
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::HtmlTextWithSubTypeContent),
            Unknown__,
        }
        impl HtmlTextWithSubTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<HtmlTextWithSubTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"sub")
                    ) {
                        let output = <super::SubType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_sub(reader, Default::default(), output, &mut *fallback);
                    }
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: HtmlTextWithSubTypeContentDeserializerState,
            ) -> Result<super::HtmlTextWithSubTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use HtmlTextWithSubTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Sub(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_sub(&mut values, value)?;
                        }
                        Ok(super::HtmlTextWithSubTypeContent::Sub(
                            values.ok_or_else(|| ErrorKind::MissingElement("sub".into()))?,
                        ))
                    }
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::HtmlTextWithSubTypeContent::Any(values.ok_or_else(
                            || ErrorKind::MissingElement("any17".into()),
                        )?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::HtmlTextWithSubTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_sub(
                values: &mut Option<super::SubType>,
                value: super::SubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"sub")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any17",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SubType>,
                output: DeserializerOutput<'de, super::SubType>,
                fallback: &mut Option<HtmlTextWithSubTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = HtmlTextWithSubTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => HtmlTextWithSubTypeContentDeserializerState::Sub(values, None),
                        Some(HtmlTextWithSubTypeContentDeserializerState::Sub(
                            _,
                            Some(deserializer),
                        )) => HtmlTextWithSubTypeContentDeserializerState::Sub(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(HtmlTextWithSubTypeContentDeserializerState::Sub(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_sub(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sub(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            HtmlTextWithSubTypeContentDeserializerState::Sub(values, None),
                        )?;
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Sub(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<HtmlTextWithSubTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = HtmlTextWithSubTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => HtmlTextWithSubTypeContentDeserializerState::Any(values, None),
                        Some(HtmlTextWithSubTypeContentDeserializerState::Any(
                            _,
                            Some(deserializer),
                        )) => HtmlTextWithSubTypeContentDeserializerState::Any(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(HtmlTextWithSubTypeContentDeserializerState::Any(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            HtmlTextWithSubTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Any(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<HtmlTextWithSubTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = HtmlTextWithSubTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => HtmlTextWithSubTypeContentDeserializerState::Text(values, None),
                        Some(HtmlTextWithSubTypeContentDeserializerState::Text(
                            _,
                            Some(deserializer),
                        )) => HtmlTextWithSubTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(HtmlTextWithSubTypeContentDeserializerState::Text(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            HtmlTextWithSubTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = HtmlTextWithSubTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::HtmlTextWithSubTypeContent>
            for HtmlTextWithSubTypeContentDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::HtmlTextWithSubTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(HtmlTextWithSubTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state,
                            HtmlTextWithSubTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::HtmlTextWithSubTypeContent>
            where
                R: DeserializeReader,
            {
                use HtmlTextWithSubTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Sub(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sub(values, None), event) => {
                            let output = <super::SubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::HtmlTextWithSubTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct NoticeTypeDeserializer {
            id: Option<String>,
            base: Option<String>,
            lang: Option<String>,
            text_before: Option<Text>,
            any: Vec<Mixed<AnyElement>>,
            state: Box<NoticeTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum NoticeTypeDeserializerState {
            Init__,
            TextBefore(Option<<Text as WithDeserializer>::Deserializer>),
            Any(Option<<Mixed<AnyElement> as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl NoticeTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                let mut base: Option<String> = None;
                let mut lang: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id,
                    base: base,
                    lang: lang,
                    text_before: None,
                    any: Vec::new(),
                    state: Box::new(NoticeTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: NoticeTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use NoticeTypeDeserializerState as S;
                match state {
                    S::TextBefore(Some(deserializer)) => {
                        self.store_text_before(deserializer.finish(reader)?)?
                    }
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_text_before(&mut self, value: Text) -> Result<(), Error> {
                if self.text_before.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"text_before",
                    )))?;
                }
                self.text_before = Some(value);
                Ok(())
            }
            fn store_any(&mut self, value: Mixed<AnyElement>) -> Result<(), Error> {
                self.any.push(value);
                Ok(())
            }
            fn handle_text_before<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<NoticeTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(NoticeTypeDeserializerState::TextBefore(None));
                    *self.state = NoticeTypeDeserializerState::Any(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_text_before(data)?;
                        *self.state = NoticeTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(NoticeTypeDeserializerState::TextBefore(
                                    Some(deserializer),
                                ));
                                *self.state = NoticeTypeDeserializerState::Any(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    NoticeTypeDeserializerState::TextBefore(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Mixed<AnyElement>>,
                fallback: &mut Option<NoticeTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(NoticeTypeDeserializerState::Any(None));
                    *self.state = NoticeTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = NoticeTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(NoticeTypeDeserializerState::Any(Some(
                                    deserializer,
                                )));
                                *self.state = NoticeTypeDeserializerState::Any(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = NoticeTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::NoticeType> for NoticeTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::NoticeType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::NoticeType>
            where
                R: DeserializeReader,
            {
                use NoticeTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::TextBefore(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = NoticeTypeDeserializerState::TextBefore(None);
                            event
                        }
                        (S::TextBefore(None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output =
                                    <Mixed<AnyElement> as WithDeserializer>::Deserializer::init(
                                        reader, event,
                                    )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::Done__;
                                event
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::NoticeType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, NoticeTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::NoticeType {
                    id: self.id,
                    base: self.base,
                    lang: self.lang,
                    text_before: self.text_before,
                    any: self.any,
                })
            }
        }
        #[derive(Debug)]
        pub struct ReferenceTypeDeserializer {
            href: Option<String>,
            override_: Option<bool>,
            text_before: Option<Text>,
            any: Vec<Mixed<AnyElement>>,
            state: Box<ReferenceTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ReferenceTypeDeserializerState {
            Init__,
            TextBefore(Option<<Text as WithDeserializer>::Deserializer>),
            Any(Option<<Mixed<AnyElement> as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ReferenceTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut href: Option<String> = None;
                let mut override_: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    href: href,
                    override_: override_,
                    text_before: None,
                    any: Vec::new(),
                    state: Box::new(ReferenceTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ReferenceTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ReferenceTypeDeserializerState as S;
                match state {
                    S::TextBefore(Some(deserializer)) => {
                        self.store_text_before(deserializer.finish(reader)?)?
                    }
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_text_before(&mut self, value: Text) -> Result<(), Error> {
                if self.text_before.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"text_before",
                    )))?;
                }
                self.text_before = Some(value);
                Ok(())
            }
            fn store_any(&mut self, value: Mixed<AnyElement>) -> Result<(), Error> {
                self.any.push(value);
                Ok(())
            }
            fn handle_text_before<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<ReferenceTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ReferenceTypeDeserializerState::TextBefore(None));
                    *self.state = ReferenceTypeDeserializerState::Any(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_text_before(data)?;
                        *self.state = ReferenceTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ReferenceTypeDeserializerState::TextBefore(
                                    Some(deserializer),
                                ));
                                *self.state = ReferenceTypeDeserializerState::Any(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ReferenceTypeDeserializerState::TextBefore(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Mixed<AnyElement>>,
                fallback: &mut Option<ReferenceTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ReferenceTypeDeserializerState::Any(None));
                    *self.state = ReferenceTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = ReferenceTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ReferenceTypeDeserializerState::Any(Some(
                                    deserializer,
                                )));
                                *self.state = ReferenceTypeDeserializerState::Any(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ReferenceTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ReferenceType> for ReferenceTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ReferenceType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ReferenceType>
            where
                R: DeserializeReader,
            {
                use ReferenceTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::TextBefore(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ReferenceTypeDeserializerState::TextBefore(None);
                            event
                        }
                        (S::TextBefore(None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output =
                                    <Mixed<AnyElement> as WithDeserializer>::Deserializer::init(
                                        reader, event,
                                    )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::Done__;
                                event
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ReferenceType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, ReferenceTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::ReferenceType {
                    href: self.href,
                    override_: self.override_,
                    text_before: self.text_before,
                    any: self.any,
                })
            }
        }
        #[derive(Debug)]
        pub struct PlainTextTypeDeserializer {
            id: String,
            content: Option<String>,
            state: Box<PlainTextTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PlainTextTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl PlainTextTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    content: None,
                    state: Box::new(PlainTextTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: PlainTextTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let PlainTextTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::PlainTextType>
            where
                R: DeserializeReader,
            {
                use PlainTextTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PlainTextType> for PlainTextTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlainTextType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlainTextType>
            where
                R: DeserializeReader,
            {
                use PlainTextTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::PlainTextType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, PlainTextTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::PlainTextType {
                    id: self.id,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct Cpe2IdrefTypeDeserializer {
            idref: String,
            state: Box<Cpe2IdrefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum Cpe2IdrefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl Cpe2IdrefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    state: Box::new(Cpe2IdrefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: Cpe2IdrefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::Cpe2IdrefType> for Cpe2IdrefTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::Cpe2IdrefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::Cpe2IdrefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::Cpe2IdrefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, Cpe2IdrefTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::Cpe2IdrefType { idref: self.idref })
            }
        }
        #[derive(Debug)]
        pub struct VersionTypeDeserializer {
            time: Option<String>,
            update: Option<String>,
            content: Option<String>,
            state: Box<VersionTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum VersionTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl VersionTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut time: Option<String> = None;
                let mut update: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"time")
                    ) {
                        reader.read_attrib(&mut time, b"time", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"update")
                    ) {
                        reader.read_attrib(&mut update, b"update", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    time: time,
                    update: update,
                    content: None,
                    state: Box::new(VersionTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: VersionTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let VersionTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::VersionType>
            where
                R: DeserializeReader,
            {
                use VersionTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::VersionType> for VersionTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::VersionType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::VersionType>
            where
                R: DeserializeReader,
            {
                use VersionTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::VersionType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, VersionTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::VersionType {
                    time: self.time,
                    update: self.update,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct MetadataTypeDeserializer {
            any: Vec<AnyElement>,
            state: Box<MetadataTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum MetadataTypeDeserializerState {
            Init__,
            Any(Option<<AnyElement as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl MetadataTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    any: Vec::new(),
                    state: Box::new(MetadataTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: MetadataTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use MetadataTypeDeserializerState as S;
                match state {
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_any(&mut self, value: AnyElement) -> Result<(), Error> {
                self.any.push(value);
                Ok(())
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<MetadataTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.any.len() < 1usize {
                        *self.state = MetadataTypeDeserializerState::Any(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        fallback.get_or_insert(MetadataTypeDeserializerState::Any(None));
                        *self.state = MetadataTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = MetadataTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(MetadataTypeDeserializerState::Any(Some(
                                    deserializer,
                                )));
                                if self.any.len().saturating_add(1) < 1usize {
                                    *self.state = MetadataTypeDeserializerState::Any(None);
                                } else {
                                    *self.state = MetadataTypeDeserializerState::Done__;
                                }
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    MetadataTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::MetadataType> for MetadataTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::MetadataType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::MetadataType>
            where
                R: DeserializeReader,
            {
                use MetadataTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = MetadataTypeDeserializerState::Any(None);
                            event
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::Done__;
                                event
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::MetadataType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, MetadataTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::MetadataType { any: self.any })
            }
        }
        #[derive(Debug)]
        pub struct ModelElementTypeDeserializer {
            system: String,
            param: Vec<super::ParamType>,
            state: Box<ModelElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ModelElementTypeDeserializerState {
            Init__,
            Param(Option<<super::ParamType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ModelElementTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut system: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    system: system.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("system".into()))
                    })?,
                    param: Vec::new(),
                    state: Box::new(ModelElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ModelElementTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ModelElementTypeDeserializerState as S;
                match state {
                    S::Param(Some(deserializer)) => {
                        self.store_param(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_param(&mut self, value: super::ParamType) -> Result<(), Error> {
                self.param.push(value);
                Ok(())
            }
            fn handle_param<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ParamType>,
                fallback: &mut Option<ModelElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ModelElementTypeDeserializerState::Param(None));
                    *self.state = ModelElementTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_param(data)?;
                        *self.state = ModelElementTypeDeserializerState::Param(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ModelElementTypeDeserializerState::Param(
                                    Some(deserializer),
                                ));
                                *self.state = ModelElementTypeDeserializerState::Param(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ModelElementTypeDeserializerState::Param(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ModelElementType> for ModelElementTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ModelElementType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ModelElementType>
            where
                R: DeserializeReader,
            {
                use ModelElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Param(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_param(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ModelElementTypeDeserializerState::Param(None);
                            event
                        }
                        (S::Param(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"param",
                                false,
                            )?;
                            match self.handle_param(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ModelElementType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ModelElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ModelElementType {
                    system: self.system,
                    param: self.param,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileTypeDeserializer {
            id: String,
            prohibit_changes: bool,
            abstract_: bool,
            note_tag: Option<String>,
            extends: Option<String>,
            base: Option<String>,
            xml_id: Option<String>,
            content: Vec<super::ProfileTypeContent>,
            state: Box<ProfileTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::ProfileTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ProfileTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                let mut prohibit_changes: Option<bool> = None;
                let mut abstract_: Option<bool> = None;
                let mut note_tag: Option<String> = None;
                let mut extends: Option<String> = None;
                let mut base: Option<String> = None;
                let mut xml_id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"prohibitChanges")
                    ) {
                        reader.read_attrib(
                            &mut prohibit_changes,
                            b"prohibitChanges",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"abstract")
                    ) {
                        reader.read_attrib(&mut abstract_, b"abstract", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"note-tag")
                    ) {
                        reader.read_attrib(&mut note_tag, b"note-tag", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"extends")
                    ) {
                        reader.read_attrib(&mut extends, b"extends", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    prohibit_changes: prohibit_changes
                        .unwrap_or_else(super::ProfileType::default_prohibit_changes),
                    abstract_: abstract_.unwrap_or_else(super::ProfileType::default_abstract_),
                    note_tag: note_tag,
                    extends: extends,
                    base: base,
                    xml_id: xml_id,
                    content: Vec::new(),
                    state: Box::new(ProfileTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ProfileTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::ProfileTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ProfileTypeContent>,
                fallback: &mut Option<ProfileTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(ProfileTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = ProfileTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = ProfileTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ProfileTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = ProfileTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileType> for ProfileTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::ProfileType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileType>
            where
                R: DeserializeReader,
            {
                use ProfileTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: ProfileTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, ProfileTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::ProfileType {
                    id: self.id,
                    prohibit_changes: self.prohibit_changes,
                    abstract_: self.abstract_,
                    note_tag: self.note_tag,
                    extends: self.extends,
                    base: self.base,
                    xml_id: self.xml_id,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileTypeContentDeserializer {
            state: Box<ProfileTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum ProfileTypeContentDeserializerState {
            Init__,
            Status(
                Option<super::StatusElementType>,
                Option<<super::StatusElementType as WithDeserializer>::Deserializer>,
            ),
            DcStatus(
                Option<super::DcStatusType>,
                Option<<super::DcStatusType as WithDeserializer>::Deserializer>,
            ),
            Version(
                Option<super::VersionType>,
                Option<<super::VersionType as WithDeserializer>::Deserializer>,
            ),
            Title(
                Option<super::TextWithSubType>,
                Option<<super::TextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Description(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Reference(
                Option<super::ReferenceType>,
                Option<<super::ReferenceType as WithDeserializer>::Deserializer>,
            ),
            Platform(
                Option<super::OverrideableCpe2IdrefType>,
                Option<<super::OverrideableCpe2IdrefType as WithDeserializer>::Deserializer>,
            ),
            Select(
                Option<super::ProfileSelectType>,
                Option<<super::ProfileSelectType as WithDeserializer>::Deserializer>,
            ),
            SetComplexValue(
                Option<super::ProfileSetComplexValueType>,
                Option<<super::ProfileSetComplexValueType as WithDeserializer>::Deserializer>,
            ),
            SetValue(
                Option<super::ProfileSetValueType>,
                Option<<super::ProfileSetValueType as WithDeserializer>::Deserializer>,
            ),
            RefineValue(
                Option<super::ProfileRefineValueType>,
                Option<<super::ProfileRefineValueType as WithDeserializer>::Deserializer>,
            ),
            RefineRule(
                Option<super::ProfileRefineRuleType>,
                Option<<super::ProfileRefineRuleType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Signature(
                Option<super::SignatureType>,
                Option<<super::SignatureType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::ProfileTypeContent),
            Unknown__,
        }
        impl ProfileTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"status")
                    ) {
                        let output =
                            <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"dc-status")
                    ) {
                        let output = <super::DcStatusType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_dc_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        let output = <super::VersionType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_version(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output =
                            <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"description")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_description(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"reference")
                    ) {
                        let output =
                            <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_reference(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_platform(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"select")
                    ) {
                        let output =
                            <super::ProfileSelectType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_select(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"set-complex-value")
                    ) {
                        let output = < super :: ProfileSetComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_set_complex_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"set-value")
                    ) {
                        let output =
                            <super::ProfileSetValueType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_set_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"refine-value")
                    ) {
                        let output = < super :: ProfileRefineValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_refine_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"refine-rule")
                    ) {
                        let output =
                            <super::ProfileRefineRuleType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_refine_rule(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(ProfileTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: ProfileTypeContentDeserializerState,
            ) -> Result<super::ProfileTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use ProfileTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Status(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_status(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Status(values.ok_or_else(
                            || ErrorKind::MissingElement("status".into()),
                        )?))
                    }
                    S::DcStatus(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_dc_status(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::DcStatus(values.ok_or_else(
                            || ErrorKind::MissingElement("dc-status".into()),
                        )?))
                    }
                    S::Version(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_version(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Version(values.ok_or_else(
                            || ErrorKind::MissingElement("version".into()),
                        )?))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Title(values.ok_or_else(
                            || ErrorKind::MissingElement("title".into()),
                        )?))
                    }
                    S::Description(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_description(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Description(values.ok_or_else(
                            || ErrorKind::MissingElement("description".into()),
                        )?))
                    }
                    S::Reference(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_reference(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Reference(values.ok_or_else(
                            || ErrorKind::MissingElement("reference".into()),
                        )?))
                    }
                    S::Platform(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Platform(values.ok_or_else(
                            || ErrorKind::MissingElement("platform".into()),
                        )?))
                    }
                    S::Select(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_select(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Select(values.ok_or_else(
                            || ErrorKind::MissingElement("select".into()),
                        )?))
                    }
                    S::SetComplexValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_set_complex_value(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::SetComplexValue(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("set-complex-value".into())
                            })?,
                        ))
                    }
                    S::SetValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_set_value(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::SetValue(values.ok_or_else(
                            || ErrorKind::MissingElement("set-value".into()),
                        )?))
                    }
                    S::RefineValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_refine_value(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::RefineValue(values.ok_or_else(
                            || ErrorKind::MissingElement("refine-value".into()),
                        )?))
                    }
                    S::RefineRule(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_refine_rule(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::RefineRule(values.ok_or_else(
                            || ErrorKind::MissingElement("refine-rule".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::ProfileTypeContent::Signature(values.ok_or_else(
                            || ErrorKind::MissingElement("signature".into()),
                        )?))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_status(
                values: &mut Option<super::StatusElementType>,
                value: super::StatusElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_dc_status(
                values: &mut Option<super::DcStatusType>,
                value: super::DcStatusType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"dc-status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_version(
                values: &mut Option<super::VersionType>,
                value: super::VersionType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"version",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextWithSubType>,
                value: super::TextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_description(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"description",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_reference(
                values: &mut Option<super::ReferenceType>,
                value: super::ReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"reference",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform(
                values: &mut Option<super::OverrideableCpe2IdrefType>,
                value: super::OverrideableCpe2IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_select(
                values: &mut Option<super::ProfileSelectType>,
                value: super::ProfileSelectType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"select",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_set_complex_value(
                values: &mut Option<super::ProfileSetComplexValueType>,
                value: super::ProfileSetComplexValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"set-complex-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_set_value(
                values: &mut Option<super::ProfileSetValueType>,
                value: super::ProfileSetValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"set-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_refine_value(
                values: &mut Option<super::ProfileRefineValueType>,
                value: super::ProfileRefineValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"refine-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_refine_rule(
                values: &mut Option<super::ProfileRefineRuleType>,
                value: super::ProfileRefineRuleType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"refine-rule",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::StatusElementType>,
                output: DeserializerOutput<'de, super::StatusElementType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Status(values, None),
                        Some(ProfileTypeContentDeserializerState::Status(
                            _,
                            Some(deserializer),
                        )) => {
                            ProfileTypeContentDeserializerState::Status(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Status(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ProfileTypeContentDeserializerState::Status(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_dc_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::DcStatusType>,
                output: DeserializerOutput<'de, super::DcStatusType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::DcStatus(values, None),
                        Some(ProfileTypeContentDeserializerState::DcStatus(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::DcStatus(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::DcStatus(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_dc_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dc_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::DcStatus(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::DcStatus(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_version<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::VersionType>,
                output: DeserializerOutput<'de, super::VersionType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Version(values, None),
                        Some(ProfileTypeContentDeserializerState::Version(
                            _,
                            Some(deserializer),
                        )) => {
                            ProfileTypeContentDeserializerState::Version(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_version(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_version(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Version(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Version(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextWithSubType>,
                output: DeserializerOutput<'de, super::TextWithSubType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Title(values, None),
                        Some(ProfileTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                            ProfileTypeContentDeserializerState::Title(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ProfileTypeContentDeserializerState::Title(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_description<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Description(values, None),
                        Some(ProfileTypeContentDeserializerState::Description(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Description(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_description(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_description(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Description(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_reference<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ReferenceType>,
                output: DeserializerOutput<'de, super::ReferenceType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Reference(values, None),
                        Some(ProfileTypeContentDeserializerState::Reference(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Reference(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_reference(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_reference(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Reference(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::OverrideableCpe2IdrefType>,
                output: DeserializerOutput<'de, super::OverrideableCpe2IdrefType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Platform(values, None),
                        Some(ProfileTypeContentDeserializerState::Platform(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Platform(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Platform(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_select<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileSelectType>,
                output: DeserializerOutput<'de, super::ProfileSelectType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Select(values, None),
                        Some(ProfileTypeContentDeserializerState::Select(
                            _,
                            Some(deserializer),
                        )) => {
                            ProfileTypeContentDeserializerState::Select(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Select(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_select(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_select(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Select(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ProfileTypeContentDeserializerState::Select(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_set_complex_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileSetComplexValueType>,
                output: DeserializerOutput<'de, super::ProfileSetComplexValueType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::SetComplexValue(values, None),
                        Some(ProfileTypeContentDeserializerState::SetComplexValue(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::SetComplexValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::SetComplexValue(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_set_complex_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_set_complex_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::SetComplexValue(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::SetComplexValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_set_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileSetValueType>,
                output: DeserializerOutput<'de, super::ProfileSetValueType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::SetValue(values, None),
                        Some(ProfileTypeContentDeserializerState::SetValue(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::SetValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::SetValue(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_set_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_set_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::SetValue(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::SetValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_refine_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileRefineValueType>,
                output: DeserializerOutput<'de, super::ProfileRefineValueType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::RefineValue(values, None),
                        Some(ProfileTypeContentDeserializerState::RefineValue(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::RefineValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::RefineValue(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_refine_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_refine_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::RefineValue(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::RefineValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_refine_rule<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileRefineRuleType>,
                output: DeserializerOutput<'de, super::ProfileRefineRuleType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::RefineRule(values, None),
                        Some(ProfileTypeContentDeserializerState::RefineRule(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::RefineRule(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::RefineRule(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_refine_rule(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_refine_rule(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::RefineRule(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::RefineRule(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Metadata(values, None),
                        Some(ProfileTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Metadata(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<ProfileTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileTypeContentDeserializerState::Signature(values, None),
                        Some(ProfileTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => ProfileTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileTypeContentDeserializerState::Signature(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = ProfileTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileTypeContent> for ProfileTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(ProfileTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, ProfileTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileTypeContent>
            where
                R: DeserializeReader,
            {
                use ProfileTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Status(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Select(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_select(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetComplexValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_set_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_set_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RefineValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_refine_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RefineRule(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_refine_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Status(values, None), event) => {
                            let output =
                                <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, None), event) => {
                            let output =
                                <super::DcStatusType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, None), event) => {
                            let output =
                                <super::VersionType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output =
                                <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, None), event) => {
                            let output =
                                <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, None), event) => {
                            let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Select(values, None), event) => {
                            let output =
                                <super::ProfileSelectType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_select(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetComplexValue(values, None), event) => {
                            let output = < super :: ProfileSetComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_set_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetValue(values, None), event) => {
                            let output = < super :: ProfileSetValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_set_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RefineValue(values, None), event) => {
                            let output = < super :: ProfileRefineValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_refine_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RefineRule(values, None), event) => {
                            let output = < super :: ProfileRefineRuleType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_refine_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::ProfileTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct ValueTypeDeserializer {
            abstract_: bool,
            cluster_id: Option<String>,
            extends: Option<String>,
            hidden: bool,
            prohibit_changes: bool,
            lang: Option<String>,
            base: Option<String>,
            xml_id: Option<String>,
            id: String,
            type_: super::ValueTypeType,
            operator: super::ValueOperatorType,
            interactive: bool,
            interface_hint: Option<super::InterfaceHintType>,
            content: Vec<super::ValueTypeContent>,
            state: Box<ValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ValueTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::ValueTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut abstract_: Option<bool> = None;
                let mut cluster_id: Option<String> = None;
                let mut extends: Option<String> = None;
                let mut hidden: Option<bool> = None;
                let mut prohibit_changes: Option<bool> = None;
                let mut lang: Option<String> = None;
                let mut base: Option<String> = None;
                let mut xml_id: Option<String> = None;
                let mut id: Option<String> = None;
                let mut type_: Option<super::ValueTypeType> = None;
                let mut operator: Option<super::ValueOperatorType> = None;
                let mut interactive: Option<bool> = None;
                let mut interface_hint: Option<super::InterfaceHintType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"abstract")
                    ) {
                        reader.read_attrib(&mut abstract_, b"abstract", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"cluster-id")
                    ) {
                        reader.read_attrib(&mut cluster_id, b"cluster-id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"extends")
                    ) {
                        reader.read_attrib(&mut extends, b"extends", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"hidden")
                    ) {
                        reader.read_attrib(&mut hidden, b"hidden", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"prohibitChanges")
                    ) {
                        reader.read_attrib(
                            &mut prohibit_changes,
                            b"prohibitChanges",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"type")
                    ) {
                        reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"operator")
                    ) {
                        reader.read_attrib(&mut operator, b"operator", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"interactive")
                    ) {
                        reader.read_attrib(&mut interactive, b"interactive", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"interfaceHint")
                    ) {
                        reader.read_attrib(&mut interface_hint, b"interfaceHint", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    abstract_: abstract_.unwrap_or_else(super::ValueType::default_abstract_),
                    cluster_id: cluster_id,
                    extends: extends,
                    hidden: hidden.unwrap_or_else(super::ValueType::default_hidden),
                    prohibit_changes: prohibit_changes
                        .unwrap_or_else(super::ValueType::default_prohibit_changes),
                    lang: lang,
                    base: base,
                    xml_id: xml_id,
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    type_: type_.unwrap_or_else(super::ValueType::default_type_),
                    operator: operator.unwrap_or_else(super::ValueType::default_operator),
                    interactive: interactive.unwrap_or_else(super::ValueType::default_interactive),
                    interface_hint: interface_hint,
                    content: Vec::new(),
                    state: Box::new(ValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ValueTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::ValueTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ValueTypeContent>,
                fallback: &mut Option<ValueTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(ValueTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = ValueTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = ValueTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ValueTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = ValueTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ValueType> for ValueTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::ValueType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ValueType>
            where
                R: DeserializeReader,
            {
                use ValueTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::ValueTypeContent as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, ValueTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::ValueType {
                    abstract_: self.abstract_,
                    cluster_id: self.cluster_id,
                    extends: self.extends,
                    hidden: self.hidden,
                    prohibit_changes: self.prohibit_changes,
                    lang: self.lang,
                    base: self.base,
                    xml_id: self.xml_id,
                    id: self.id,
                    type_: self.type_,
                    operator: self.operator,
                    interactive: self.interactive,
                    interface_hint: self.interface_hint,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct ValueTypeContentDeserializer {
            state: Box<ValueTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum ValueTypeContentDeserializerState {
            Init__,
            Status(
                Option<super::StatusElementType>,
                Option<<super::StatusElementType as WithDeserializer>::Deserializer>,
            ),
            DcStatus(
                Option<super::DcStatusType>,
                Option<<super::DcStatusType as WithDeserializer>::Deserializer>,
            ),
            Version(
                Option<super::VersionType>,
                Option<<super::VersionType as WithDeserializer>::Deserializer>,
            ),
            Title(
                Option<super::TextWithSubType>,
                Option<<super::TextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Description(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Warning(
                Option<super::WarningType>,
                Option<<super::WarningType as WithDeserializer>::Deserializer>,
            ),
            Question(
                Option<super::TextType>,
                Option<<super::TextType as WithDeserializer>::Deserializer>,
            ),
            Reference(
                Option<super::ReferenceType>,
                Option<<super::ReferenceType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Value(
                Option<super::SelStringType>,
                Option<<super::SelStringType as WithDeserializer>::Deserializer>,
            ),
            ComplexValue(
                Option<super::SelComplexValueType>,
                Option<<super::SelComplexValueType as WithDeserializer>::Deserializer>,
            ),
            Default(
                Option<super::SelStringType>,
                Option<<super::SelStringType as WithDeserializer>::Deserializer>,
            ),
            ComplexDefault(
                Option<super::SelComplexValueType>,
                Option<<super::SelComplexValueType as WithDeserializer>::Deserializer>,
            ),
            Match(
                Option<super::SelStringType>,
                Option<<super::SelStringType as WithDeserializer>::Deserializer>,
            ),
            LowerBound(
                Option<super::SelNumType>,
                Option<<super::SelNumType as WithDeserializer>::Deserializer>,
            ),
            UpperBound(
                Option<super::SelNumType>,
                Option<<super::SelNumType as WithDeserializer>::Deserializer>,
            ),
            Choices(
                Option<super::SelChoicesType>,
                Option<<super::SelChoicesType as WithDeserializer>::Deserializer>,
            ),
            Source(
                Option<super::UriRefType>,
                Option<<super::UriRefType as WithDeserializer>::Deserializer>,
            ),
            Signature(
                Option<super::SignatureType>,
                Option<<super::SignatureType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::ValueTypeContent),
            Unknown__,
        }
        impl ValueTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"status")
                    ) {
                        let output =
                            <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"dc-status")
                    ) {
                        let output = <super::DcStatusType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_dc_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        let output = <super::VersionType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_version(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output =
                            <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"description")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_description(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"warning")
                    ) {
                        let output = <super::WarningType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_warning(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"question")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_question(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"reference")
                    ) {
                        let output =
                            <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_reference(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"value")
                    ) {
                        let output =
                            <super::SelStringType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-value")
                    ) {
                        let output =
                            <super::SelComplexValueType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"default")
                    ) {
                        let output =
                            <super::SelStringType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_default(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-default")
                    ) {
                        let output =
                            <super::SelComplexValueType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_default(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"match")
                    ) {
                        let output =
                            <super::SelStringType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_match_(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"lower-bound")
                    ) {
                        let output = <super::SelNumType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_lower_bound(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"upper-bound")
                    ) {
                        let output = <super::SelNumType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_upper_bound(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"choices")
                    ) {
                        let output =
                            <super::SelChoicesType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_choices(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"source")
                    ) {
                        let output = <super::UriRefType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_source(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(ValueTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: ValueTypeContentDeserializerState,
            ) -> Result<super::ValueTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use ValueTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Status(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_status(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Status(values.ok_or_else(
                            || ErrorKind::MissingElement("status".into()),
                        )?))
                    }
                    S::DcStatus(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_dc_status(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::DcStatus(values.ok_or_else(
                            || ErrorKind::MissingElement("dc-status".into()),
                        )?))
                    }
                    S::Version(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_version(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Version(values.ok_or_else(
                            || ErrorKind::MissingElement("version".into()),
                        )?))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Title(values.ok_or_else(|| {
                            ErrorKind::MissingElement("title".into())
                        })?))
                    }
                    S::Description(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_description(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Description(values.ok_or_else(
                            || ErrorKind::MissingElement("description".into()),
                        )?))
                    }
                    S::Warning(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_warning(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Warning(values.ok_or_else(
                            || ErrorKind::MissingElement("warning".into()),
                        )?))
                    }
                    S::Question(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_question(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Question(values.ok_or_else(
                            || ErrorKind::MissingElement("question".into()),
                        )?))
                    }
                    S::Reference(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_reference(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Reference(values.ok_or_else(
                            || ErrorKind::MissingElement("reference".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Value(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_value(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Value(values.ok_or_else(|| {
                            ErrorKind::MissingElement("value".into())
                        })?))
                    }
                    S::ComplexValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_value(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::ComplexValue(values.ok_or_else(
                            || ErrorKind::MissingElement("complex-value".into()),
                        )?))
                    }
                    S::Default(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_default(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Default(values.ok_or_else(
                            || ErrorKind::MissingElement("default".into()),
                        )?))
                    }
                    S::ComplexDefault(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_default(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::ComplexDefault(values.ok_or_else(
                            || ErrorKind::MissingElement("complex-default".into()),
                        )?))
                    }
                    S::Match(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_match_(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Match(values.ok_or_else(|| {
                            ErrorKind::MissingElement("match".into())
                        })?))
                    }
                    S::LowerBound(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_lower_bound(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::LowerBound(values.ok_or_else(
                            || ErrorKind::MissingElement("lower-bound".into()),
                        )?))
                    }
                    S::UpperBound(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_upper_bound(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::UpperBound(values.ok_or_else(
                            || ErrorKind::MissingElement("upper-bound".into()),
                        )?))
                    }
                    S::Choices(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_choices(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Choices(values.ok_or_else(
                            || ErrorKind::MissingElement("choices".into()),
                        )?))
                    }
                    S::Source(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_source(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Source(values.ok_or_else(
                            || ErrorKind::MissingElement("source".into()),
                        )?))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::ValueTypeContent::Signature(values.ok_or_else(
                            || ErrorKind::MissingElement("signature".into()),
                        )?))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_status(
                values: &mut Option<super::StatusElementType>,
                value: super::StatusElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_dc_status(
                values: &mut Option<super::DcStatusType>,
                value: super::DcStatusType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"dc-status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_version(
                values: &mut Option<super::VersionType>,
                value: super::VersionType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"version",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextWithSubType>,
                value: super::TextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_description(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"description",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_warning(
                values: &mut Option<super::WarningType>,
                value: super::WarningType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"warning",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_question(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"question",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_reference(
                values: &mut Option<super::ReferenceType>,
                value: super::ReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"reference",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_value(
                values: &mut Option<super::SelStringType>,
                value: super::SelStringType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_value(
                values: &mut Option<super::SelComplexValueType>,
                value: super::SelComplexValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_default(
                values: &mut Option<super::SelStringType>,
                value: super::SelStringType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"default",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_default(
                values: &mut Option<super::SelComplexValueType>,
                value: super::SelComplexValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-default",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_match_(
                values: &mut Option<super::SelStringType>,
                value: super::SelStringType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"match",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_lower_bound(
                values: &mut Option<super::SelNumType>,
                value: super::SelNumType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"lower-bound",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_upper_bound(
                values: &mut Option<super::SelNumType>,
                value: super::SelNumType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"upper-bound",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_choices(
                values: &mut Option<super::SelChoicesType>,
                value: super::SelChoicesType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"choices",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_source(
                values: &mut Option<super::UriRefType>,
                value: super::UriRefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"source",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::StatusElementType>,
                output: DeserializerOutput<'de, super::StatusElementType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Status(values, None),
                        Some(ValueTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Status(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Status(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Status(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_dc_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::DcStatusType>,
                output: DeserializerOutput<'de, super::DcStatusType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::DcStatus(values, None),
                        Some(ValueTypeContentDeserializerState::DcStatus(
                            _,
                            Some(deserializer),
                        )) => {
                            ValueTypeContentDeserializerState::DcStatus(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::DcStatus(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_dc_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dc_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::DcStatus(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::DcStatus(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_version<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::VersionType>,
                output: DeserializerOutput<'de, super::VersionType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Version(values, None),
                        Some(ValueTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Version(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_version(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_version(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Version(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Version(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextWithSubType>,
                output: DeserializerOutput<'de, super::TextWithSubType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Title(values, None),
                        Some(ValueTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Title(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Title(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_description<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Description(values, None),
                        Some(ValueTypeContentDeserializerState::Description(
                            _,
                            Some(deserializer),
                        )) => ValueTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Description(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_description(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_description(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Description(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_warning<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::WarningType>,
                output: DeserializerOutput<'de, super::WarningType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Warning(values, None),
                        Some(ValueTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Warning(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_warning(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_warning(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Warning(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Warning(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_question<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Question(values, None),
                        Some(ValueTypeContentDeserializerState::Question(
                            _,
                            Some(deserializer),
                        )) => {
                            ValueTypeContentDeserializerState::Question(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Question(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_question(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_question(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Question(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Question(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_reference<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ReferenceType>,
                output: DeserializerOutput<'de, super::ReferenceType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Reference(values, None),
                        Some(ValueTypeContentDeserializerState::Reference(
                            _,
                            Some(deserializer),
                        )) => {
                            ValueTypeContentDeserializerState::Reference(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Reference(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_reference(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_reference(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Reference(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Metadata(values, None),
                        Some(ValueTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => {
                            ValueTypeContentDeserializerState::Metadata(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Metadata(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Metadata(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelStringType>,
                output: DeserializerOutput<'de, super::SelStringType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Value(values, None),
                        Some(ValueTypeContentDeserializerState::Value(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Value(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Value(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Value(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Value(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelComplexValueType>,
                output: DeserializerOutput<'de, super::SelComplexValueType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::ComplexValue(values, None),
                        Some(ValueTypeContentDeserializerState::ComplexValue(
                            _,
                            Some(deserializer),
                        )) => ValueTypeContentDeserializerState::ComplexValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::ComplexValue(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::ComplexValue(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::ComplexValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_default<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelStringType>,
                output: DeserializerOutput<'de, super::SelStringType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Default(values, None),
                        Some(ValueTypeContentDeserializerState::Default(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Default(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Default(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_default(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_default(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Default(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Default(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_default<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelComplexValueType>,
                output: DeserializerOutput<'de, super::SelComplexValueType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::ComplexDefault(values, None),
                        Some(ValueTypeContentDeserializerState::ComplexDefault(
                            _,
                            Some(deserializer),
                        )) => ValueTypeContentDeserializerState::ComplexDefault(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::ComplexDefault(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_default(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_default(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::ComplexDefault(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::ComplexDefault(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_match_<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelStringType>,
                output: DeserializerOutput<'de, super::SelStringType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Match(values, None),
                        Some(ValueTypeContentDeserializerState::Match(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Match(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Match(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_match_(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_match_(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Match(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Match(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_lower_bound<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelNumType>,
                output: DeserializerOutput<'de, super::SelNumType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::LowerBound(values, None),
                        Some(ValueTypeContentDeserializerState::LowerBound(
                            _,
                            Some(deserializer),
                        )) => ValueTypeContentDeserializerState::LowerBound(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::LowerBound(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_lower_bound(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_lower_bound(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::LowerBound(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::LowerBound(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_upper_bound<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelNumType>,
                output: DeserializerOutput<'de, super::SelNumType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::UpperBound(values, None),
                        Some(ValueTypeContentDeserializerState::UpperBound(
                            _,
                            Some(deserializer),
                        )) => ValueTypeContentDeserializerState::UpperBound(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::UpperBound(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_upper_bound(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_upper_bound(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::UpperBound(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::UpperBound(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_choices<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SelChoicesType>,
                output: DeserializerOutput<'de, super::SelChoicesType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Choices(values, None),
                        Some(ValueTypeContentDeserializerState::Choices(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Choices(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Choices(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_choices(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_choices(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Choices(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Choices(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_source<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::UriRefType>,
                output: DeserializerOutput<'de, super::UriRefType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Source(values, None),
                        Some(ValueTypeContentDeserializerState::Source(_, Some(deserializer))) => {
                            ValueTypeContentDeserializerState::Source(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Source(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_source(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_source(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Source(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            ValueTypeContentDeserializerState::Source(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<ValueTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ValueTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ValueTypeContentDeserializerState::Signature(values, None),
                        Some(ValueTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => {
                            ValueTypeContentDeserializerState::Signature(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ValueTypeContentDeserializerState::Signature(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ValueTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = ValueTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ValueTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ValueTypeContent> for ValueTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ValueTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(ValueTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, ValueTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ValueTypeContent>
            where
                R: DeserializeReader,
            {
                use ValueTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Status(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Default(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_default(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexDefault(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_default(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Match(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_match_(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::LowerBound(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_lower_bound(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::UpperBound(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_upper_bound(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Choices(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_choices(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Source(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_source(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Status(values, None), event) => {
                            let output =
                                <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, None), event) => {
                            let output =
                                <super::DcStatusType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, None), event) => {
                            let output =
                                <super::VersionType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output =
                                <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, None), event) => {
                            let output =
                                <super::WarningType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, None), event) => {
                            let output =
                                <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, None), event) => {
                            let output =
                                <super::SelStringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexValue(values, None), event) => {
                            let output = < super :: SelComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Default(values, None), event) => {
                            let output =
                                <super::SelStringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_default(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexDefault(values, None), event) => {
                            let output = < super :: SelComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_complex_default(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Match(values, None), event) => {
                            let output =
                                <super::SelStringType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_match_(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::LowerBound(values, None), event) => {
                            let output =
                                <super::SelNumType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_lower_bound(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::UpperBound(values, None), event) => {
                            let output =
                                <super::SelNumType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_upper_bound(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Choices(values, None), event) => {
                            let output =
                                <super::SelChoicesType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_choices(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Source(values, None), event) => {
                            let output =
                                <super::UriRefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_source(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::ValueTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct GroupTypeDeserializer {
            abstract_: bool,
            cluster_id: Option<String>,
            extends: Option<String>,
            hidden: bool,
            prohibit_changes: bool,
            lang: Option<String>,
            base: Option<String>,
            xml_id: Option<String>,
            selected: bool,
            weight: f64,
            id: String,
            content: Vec<super::GroupTypeContent>,
            state: Box<GroupTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum GroupTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::GroupTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl GroupTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut abstract_: Option<bool> = None;
                let mut cluster_id: Option<String> = None;
                let mut extends: Option<String> = None;
                let mut hidden: Option<bool> = None;
                let mut prohibit_changes: Option<bool> = None;
                let mut lang: Option<String> = None;
                let mut base: Option<String> = None;
                let mut xml_id: Option<String> = None;
                let mut selected: Option<bool> = None;
                let mut weight: Option<f64> = None;
                let mut id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"abstract")
                    ) {
                        reader.read_attrib(&mut abstract_, b"abstract", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"cluster-id")
                    ) {
                        reader.read_attrib(&mut cluster_id, b"cluster-id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"extends")
                    ) {
                        reader.read_attrib(&mut extends, b"extends", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"hidden")
                    ) {
                        reader.read_attrib(&mut hidden, b"hidden", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"prohibitChanges")
                    ) {
                        reader.read_attrib(
                            &mut prohibit_changes,
                            b"prohibitChanges",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selected")
                    ) {
                        reader.read_attrib(&mut selected, b"selected", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"weight")
                    ) {
                        reader.read_attrib(&mut weight, b"weight", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    abstract_: abstract_.unwrap_or_else(super::GroupType::default_abstract_),
                    cluster_id: cluster_id,
                    extends: extends,
                    hidden: hidden.unwrap_or_else(super::GroupType::default_hidden),
                    prohibit_changes: prohibit_changes
                        .unwrap_or_else(super::GroupType::default_prohibit_changes),
                    lang: lang,
                    base: base,
                    xml_id: xml_id,
                    selected: selected.unwrap_or_else(super::GroupType::default_selected),
                    weight: weight.unwrap_or_else(super::GroupType::default_weight),
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    content: Vec::new(),
                    state: Box::new(GroupTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: GroupTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let GroupTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::GroupTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::GroupTypeContent>,
                fallback: &mut Option<GroupTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(GroupTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = GroupTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = GroupTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(GroupTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = GroupTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::GroupType> for GroupTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::GroupType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::GroupType>
            where
                R: DeserializeReader,
            {
                use GroupTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::GroupTypeContent as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::GroupType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, GroupTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::GroupType {
                    abstract_: self.abstract_,
                    cluster_id: self.cluster_id,
                    extends: self.extends,
                    hidden: self.hidden,
                    prohibit_changes: self.prohibit_changes,
                    lang: self.lang,
                    base: self.base,
                    xml_id: self.xml_id,
                    selected: self.selected,
                    weight: self.weight,
                    id: self.id,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct GroupTypeContentDeserializer {
            state: Box<GroupTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum GroupTypeContentDeserializerState {
            Init__,
            Status(
                Option<super::StatusElementType>,
                Option<<super::StatusElementType as WithDeserializer>::Deserializer>,
            ),
            DcStatus(
                Option<super::DcStatusType>,
                Option<<super::DcStatusType as WithDeserializer>::Deserializer>,
            ),
            Version(
                Option<super::VersionType>,
                Option<<super::VersionType as WithDeserializer>::Deserializer>,
            ),
            Title(
                Option<super::TextWithSubType>,
                Option<<super::TextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Description(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Warning(
                Option<super::WarningType>,
                Option<<super::WarningType as WithDeserializer>::Deserializer>,
            ),
            Question(
                Option<super::TextType>,
                Option<<super::TextType as WithDeserializer>::Deserializer>,
            ),
            Reference(
                Option<super::ReferenceType>,
                Option<<super::ReferenceType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Rationale(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Platform(
                Option<super::OverrideableCpe2IdrefType>,
                Option<<super::OverrideableCpe2IdrefType as WithDeserializer>::Deserializer>,
            ),
            Requires(
                Option<super::IdrefListType>,
                Option<<super::IdrefListType as WithDeserializer>::Deserializer>,
            ),
            Conflicts(
                Option<super::IdrefType>,
                Option<<super::IdrefType as WithDeserializer>::Deserializer>,
            ),
            Value(
                Option<super::ValueType>,
                Option<<super::ValueType as WithDeserializer>::Deserializer>,
            ),
            Group(
                Option<super::GroupType>,
                Option<<super::GroupType as WithDeserializer>::Deserializer>,
            ),
            Rule(
                Option<super::RuleType>,
                Option<<super::RuleType as WithDeserializer>::Deserializer>,
            ),
            Signature(
                Option<super::SignatureType>,
                Option<<super::SignatureType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::GroupTypeContent),
            Unknown__,
        }
        impl GroupTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"status")
                    ) {
                        let output =
                            <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"dc-status")
                    ) {
                        let output = <super::DcStatusType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_dc_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        let output = <super::VersionType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_version(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output =
                            <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"description")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_description(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"warning")
                    ) {
                        let output = <super::WarningType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_warning(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"question")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_question(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"reference")
                    ) {
                        let output =
                            <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_reference(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"rationale")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_rationale(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_platform(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"requires")
                    ) {
                        let output =
                            <super::IdrefListType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_requires(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"conflicts")
                    ) {
                        let output = <super::IdrefType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_conflicts(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Value")
                    ) {
                        let output = <super::ValueType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Group")
                    ) {
                        let output = <super::GroupType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_group(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"Rule")
                    ) {
                        let output = <super::RuleType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_rule(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(GroupTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: GroupTypeContentDeserializerState,
            ) -> Result<super::GroupTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use GroupTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Status(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_status(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Status(values.ok_or_else(
                            || ErrorKind::MissingElement("status".into()),
                        )?))
                    }
                    S::DcStatus(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_dc_status(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::DcStatus(values.ok_or_else(
                            || ErrorKind::MissingElement("dc-status".into()),
                        )?))
                    }
                    S::Version(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_version(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Version(values.ok_or_else(
                            || ErrorKind::MissingElement("version".into()),
                        )?))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Title(values.ok_or_else(|| {
                            ErrorKind::MissingElement("title".into())
                        })?))
                    }
                    S::Description(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_description(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Description(values.ok_or_else(
                            || ErrorKind::MissingElement("description".into()),
                        )?))
                    }
                    S::Warning(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_warning(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Warning(values.ok_or_else(
                            || ErrorKind::MissingElement("warning".into()),
                        )?))
                    }
                    S::Question(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_question(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Question(values.ok_or_else(
                            || ErrorKind::MissingElement("question".into()),
                        )?))
                    }
                    S::Reference(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_reference(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Reference(values.ok_or_else(
                            || ErrorKind::MissingElement("reference".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Rationale(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rationale(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Rationale(values.ok_or_else(
                            || ErrorKind::MissingElement("rationale".into()),
                        )?))
                    }
                    S::Platform(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Platform(values.ok_or_else(
                            || ErrorKind::MissingElement("platform".into()),
                        )?))
                    }
                    S::Requires(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_requires(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Requires(values.ok_or_else(
                            || ErrorKind::MissingElement("requires".into()),
                        )?))
                    }
                    S::Conflicts(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_conflicts(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Conflicts(values.ok_or_else(
                            || ErrorKind::MissingElement("conflicts".into()),
                        )?))
                    }
                    S::Value(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_value(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Value(values.ok_or_else(|| {
                            ErrorKind::MissingElement("Value".into())
                        })?))
                    }
                    S::Group(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_group(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Group(values.ok_or_else(|| {
                            ErrorKind::MissingElement("Group".into())
                        })?))
                    }
                    S::Rule(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rule(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Rule(
                            values.ok_or_else(|| ErrorKind::MissingElement("Rule".into()))?,
                        ))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::GroupTypeContent::Signature(values.ok_or_else(
                            || ErrorKind::MissingElement("signature".into()),
                        )?))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_status(
                values: &mut Option<super::StatusElementType>,
                value: super::StatusElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_dc_status(
                values: &mut Option<super::DcStatusType>,
                value: super::DcStatusType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"dc-status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_version(
                values: &mut Option<super::VersionType>,
                value: super::VersionType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"version",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextWithSubType>,
                value: super::TextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_description(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"description",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_warning(
                values: &mut Option<super::WarningType>,
                value: super::WarningType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"warning",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_question(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"question",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_reference(
                values: &mut Option<super::ReferenceType>,
                value: super::ReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"reference",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rationale(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"rationale",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform(
                values: &mut Option<super::OverrideableCpe2IdrefType>,
                value: super::OverrideableCpe2IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_requires(
                values: &mut Option<super::IdrefListType>,
                value: super::IdrefListType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"requires",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_conflicts(
                values: &mut Option<super::IdrefType>,
                value: super::IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"conflicts",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_value(
                values: &mut Option<super::ValueType>,
                value: super::ValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_group(
                values: &mut Option<super::GroupType>,
                value: super::GroupType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Group",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rule(
                values: &mut Option<super::RuleType>,
                value: super::RuleType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Rule")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::StatusElementType>,
                output: DeserializerOutput<'de, super::StatusElementType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Status(values, None),
                        Some(GroupTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Status(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Status(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Status(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_dc_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::DcStatusType>,
                output: DeserializerOutput<'de, super::DcStatusType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::DcStatus(values, None),
                        Some(GroupTypeContentDeserializerState::DcStatus(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::DcStatus(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::DcStatus(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_dc_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dc_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::DcStatus(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::DcStatus(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_version<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::VersionType>,
                output: DeserializerOutput<'de, super::VersionType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Version(values, None),
                        Some(GroupTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Version(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_version(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_version(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Version(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Version(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextWithSubType>,
                output: DeserializerOutput<'de, super::TextWithSubType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Title(values, None),
                        Some(GroupTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Title(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Title(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_description<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Description(values, None),
                        Some(GroupTypeContentDeserializerState::Description(
                            _,
                            Some(deserializer),
                        )) => GroupTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Description(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_description(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_description(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Description(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = GroupTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_warning<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::WarningType>,
                output: DeserializerOutput<'de, super::WarningType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Warning(values, None),
                        Some(GroupTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Warning(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_warning(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_warning(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Warning(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Warning(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_question<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Question(values, None),
                        Some(GroupTypeContentDeserializerState::Question(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Question(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Question(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_question(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_question(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Question(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Question(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_reference<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ReferenceType>,
                output: DeserializerOutput<'de, super::ReferenceType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Reference(values, None),
                        Some(GroupTypeContentDeserializerState::Reference(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Reference(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Reference(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_reference(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_reference(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Reference(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = GroupTypeContentDeserializerState::Reference(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Metadata(values, None),
                        Some(GroupTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Metadata(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Metadata(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Metadata(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rationale<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Rationale(values, None),
                        Some(GroupTypeContentDeserializerState::Rationale(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Rationale(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Rationale(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rationale(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rationale(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Rationale(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = GroupTypeContentDeserializerState::Rationale(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::OverrideableCpe2IdrefType>,
                output: DeserializerOutput<'de, super::OverrideableCpe2IdrefType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Platform(values, None),
                        Some(GroupTypeContentDeserializerState::Platform(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Platform(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Platform(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Platform(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Platform(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_requires<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdrefListType>,
                output: DeserializerOutput<'de, super::IdrefListType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Requires(values, None),
                        Some(GroupTypeContentDeserializerState::Requires(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Requires(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Requires(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_requires(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_requires(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Requires(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Requires(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_conflicts<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdrefType>,
                output: DeserializerOutput<'de, super::IdrefType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Conflicts(values, None),
                        Some(GroupTypeContentDeserializerState::Conflicts(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Conflicts(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Conflicts(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_conflicts(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_conflicts(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Conflicts(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = GroupTypeContentDeserializerState::Conflicts(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ValueType>,
                output: DeserializerOutput<'de, super::ValueType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Value(values, None),
                        Some(GroupTypeContentDeserializerState::Value(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Value(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Value(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Value(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Value(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_group<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::GroupType>,
                output: DeserializerOutput<'de, super::GroupType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Group(values, None),
                        Some(GroupTypeContentDeserializerState::Group(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Group(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Group(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_group(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_group(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Group(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Group(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rule<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::RuleType>,
                output: DeserializerOutput<'de, super::RuleType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Rule(values, None),
                        Some(GroupTypeContentDeserializerState::Rule(_, Some(deserializer))) => {
                            GroupTypeContentDeserializerState::Rule(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Rule(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rule(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rule(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Rule(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            GroupTypeContentDeserializerState::Rule(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<GroupTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = GroupTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => GroupTypeContentDeserializerState::Signature(values, None),
                        Some(GroupTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => {
                            GroupTypeContentDeserializerState::Signature(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(GroupTypeContentDeserializerState::Signature(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            GroupTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = GroupTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = GroupTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::GroupTypeContent> for GroupTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::GroupTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(GroupTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, GroupTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::GroupTypeContent>
            where
                R: DeserializeReader,
            {
                use GroupTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Status(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rationale(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rationale(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Requires(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_requires(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Conflicts(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_conflicts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Group(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_group(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rule(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Status(values, None), event) => {
                            let output =
                                <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, None), event) => {
                            let output =
                                <super::DcStatusType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, None), event) => {
                            let output =
                                <super::VersionType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output =
                                <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, None), event) => {
                            let output =
                                <super::WarningType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, None), event) => {
                            let output =
                                <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rationale(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_rationale(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, None), event) => {
                            let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Requires(values, None), event) => {
                            let output =
                                <super::IdrefListType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_requires(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Conflicts(values, None), event) => {
                            let output =
                                <super::IdrefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_conflicts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Value(values, None), event) => {
                            let output =
                                <super::ValueType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Group(values, None), event) => {
                            let output =
                                <super::GroupType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_group(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rule(values, None), event) => {
                            let output = <super::RuleType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_rule(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::GroupTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct RuleTypeDeserializer {
            abstract_: bool,
            cluster_id: Option<String>,
            extends: Option<String>,
            hidden: bool,
            prohibit_changes: bool,
            lang: Option<String>,
            base: Option<String>,
            xml_id: Option<String>,
            selected: bool,
            weight: f64,
            id: String,
            role: super::RoleEnumType,
            severity: super::SeverityEnumType,
            multiple: bool,
            content: Vec<super::RuleTypeContent>,
            state: Box<RuleTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum RuleTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::RuleTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl RuleTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut abstract_: Option<bool> = None;
                let mut cluster_id: Option<String> = None;
                let mut extends: Option<String> = None;
                let mut hidden: Option<bool> = None;
                let mut prohibit_changes: Option<bool> = None;
                let mut lang: Option<String> = None;
                let mut base: Option<String> = None;
                let mut xml_id: Option<String> = None;
                let mut selected: Option<bool> = None;
                let mut weight: Option<f64> = None;
                let mut id: Option<String> = None;
                let mut role: Option<super::RoleEnumType> = None;
                let mut severity: Option<super::SeverityEnumType> = None;
                let mut multiple: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"abstract")
                    ) {
                        reader.read_attrib(&mut abstract_, b"abstract", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"cluster-id")
                    ) {
                        reader.read_attrib(&mut cluster_id, b"cluster-id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"extends")
                    ) {
                        reader.read_attrib(&mut extends, b"extends", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"hidden")
                    ) {
                        reader.read_attrib(&mut hidden, b"hidden", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"prohibitChanges")
                    ) {
                        reader.read_attrib(
                            &mut prohibit_changes,
                            b"prohibitChanges",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selected")
                    ) {
                        reader.read_attrib(&mut selected, b"selected", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"weight")
                    ) {
                        reader.read_attrib(&mut weight, b"weight", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"role")
                    ) {
                        reader.read_attrib(&mut role, b"role", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"severity")
                    ) {
                        reader.read_attrib(&mut severity, b"severity", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"multiple")
                    ) {
                        reader.read_attrib(&mut multiple, b"multiple", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    abstract_: abstract_.unwrap_or_else(super::RuleType::default_abstract_),
                    cluster_id: cluster_id,
                    extends: extends,
                    hidden: hidden.unwrap_or_else(super::RuleType::default_hidden),
                    prohibit_changes: prohibit_changes
                        .unwrap_or_else(super::RuleType::default_prohibit_changes),
                    lang: lang,
                    base: base,
                    xml_id: xml_id,
                    selected: selected.unwrap_or_else(super::RuleType::default_selected),
                    weight: weight.unwrap_or_else(super::RuleType::default_weight),
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    role: role.unwrap_or_else(super::RuleType::default_role),
                    severity: severity.unwrap_or_else(super::RuleType::default_severity),
                    multiple: multiple.unwrap_or_else(super::RuleType::default_multiple),
                    content: Vec::new(),
                    state: Box::new(RuleTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: RuleTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let RuleTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::RuleTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::RuleTypeContent>,
                fallback: &mut Option<RuleTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback.take().unwrap_or(RuleTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = RuleTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = RuleTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(RuleTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = RuleTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::RuleType> for RuleTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::RuleType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleType>
            where
                R: DeserializeReader,
            {
                use RuleTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::RuleTypeContent as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::RuleType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, RuleTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::RuleType {
                    abstract_: self.abstract_,
                    cluster_id: self.cluster_id,
                    extends: self.extends,
                    hidden: self.hidden,
                    prohibit_changes: self.prohibit_changes,
                    lang: self.lang,
                    base: self.base,
                    xml_id: self.xml_id,
                    selected: self.selected,
                    weight: self.weight,
                    id: self.id,
                    role: self.role,
                    severity: self.severity,
                    multiple: self.multiple,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct RuleTypeContentDeserializer {
            state: Box<RuleTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum RuleTypeContentDeserializerState {
            Init__,
            Status(
                Option<super::StatusElementType>,
                Option<<super::StatusElementType as WithDeserializer>::Deserializer>,
            ),
            DcStatus(
                Option<super::DcStatusType>,
                Option<<super::DcStatusType as WithDeserializer>::Deserializer>,
            ),
            Version(
                Option<super::VersionType>,
                Option<<super::VersionType as WithDeserializer>::Deserializer>,
            ),
            Title(
                Option<super::TextWithSubType>,
                Option<<super::TextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Description(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Warning(
                Option<super::WarningType>,
                Option<<super::WarningType as WithDeserializer>::Deserializer>,
            ),
            Question(
                Option<super::TextType>,
                Option<<super::TextType as WithDeserializer>::Deserializer>,
            ),
            Reference(
                Option<super::ReferenceType>,
                Option<<super::ReferenceType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Rationale(
                Option<super::HtmlTextWithSubType>,
                Option<<super::HtmlTextWithSubType as WithDeserializer>::Deserializer>,
            ),
            Platform(
                Option<super::OverrideableCpe2IdrefType>,
                Option<<super::OverrideableCpe2IdrefType as WithDeserializer>::Deserializer>,
            ),
            Requires(
                Option<super::IdrefListType>,
                Option<<super::IdrefListType as WithDeserializer>::Deserializer>,
            ),
            Conflicts(
                Option<super::IdrefType>,
                Option<<super::IdrefType as WithDeserializer>::Deserializer>,
            ),
            Ident(
                Option<super::IdentType>,
                Option<<super::IdentType as WithDeserializer>::Deserializer>,
            ),
            ImpactMetric(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            ProfileNote(
                Option<super::ProfileNoteType>,
                Option<<super::ProfileNoteType as WithDeserializer>::Deserializer>,
            ),
            Fixtext(
                Option<super::FixTextType>,
                Option<<super::FixTextType as WithDeserializer>::Deserializer>,
            ),
            Fix(
                Option<super::FixType>,
                Option<<super::FixType as WithDeserializer>::Deserializer>,
            ),
            Check(
                Option<super::CheckType>,
                Option<<super::CheckType as WithDeserializer>::Deserializer>,
            ),
            ComplexCheck(
                Option<super::ComplexCheckType>,
                Option<<super::ComplexCheckType as WithDeserializer>::Deserializer>,
            ),
            Signature(
                Option<super::SignatureType>,
                Option<<super::SignatureType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::RuleTypeContent),
            Unknown__,
        }
        impl RuleTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"status")
                    ) {
                        let output =
                            <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"dc-status")
                    ) {
                        let output = <super::DcStatusType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_dc_status(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        let output = <super::VersionType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_version(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output =
                            <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"description")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_description(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"warning")
                    ) {
                        let output = <super::WarningType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_warning(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"question")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_question(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"reference")
                    ) {
                        let output =
                            <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_reference(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"rationale")
                    ) {
                        let output =
                            <super::HtmlTextWithSubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_rationale(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_platform(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"requires")
                    ) {
                        let output =
                            <super::IdrefListType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_requires(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"conflicts")
                    ) {
                        let output = <super::IdrefType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_conflicts(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"ident")
                    ) {
                        let output = <super::IdentType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_ident(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"impact-metric")
                    ) {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        return self.handle_impact_metric(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"profile-note")
                    ) {
                        let output =
                            <super::ProfileNoteType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_profile_note(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"fixtext")
                    ) {
                        let output = <super::FixTextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_fixtext(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"fix")
                    ) {
                        let output = <super::FixType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_fix(reader, Default::default(), output, &mut *fallback);
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"check")
                    ) {
                        let output = <super::CheckType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-check")
                    ) {
                        let output =
                            <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(RuleTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: RuleTypeContentDeserializerState,
            ) -> Result<super::RuleTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use RuleTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Status(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_status(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Status(values.ok_or_else(|| {
                            ErrorKind::MissingElement("status".into())
                        })?))
                    }
                    S::DcStatus(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_dc_status(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::DcStatus(values.ok_or_else(
                            || ErrorKind::MissingElement("dc-status".into()),
                        )?))
                    }
                    S::Version(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_version(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Version(values.ok_or_else(
                            || ErrorKind::MissingElement("version".into()),
                        )?))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Title(values.ok_or_else(|| {
                            ErrorKind::MissingElement("title".into())
                        })?))
                    }
                    S::Description(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_description(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Description(values.ok_or_else(
                            || ErrorKind::MissingElement("description".into()),
                        )?))
                    }
                    S::Warning(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_warning(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Warning(values.ok_or_else(
                            || ErrorKind::MissingElement("warning".into()),
                        )?))
                    }
                    S::Question(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_question(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Question(values.ok_or_else(
                            || ErrorKind::MissingElement("question".into()),
                        )?))
                    }
                    S::Reference(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_reference(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Reference(values.ok_or_else(
                            || ErrorKind::MissingElement("reference".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Rationale(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rationale(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Rationale(values.ok_or_else(
                            || ErrorKind::MissingElement("rationale".into()),
                        )?))
                    }
                    S::Platform(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Platform(values.ok_or_else(
                            || ErrorKind::MissingElement("platform".into()),
                        )?))
                    }
                    S::Requires(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_requires(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Requires(values.ok_or_else(
                            || ErrorKind::MissingElement("requires".into()),
                        )?))
                    }
                    S::Conflicts(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_conflicts(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Conflicts(values.ok_or_else(
                            || ErrorKind::MissingElement("conflicts".into()),
                        )?))
                    }
                    S::Ident(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_ident(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Ident(values.ok_or_else(|| {
                            ErrorKind::MissingElement("ident".into())
                        })?))
                    }
                    S::ImpactMetric(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_impact_metric(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::ImpactMetric(values.ok_or_else(
                            || ErrorKind::MissingElement("impact-metric".into()),
                        )?))
                    }
                    S::ProfileNote(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_profile_note(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::ProfileNote(values.ok_or_else(
                            || ErrorKind::MissingElement("profile-note".into()),
                        )?))
                    }
                    S::Fixtext(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_fixtext(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Fixtext(values.ok_or_else(
                            || ErrorKind::MissingElement("fixtext".into()),
                        )?))
                    }
                    S::Fix(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_fix(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Fix(
                            values.ok_or_else(|| ErrorKind::MissingElement("fix".into()))?,
                        ))
                    }
                    S::Check(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_check(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Check(values.ok_or_else(|| {
                            ErrorKind::MissingElement("check".into())
                        })?))
                    }
                    S::ComplexCheck(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_check(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::ComplexCheck(values.ok_or_else(
                            || ErrorKind::MissingElement("complex-check".into()),
                        )?))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::RuleTypeContent::Signature(values.ok_or_else(
                            || ErrorKind::MissingElement("signature".into()),
                        )?))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_status(
                values: &mut Option<super::StatusElementType>,
                value: super::StatusElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_dc_status(
                values: &mut Option<super::DcStatusType>,
                value: super::DcStatusType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"dc-status",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_version(
                values: &mut Option<super::VersionType>,
                value: super::VersionType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"version",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextWithSubType>,
                value: super::TextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_description(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"description",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_warning(
                values: &mut Option<super::WarningType>,
                value: super::WarningType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"warning",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_question(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"question",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_reference(
                values: &mut Option<super::ReferenceType>,
                value: super::ReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"reference",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rationale(
                values: &mut Option<super::HtmlTextWithSubType>,
                value: super::HtmlTextWithSubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"rationale",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform(
                values: &mut Option<super::OverrideableCpe2IdrefType>,
                value: super::OverrideableCpe2IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_requires(
                values: &mut Option<super::IdrefListType>,
                value: super::IdrefListType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"requires",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_conflicts(
                values: &mut Option<super::IdrefType>,
                value: super::IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"conflicts",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_ident(
                values: &mut Option<super::IdentType>,
                value: super::IdentType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ident",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_impact_metric(
                values: &mut Option<String>,
                value: String,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"impact-metric",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_profile_note(
                values: &mut Option<super::ProfileNoteType>,
                value: super::ProfileNoteType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"profile-note",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fixtext(
                values: &mut Option<super::FixTextType>,
                value: super::FixTextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"fixtext",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fix(
                values: &mut Option<super::FixType>,
                value: super::FixType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"fix")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_check(
                values: &mut Option<super::CheckType>,
                value: super::CheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_check(
                values: &mut Option<super::ComplexCheckType>,
                value: super::ComplexCheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::StatusElementType>,
                output: DeserializerOutput<'de, super::StatusElementType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Status(values, None),
                        Some(RuleTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Status(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Status(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Status(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Status(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_dc_status<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::DcStatusType>,
                output: DeserializerOutput<'de, super::DcStatusType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::DcStatus(values, None),
                        Some(RuleTypeContentDeserializerState::DcStatus(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::DcStatus(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::DcStatus(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_dc_status(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dc_status(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::DcStatus(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::DcStatus(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_version<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::VersionType>,
                output: DeserializerOutput<'de, super::VersionType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Version(values, None),
                        Some(RuleTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Version(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Version(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_version(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_version(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Version(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Version(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextWithSubType>,
                output: DeserializerOutput<'de, super::TextWithSubType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Title(values, None),
                        Some(RuleTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Title(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Title(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_description<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Description(values, None),
                        Some(RuleTypeContentDeserializerState::Description(
                            _,
                            Some(deserializer),
                        )) => RuleTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Description(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_description(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_description(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Description(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleTypeContentDeserializerState::Description(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_warning<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::WarningType>,
                output: DeserializerOutput<'de, super::WarningType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Warning(values, None),
                        Some(RuleTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Warning(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Warning(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_warning(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_warning(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Warning(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Warning(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_question<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Question(values, None),
                        Some(RuleTypeContentDeserializerState::Question(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Question(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Question(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_question(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_question(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Question(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Question(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_reference<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ReferenceType>,
                output: DeserializerOutput<'de, super::ReferenceType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Reference(values, None),
                        Some(RuleTypeContentDeserializerState::Reference(
                            _,
                            Some(deserializer),
                        )) => {
                            RuleTypeContentDeserializerState::Reference(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Reference(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_reference(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_reference(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Reference(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Reference(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Metadata(values, None),
                        Some(RuleTypeContentDeserializerState::Metadata(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Metadata(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Metadata(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Metadata(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rationale<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::HtmlTextWithSubType>,
                output: DeserializerOutput<'de, super::HtmlTextWithSubType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Rationale(values, None),
                        Some(RuleTypeContentDeserializerState::Rationale(
                            _,
                            Some(deserializer),
                        )) => {
                            RuleTypeContentDeserializerState::Rationale(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Rationale(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rationale(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rationale(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Rationale(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Rationale(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::OverrideableCpe2IdrefType>,
                output: DeserializerOutput<'de, super::OverrideableCpe2IdrefType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Platform(values, None),
                        Some(RuleTypeContentDeserializerState::Platform(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Platform(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Platform(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Platform(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Platform(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_requires<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdrefListType>,
                output: DeserializerOutput<'de, super::IdrefListType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Requires(values, None),
                        Some(RuleTypeContentDeserializerState::Requires(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Requires(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Requires(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_requires(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_requires(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Requires(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Requires(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_conflicts<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdrefType>,
                output: DeserializerOutput<'de, super::IdrefType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Conflicts(values, None),
                        Some(RuleTypeContentDeserializerState::Conflicts(
                            _,
                            Some(deserializer),
                        )) => {
                            RuleTypeContentDeserializerState::Conflicts(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Conflicts(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_conflicts(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_conflicts(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Conflicts(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Conflicts(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_ident<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdentType>,
                output: DeserializerOutput<'de, super::IdentType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Ident(values, None),
                        Some(RuleTypeContentDeserializerState::Ident(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Ident(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Ident(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_ident(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_ident(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Ident(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Ident(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_impact_metric<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<String>,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::ImpactMetric(values, None),
                        Some(RuleTypeContentDeserializerState::ImpactMetric(
                            _,
                            Some(deserializer),
                        )) => RuleTypeContentDeserializerState::ImpactMetric(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::ImpactMetric(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_impact_metric(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_impact_metric(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::ImpactMetric(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleTypeContentDeserializerState::ImpactMetric(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_profile_note<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileNoteType>,
                output: DeserializerOutput<'de, super::ProfileNoteType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::ProfileNote(values, None),
                        Some(RuleTypeContentDeserializerState::ProfileNote(
                            _,
                            Some(deserializer),
                        )) => RuleTypeContentDeserializerState::ProfileNote(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::ProfileNote(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_profile_note(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_profile_note(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::ProfileNote(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleTypeContentDeserializerState::ProfileNote(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_fixtext<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::FixTextType>,
                output: DeserializerOutput<'de, super::FixTextType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Fixtext(values, None),
                        Some(RuleTypeContentDeserializerState::Fixtext(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Fixtext(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Fixtext(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_fixtext(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fixtext(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Fixtext(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Fixtext(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_fix<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::FixType>,
                output: DeserializerOutput<'de, super::FixType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Fix(values, None),
                        Some(RuleTypeContentDeserializerState::Fix(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Fix(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Fix(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_fix(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fix(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Fix(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Fix(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::CheckType>,
                output: DeserializerOutput<'de, super::CheckType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Check(values, None),
                        Some(RuleTypeContentDeserializerState::Check(_, Some(deserializer))) => {
                            RuleTypeContentDeserializerState::Check(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Check(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Check(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Check(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ComplexCheckType>,
                output: DeserializerOutput<'de, super::ComplexCheckType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::ComplexCheck(values, None),
                        Some(RuleTypeContentDeserializerState::ComplexCheck(
                            _,
                            Some(deserializer),
                        )) => RuleTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::ComplexCheck(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::ComplexCheck(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<RuleTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleTypeContentDeserializerState::Signature(values, None),
                        Some(RuleTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => {
                            RuleTypeContentDeserializerState::Signature(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleTypeContentDeserializerState::Signature(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = RuleTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleTypeContentDeserializerState::Signature(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::RuleTypeContent> for RuleTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(RuleTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, RuleTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleTypeContent>
            where
                R: DeserializeReader,
            {
                use RuleTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Status(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rationale(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rationale(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Requires(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_requires(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Conflicts(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_conflicts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Ident(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_ident(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImpactMetric(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_impact_metric(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ProfileNote(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_profile_note(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fixtext(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_fixtext(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fix(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_fix(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Check(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Status(values, None), event) => {
                            let output =
                                <super::StatusElementType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DcStatus(values, None), event) => {
                            let output =
                                <super::DcStatusType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_dc_status(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Version(values, None), event) => {
                            let output =
                                <super::VersionType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_version(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output =
                                <super::TextWithSubType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Description(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_description(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Warning(values, None), event) => {
                            let output =
                                <super::WarningType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_warning(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Question(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_question(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Reference(values, None), event) => {
                            let output =
                                <super::ReferenceType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_reference(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Rationale(values, None), event) => {
                            let output = < super :: HtmlTextWithSubType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_rationale(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, None), event) => {
                            let output = < super :: OverrideableCpe2IdrefType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Requires(values, None), event) => {
                            let output =
                                <super::IdrefListType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_requires(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Conflicts(values, None), event) => {
                            let output =
                                <super::IdrefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_conflicts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Ident(values, None), event) => {
                            let output =
                                <super::IdentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ident(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImpactMetric(values, None), event) => {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_impact_metric(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ProfileNote(values, None), event) => {
                            let output =
                                <super::ProfileNoteType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_profile_note(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fixtext(values, None), event) => {
                            let output =
                                <super::FixTextType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_fixtext(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fix(values, None), event) => {
                            let output = <super::FixType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_fix(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Check(values, None), event) => {
                            let output =
                                <super::CheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, None), event) => {
                            let output =
                                <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::RuleTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct TestResultTypeDeserializer {
            id: String,
            start_time: Option<String>,
            end_time: String,
            test_system: Option<String>,
            version: Option<String>,
            xml_id: Option<String>,
            content: Vec<super::TestResultTypeContent>,
            state: Box<TestResultTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TestResultTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::TestResultTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl TestResultTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                let mut start_time: Option<String> = None;
                let mut end_time: Option<String> = None;
                let mut test_system: Option<String> = None;
                let mut version: Option<String> = None;
                let mut xml_id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"start-time")
                    ) {
                        reader.read_attrib(&mut start_time, b"start-time", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"end-time")
                    ) {
                        reader.read_attrib(&mut end_time, b"end-time", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"test-system")
                    ) {
                        reader.read_attrib(&mut test_system, b"test-system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        reader.read_attrib(&mut version, b"version", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"Id")
                    ) {
                        reader.read_attrib(&mut xml_id, b"Id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    start_time: start_time,
                    end_time: end_time.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("end-time".into()))
                    })?,
                    test_system: test_system,
                    version: version,
                    xml_id: xml_id,
                    content: Vec::new(),
                    state: Box::new(TestResultTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TestResultTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let TestResultTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::TestResultTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TestResultTypeContent>,
                fallback: &mut Option<TestResultTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(TestResultTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = TestResultTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    TestResultTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(TestResultTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = TestResultTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::TestResultType> for TestResultTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TestResultType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TestResultType>
            where
                R: DeserializeReader,
            {
                use TestResultTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: TestResultTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TestResultType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, TestResultTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::TestResultType {
                    id: self.id,
                    start_time: self.start_time,
                    end_time: self.end_time,
                    test_system: self.test_system,
                    version: self.version,
                    xml_id: self.xml_id,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct TestResultTypeContentDeserializer {
            state: Box<TestResultTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum TestResultTypeContentDeserializerState {
            Init__,
            Benchmark(
                Option<super::BenchmarkReferenceType>,
                Option<<super::BenchmarkReferenceType as WithDeserializer>::Deserializer>,
            ),
            TailoringFile(
                Option<super::TailoringReferenceType>,
                Option<<super::TailoringReferenceType as WithDeserializer>::Deserializer>,
            ),
            Title(
                Option<super::TextType>,
                Option<<super::TextType as WithDeserializer>::Deserializer>,
            ),
            Remark(
                Option<super::TextType>,
                Option<<super::TextType as WithDeserializer>::Deserializer>,
            ),
            Organization(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            Identity(
                Option<super::IdentityType>,
                Option<<super::IdentityType as WithDeserializer>::Deserializer>,
            ),
            Profile(
                Option<super::IdrefType>,
                Option<<super::IdrefType as WithDeserializer>::Deserializer>,
            ),
            Target(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            TargetAddress(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            TargetFacts(
                Option<super::TargetFactsType>,
                Option<<super::TargetFactsType as WithDeserializer>::Deserializer>,
            ),
            TargetIdRef(
                Option<super::TargetIdRefType>,
                Option<<super::TargetIdRefType as WithDeserializer>::Deserializer>,
            ),
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Platform(
                Option<super::Cpe2IdrefType>,
                Option<<super::Cpe2IdrefType as WithDeserializer>::Deserializer>,
            ),
            SetValue(
                Option<super::ProfileSetValueType>,
                Option<<super::ProfileSetValueType as WithDeserializer>::Deserializer>,
            ),
            SetComplexValue(
                Option<super::ProfileSetComplexValueType>,
                Option<<super::ProfileSetComplexValueType as WithDeserializer>::Deserializer>,
            ),
            RuleResult(
                Option<super::RuleResultType>,
                Option<<super::RuleResultType as WithDeserializer>::Deserializer>,
            ),
            Score(
                Option<super::ScoreType>,
                Option<<super::ScoreType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Signature(
                Option<super::SignatureType>,
                Option<<super::SignatureType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::TestResultTypeContent),
            Unknown__,
        }
        impl TestResultTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"benchmark")
                    ) {
                        let output = < super :: BenchmarkReferenceType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_benchmark(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"tailoring-file")
                    ) {
                        let output = < super :: TailoringReferenceType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_tailoring_file(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"title")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_title(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"remark")
                    ) {
                        let output = <super::TextType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_remark(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"organization")
                    ) {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        return self.handle_organization(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"identity")
                    ) {
                        let output = <super::IdentityType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_identity(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"profile")
                    ) {
                        let output = <super::IdrefType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_profile(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"target")
                    ) {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        return self.handle_target(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"target-address")
                    ) {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        return self.handle_target_address(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"target-facts")
                    ) {
                        let output =
                            <super::TargetFactsType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_target_facts(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"target-id-ref")
                    ) {
                        let output =
                            <super::TargetIdRefType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_target_id_ref(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        let output =
                            <super::Cpe2IdrefType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_platform(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"set-value")
                    ) {
                        let output =
                            <super::ProfileSetValueType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_set_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"set-complex-value")
                    ) {
                        let output = < super :: ProfileSetComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                        return self.handle_set_complex_value(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"rule-result")
                    ) {
                        let output =
                            <super::RuleResultType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_rule_result(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"score")
                    ) {
                        let output = <super::ScoreType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_score(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"signature")
                    ) {
                        let output =
                            <super::SignatureType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_signature(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(TestResultTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: TestResultTypeContentDeserializerState,
            ) -> Result<super::TestResultTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use TestResultTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Benchmark(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_benchmark(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Benchmark(values.ok_or_else(
                            || ErrorKind::MissingElement("benchmark".into()),
                        )?))
                    }
                    S::TailoringFile(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_tailoring_file(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::TailoringFile(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("tailoring-file".into())
                            })?,
                        ))
                    }
                    S::Title(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_title(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Title(values.ok_or_else(
                            || ErrorKind::MissingElement("title".into()),
                        )?))
                    }
                    S::Remark(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_remark(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Remark(values.ok_or_else(
                            || ErrorKind::MissingElement("remark".into()),
                        )?))
                    }
                    S::Organization(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_organization(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Organization(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("organization".into()))?,
                        ))
                    }
                    S::Identity(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_identity(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Identity(values.ok_or_else(
                            || ErrorKind::MissingElement("identity".into()),
                        )?))
                    }
                    S::Profile(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_profile(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Profile(values.ok_or_else(
                            || ErrorKind::MissingElement("profile".into()),
                        )?))
                    }
                    S::Target(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_target(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Target(values.ok_or_else(
                            || ErrorKind::MissingElement("target".into()),
                        )?))
                    }
                    S::TargetAddress(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_target_address(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::TargetAddress(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("target-address".into())
                            })?,
                        ))
                    }
                    S::TargetFacts(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_target_facts(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::TargetFacts(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("target-facts".into()))?,
                        ))
                    }
                    S::TargetIdRef(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_target_id_ref(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::TargetIdRef(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("target-id-ref".into()))?,
                        ))
                    }
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Any(values.ok_or_else(
                            || ErrorKind::MissingElement("any54".into()),
                        )?))
                    }
                    S::Platform(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_platform(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Platform(values.ok_or_else(
                            || ErrorKind::MissingElement("platform".into()),
                        )?))
                    }
                    S::SetValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_set_value(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::SetValue(values.ok_or_else(
                            || ErrorKind::MissingElement("set-value".into()),
                        )?))
                    }
                    S::SetComplexValue(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_set_complex_value(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::SetComplexValue(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("set-complex-value".into())
                            })?,
                        ))
                    }
                    S::RuleResult(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_rule_result(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::RuleResult(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("rule-result".into()))?,
                        ))
                    }
                    S::Score(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_score(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Score(values.ok_or_else(
                            || ErrorKind::MissingElement("score".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Signature(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_signature(&mut values, value)?;
                        }
                        Ok(super::TestResultTypeContent::Signature(values.ok_or_else(
                            || ErrorKind::MissingElement("signature".into()),
                        )?))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_benchmark(
                values: &mut Option<super::BenchmarkReferenceType>,
                value: super::BenchmarkReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"benchmark",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_tailoring_file(
                values: &mut Option<super::TailoringReferenceType>,
                value: super::TailoringReferenceType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"tailoring-file",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_title(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"title",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_remark(
                values: &mut Option<super::TextType>,
                value: super::TextType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"remark",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_organization(values: &mut Option<String>, value: String) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"organization",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_identity(
                values: &mut Option<super::IdentityType>,
                value: super::IdentityType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"identity",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_profile(
                values: &mut Option<super::IdrefType>,
                value: super::IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"profile",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_target(values: &mut Option<String>, value: String) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"target",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_target_address(
                values: &mut Option<String>,
                value: String,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"target-address",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_target_facts(
                values: &mut Option<super::TargetFactsType>,
                value: super::TargetFactsType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"target-facts",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_target_id_ref(
                values: &mut Option<super::TargetIdRefType>,
                value: super::TargetIdRefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"target-id-ref",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any54",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_platform(
                values: &mut Option<super::Cpe2IdrefType>,
                value: super::Cpe2IdrefType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"platform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_set_value(
                values: &mut Option<super::ProfileSetValueType>,
                value: super::ProfileSetValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"set-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_set_complex_value(
                values: &mut Option<super::ProfileSetComplexValueType>,
                value: super::ProfileSetComplexValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"set-complex-value",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_rule_result(
                values: &mut Option<super::RuleResultType>,
                value: super::RuleResultType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"rule-result",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_score(
                values: &mut Option<super::ScoreType>,
                value: super::ScoreType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"score",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_signature(
                values: &mut Option<super::SignatureType>,
                value: super::SignatureType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"signature",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_benchmark<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::BenchmarkReferenceType>,
                output: DeserializerOutput<'de, super::BenchmarkReferenceType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Benchmark(values, None),
                        Some(TestResultTypeContentDeserializerState::Benchmark(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Benchmark(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Benchmark(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_benchmark(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_benchmark(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Benchmark(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Benchmark(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_tailoring_file<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TailoringReferenceType>,
                output: DeserializerOutput<'de, super::TailoringReferenceType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::TailoringFile(values, None),
                        Some(TestResultTypeContentDeserializerState::TailoringFile(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::TailoringFile(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::TailoringFile(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_tailoring_file(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_tailoring_file(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::TailoringFile(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::TailoringFile(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Title(values, None),
                        Some(TestResultTypeContentDeserializerState::Title(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Title(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Title(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_title(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_title(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Title(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Title(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TextType>,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Remark(values, None),
                        Some(TestResultTypeContentDeserializerState::Remark(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Remark(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Remark(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_remark(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_remark(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Remark(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Remark(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_organization<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<String>,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Organization(values, None),
                        Some(TestResultTypeContentDeserializerState::Organization(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Organization(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Organization(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_organization(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_organization(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Organization(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Organization(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_identity<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdentityType>,
                output: DeserializerOutput<'de, super::IdentityType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Identity(values, None),
                        Some(TestResultTypeContentDeserializerState::Identity(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Identity(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Identity(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_identity(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_identity(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Identity(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Identity(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_profile<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdrefType>,
                output: DeserializerOutput<'de, super::IdrefType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Profile(values, None),
                        Some(TestResultTypeContentDeserializerState::Profile(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Profile(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Profile(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_profile(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_profile(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Profile(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Profile(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_target<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<String>,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Target(values, None),
                        Some(TestResultTypeContentDeserializerState::Target(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Target(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Target(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_target(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_target(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Target(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Target(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_target_address<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<String>,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::TargetAddress(values, None),
                        Some(TestResultTypeContentDeserializerState::TargetAddress(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::TargetAddress(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::TargetAddress(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_target_address(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_target_address(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::TargetAddress(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::TargetAddress(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_target_facts<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TargetFactsType>,
                output: DeserializerOutput<'de, super::TargetFactsType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::TargetFacts(values, None),
                        Some(TestResultTypeContentDeserializerState::TargetFacts(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::TargetFacts(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::TargetFacts(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_target_facts(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_target_facts(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::TargetFacts(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::TargetFacts(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_target_id_ref<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::TargetIdRefType>,
                output: DeserializerOutput<'de, super::TargetIdRefType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::TargetIdRef(values, None),
                        Some(TestResultTypeContentDeserializerState::TargetIdRef(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::TargetIdRef(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::TargetIdRef(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_target_id_ref(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_target_id_ref(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::TargetIdRef(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::TargetIdRef(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Any(values, None),
                        Some(TestResultTypeContentDeserializerState::Any(
                            _,
                            Some(deserializer),
                        )) => {
                            TestResultTypeContentDeserializerState::Any(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            TestResultTypeContentDeserializerState::Any(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::Cpe2IdrefType>,
                output: DeserializerOutput<'de, super::Cpe2IdrefType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Platform(values, None),
                        Some(TestResultTypeContentDeserializerState::Platform(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Platform(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_platform(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_platform(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Platform(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Platform(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_set_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileSetValueType>,
                output: DeserializerOutput<'de, super::ProfileSetValueType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::SetValue(values, None),
                        Some(TestResultTypeContentDeserializerState::SetValue(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::SetValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::SetValue(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_set_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_set_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::SetValue(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::SetValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_set_complex_value<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ProfileSetComplexValueType>,
                output: DeserializerOutput<'de, super::ProfileSetComplexValueType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            TestResultTypeContentDeserializerState::SetComplexValue(values, None)
                        }
                        Some(TestResultTypeContentDeserializerState::SetComplexValue(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::SetComplexValue(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::SetComplexValue(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_set_complex_value(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_set_complex_value(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::SetComplexValue(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::SetComplexValue(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_rule_result<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::RuleResultType>,
                output: DeserializerOutput<'de, super::RuleResultType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::RuleResult(values, None),
                        Some(TestResultTypeContentDeserializerState::RuleResult(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::RuleResult(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::RuleResult(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_rule_result(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_rule_result(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::RuleResult(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::RuleResult(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_score<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ScoreType>,
                output: DeserializerOutput<'de, super::ScoreType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Score(values, None),
                        Some(TestResultTypeContentDeserializerState::Score(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Score(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Score(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_score(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_score(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Score(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Score(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Metadata(values, None),
                        Some(TestResultTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Metadata(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_signature<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SignatureType>,
                output: DeserializerOutput<'de, super::SignatureType>,
                fallback: &mut Option<TestResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = TestResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => TestResultTypeContentDeserializerState::Signature(values, None),
                        Some(TestResultTypeContentDeserializerState::Signature(
                            _,
                            Some(deserializer),
                        )) => TestResultTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(TestResultTypeContentDeserializerState::Signature(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_signature(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_signature(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            TestResultTypeContentDeserializerState::Signature(values, None),
                        )?;
                        *self.state = TestResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = TestResultTypeContentDeserializerState::Signature(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::TestResultTypeContent> for TestResultTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TestResultTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(TestResultTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, TestResultTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TestResultTypeContent>
            where
                R: DeserializeReader,
            {
                use TestResultTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Benchmark(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_benchmark(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TailoringFile(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_tailoring_file(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Remark(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Organization(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_organization(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Identity(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_identity(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Profile(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_profile(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Target(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_target(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetAddress(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_target_address(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetFacts(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_target_facts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetIdRef(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_target_id_ref(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_set_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetComplexValue(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_set_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RuleResult(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_rule_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Score(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_score(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Benchmark(values, None), event) => {
                            let output = < super :: BenchmarkReferenceType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_benchmark(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TailoringFile(values, None), event) => {
                            let output = < super :: TailoringReferenceType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_tailoring_file(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Title(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_title(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Remark(values, None), event) => {
                            let output = <super::TextType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_remark(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Organization(values, None), event) => {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_organization(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Identity(values, None), event) => {
                            let output =
                                <super::IdentityType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_identity(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Profile(values, None), event) => {
                            let output =
                                <super::IdrefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_profile(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Target(values, None), event) => {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_target(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetAddress(values, None), event) => {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_target_address(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetFacts(values, None), event) => {
                            let output =
                                <super::TargetFactsType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_target_facts(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TargetIdRef(values, None), event) => {
                            let output =
                                <super::TargetIdRefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_target_id_ref(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Platform(values, None), event) => {
                            let output =
                                <super::Cpe2IdrefType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_platform(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetValue(values, None), event) => {
                            let output = < super :: ProfileSetValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_set_value(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::SetComplexValue(values, None), event) => {
                            let output = < super :: ProfileSetComplexValueType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_set_complex_value(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RuleResult(values, None), event) => {
                            let output =
                                <super::RuleResultType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_rule_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Score(values, None), event) => {
                            let output =
                                <super::ScoreType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_score(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Signature(values, None), event) => {
                            let output =
                                <super::SignatureType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_signature(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::TestResultTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct SignatureTypeDeserializer {
            any: Option<AnyElement>,
            state: Box<SignatureTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SignatureTypeDeserializerState {
            Init__,
            Any(Option<<AnyElement as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl SignatureTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    any: None,
                    state: Box::new(SignatureTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SignatureTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use SignatureTypeDeserializerState as S;
                match state {
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_any(&mut self, value: AnyElement) -> Result<(), Error> {
                if self.any.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any10",
                    )))?;
                }
                self.any = Some(value);
                Ok(())
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<SignatureTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.any.is_some() {
                        fallback.get_or_insert(SignatureTypeDeserializerState::Any(None));
                        *self.state = SignatureTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    } else {
                        *self.state = SignatureTypeDeserializerState::Any(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = SignatureTypeDeserializerState::Done__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(SignatureTypeDeserializerState::Any(Some(
                                    deserializer,
                                )));
                                *self.state = SignatureTypeDeserializerState::Done__;
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    SignatureTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::SignatureType> for SignatureTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SignatureType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SignatureType>
            where
                R: DeserializeReader,
            {
                use SignatureTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = SignatureTypeDeserializerState::Any(None);
                            event
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::Done__;
                                event
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SignatureType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, SignatureTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::SignatureType {
                    any: self
                        .any
                        .ok_or_else(|| ErrorKind::MissingElement("any10".into()))?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SubTypeDeserializer {
            idref: String,
            use_: super::SubUseEnumType,
            state: Box<SubTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SubTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl SubTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut use_: Option<super::SubUseEnumType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"use")
                    ) {
                        reader.read_attrib(&mut use_, b"use", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    use_: use_.unwrap_or_else(super::SubType::default_use_),
                    state: Box::new(SubTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SubTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::SubType> for SubTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::SubType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SubType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SubType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, SubTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::SubType {
                    idref: self.idref,
                    use_: self.use_,
                })
            }
        }
        #[derive(Debug)]
        pub struct ParamTypeDeserializer {
            name: String,
            content: Option<String>,
            state: Box<ParamTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ParamTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ParamTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut name: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"name")
                    ) {
                        reader.read_attrib(&mut name, b"name", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("name".into()))
                    })?,
                    content: None,
                    state: Box::new(ParamTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ParamTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ParamTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::ParamType>
            where
                R: DeserializeReader,
            {
                use ParamTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ParamType> for ParamTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::ParamType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ParamType>
            where
                R: DeserializeReader,
            {
                use ParamTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ParamType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, ParamTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::ParamType {
                    name: self.name,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct TextWithSubTypeDeserializer {
            lang: Option<String>,
            override_: bool,
            text_before: Option<Text>,
            sub: Vec<Mixed<super::SubType>>,
            state: Box<TextWithSubTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TextWithSubTypeDeserializerState {
            Init__,
            TextBefore(Option<<Text as WithDeserializer>::Deserializer>),
            Sub(Option<<Mixed<super::SubType> as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl TextWithSubTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut override_: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    override_: override_.unwrap_or_else(super::TextWithSubType::default_override_),
                    text_before: None,
                    sub: Vec::new(),
                    state: Box::new(TextWithSubTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TextWithSubTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use TextWithSubTypeDeserializerState as S;
                match state {
                    S::TextBefore(Some(deserializer)) => {
                        self.store_text_before(deserializer.finish(reader)?)?
                    }
                    S::Sub(Some(deserializer)) => self.store_sub(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_text_before(&mut self, value: Text) -> Result<(), Error> {
                if self.text_before.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"text_before",
                    )))?;
                }
                self.text_before = Some(value);
                Ok(())
            }
            fn store_sub(&mut self, value: Mixed<super::SubType>) -> Result<(), Error> {
                self.sub.push(value);
                Ok(())
            }
            fn handle_text_before<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<TextWithSubTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(TextWithSubTypeDeserializerState::TextBefore(None));
                    *self.state = TextWithSubTypeDeserializerState::Sub(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_text_before(data)?;
                        *self.state = TextWithSubTypeDeserializerState::Sub(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    TextWithSubTypeDeserializerState::TextBefore(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = TextWithSubTypeDeserializerState::Sub(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = TextWithSubTypeDeserializerState::TextBefore(Some(
                                    deserializer,
                                ));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Mixed<super::SubType>>,
                fallback: &mut Option<TextWithSubTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(TextWithSubTypeDeserializerState::Sub(None));
                    *self.state = TextWithSubTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_sub(data)?;
                        *self.state = TextWithSubTypeDeserializerState::Sub(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(TextWithSubTypeDeserializerState::Sub(
                                    Some(deserializer),
                                ));
                                *self.state = TextWithSubTypeDeserializerState::Sub(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    TextWithSubTypeDeserializerState::Sub(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::TextWithSubType> for TextWithSubTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TextWithSubType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TextWithSubType>
            where
                R: DeserializeReader,
            {
                use TextWithSubTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::TextBefore(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Sub(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = TextWithSubTypeDeserializerState::TextBefore(None);
                            event
                        }
                        (S::TextBefore(None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Sub(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"sub",
                                false,
                            )?;
                            match self.handle_sub(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TextWithSubType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    TextWithSubTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::TextWithSubType {
                    lang: self.lang,
                    override_: self.override_,
                    text_before: self.text_before,
                    sub: self.sub,
                })
            }
        }
        #[derive(Debug)]
        pub struct OverrideableCpe2IdrefTypeDeserializer {
            idref: String,
            override_: bool,
            state: Box<OverrideableCpe2IdrefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OverrideableCpe2IdrefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl OverrideableCpe2IdrefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut override_: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    override_: override_
                        .unwrap_or_else(super::OverrideableCpe2IdrefType::default_override_),
                    state: Box::new(OverrideableCpe2IdrefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: OverrideableCpe2IdrefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::OverrideableCpe2IdrefType>
            for OverrideableCpe2IdrefTypeDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OverrideableCpe2IdrefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OverrideableCpe2IdrefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::OverrideableCpe2IdrefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    OverrideableCpe2IdrefTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::OverrideableCpe2IdrefType {
                    idref: self.idref,
                    override_: self.override_,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileSelectTypeDeserializer {
            idref: String,
            selected: bool,
            remark: Vec<super::TextType>,
            state: Box<ProfileSelectTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileSelectTypeDeserializerState {
            Init__,
            Remark(Option<<super::TextType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ProfileSelectTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut selected: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selected")
                    ) {
                        reader.read_attrib(&mut selected, b"selected", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    selected: selected.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("selected".into()))
                    })?,
                    remark: Vec::new(),
                    state: Box::new(ProfileSelectTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileSelectTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ProfileSelectTypeDeserializerState as S;
                match state {
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_remark(&mut self, value: super::TextType) -> Result<(), Error> {
                self.remark.push(value);
                Ok(())
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<ProfileSelectTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ProfileSelectTypeDeserializerState::Remark(None));
                    *self.state = ProfileSelectTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state = ProfileSelectTypeDeserializerState::Remark(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ProfileSelectTypeDeserializerState::Remark(
                                    Some(deserializer),
                                ));
                                *self.state = ProfileSelectTypeDeserializerState::Remark(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ProfileSelectTypeDeserializerState::Remark(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileSelectType> for ProfileSelectTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSelectType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSelectType>
            where
                R: DeserializeReader,
            {
                use ProfileSelectTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ProfileSelectTypeDeserializerState::Remark(None);
                            event
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"remark",
                                false,
                            )?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileSelectType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileSelectTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileSelectType {
                    idref: self.idref,
                    selected: self.selected,
                    remark: self.remark,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileSetComplexValueTypeDeserializer {
            idref: String,
            item: Vec<String>,
            state: Box<ProfileSetComplexValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileSetComplexValueTypeDeserializerState {
            Init__,
            Item(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ProfileSetComplexValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    item: Vec::new(),
                    state: Box::new(ProfileSetComplexValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileSetComplexValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ProfileSetComplexValueTypeDeserializerState as S;
                match state {
                    S::Item(Some(deserializer)) => self.store_item(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_item(&mut self, value: String) -> Result<(), Error> {
                self.item.push(value);
                Ok(())
            }
            fn handle_item<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<ProfileSetComplexValueTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ProfileSetComplexValueTypeDeserializerState::Item(None));
                    *self.state = ProfileSetComplexValueTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_item(data)?;
                        *self.state = ProfileSetComplexValueTypeDeserializerState::Item(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    ProfileSetComplexValueTypeDeserializerState::Item(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state =
                                    ProfileSetComplexValueTypeDeserializerState::Item(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = ProfileSetComplexValueTypeDeserializerState::Item(
                                    Some(deserializer),
                                );
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileSetComplexValueType>
            for ProfileSetComplexValueTypeDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSetComplexValueType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSetComplexValueType>
            where
                R: DeserializeReader,
            {
                use ProfileSetComplexValueTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Item(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ProfileSetComplexValueTypeDeserializerState::Item(None);
                            event
                        }
                        (S::Item(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"item",
                                false,
                            )?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileSetComplexValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileSetComplexValueTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileSetComplexValueType {
                    idref: self.idref,
                    item: self.item,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileSetValueTypeDeserializer {
            idref: String,
            content: Option<String>,
            state: Box<ProfileSetValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileSetValueTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ProfileSetValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    content: None,
                    state: Box::new(ProfileSetValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileSetValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ProfileSetValueTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::ProfileSetValueType>
            where
                R: DeserializeReader,
            {
                use ProfileSetValueTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ProfileSetValueType> for ProfileSetValueTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSetValueType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileSetValueType>
            where
                R: DeserializeReader,
            {
                use ProfileSetValueTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileSetValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileSetValueTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileSetValueType {
                    idref: self.idref,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileRefineValueTypeDeserializer {
            idref: String,
            selector: Option<String>,
            operator: Option<super::ValueOperatorType>,
            remark: Vec<super::TextType>,
            state: Box<ProfileRefineValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileRefineValueTypeDeserializerState {
            Init__,
            Remark(Option<<super::TextType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ProfileRefineValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut selector: Option<String> = None;
                let mut operator: Option<super::ValueOperatorType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"operator")
                    ) {
                        reader.read_attrib(&mut operator, b"operator", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    selector: selector,
                    operator: operator,
                    remark: Vec::new(),
                    state: Box::new(ProfileRefineValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileRefineValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ProfileRefineValueTypeDeserializerState as S;
                match state {
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_remark(&mut self, value: super::TextType) -> Result<(), Error> {
                self.remark.push(value);
                Ok(())
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<ProfileRefineValueTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ProfileRefineValueTypeDeserializerState::Remark(None));
                    *self.state = ProfileRefineValueTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state = ProfileRefineValueTypeDeserializerState::Remark(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    ProfileRefineValueTypeDeserializerState::Remark(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = ProfileRefineValueTypeDeserializerState::Remark(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = ProfileRefineValueTypeDeserializerState::Remark(
                                    Some(deserializer),
                                );
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileRefineValueType> for ProfileRefineValueTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileRefineValueType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileRefineValueType>
            where
                R: DeserializeReader,
            {
                use ProfileRefineValueTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ProfileRefineValueTypeDeserializerState::Remark(None);
                            event
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"remark",
                                false,
                            )?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileRefineValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileRefineValueTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileRefineValueType {
                    idref: self.idref,
                    selector: self.selector,
                    operator: self.operator,
                    remark: self.remark,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileRefineRuleTypeDeserializer {
            idref: String,
            weight: Option<f64>,
            selector: Option<String>,
            severity: Option<super::SeverityEnumType>,
            role: Option<super::RoleEnumType>,
            remark: Vec<super::TextType>,
            state: Box<ProfileRefineRuleTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileRefineRuleTypeDeserializerState {
            Init__,
            Remark(Option<<super::TextType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ProfileRefineRuleTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut weight: Option<f64> = None;
                let mut selector: Option<String> = None;
                let mut severity: Option<super::SeverityEnumType> = None;
                let mut role: Option<super::RoleEnumType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"weight")
                    ) {
                        reader.read_attrib(&mut weight, b"weight", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"severity")
                    ) {
                        reader.read_attrib(&mut severity, b"severity", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"role")
                    ) {
                        reader.read_attrib(&mut role, b"role", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    weight: weight,
                    selector: selector,
                    severity: severity,
                    role: role,
                    remark: Vec::new(),
                    state: Box::new(ProfileRefineRuleTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileRefineRuleTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ProfileRefineRuleTypeDeserializerState as S;
                match state {
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_remark(&mut self, value: super::TextType) -> Result<(), Error> {
                self.remark.push(value);
                Ok(())
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<ProfileRefineRuleTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ProfileRefineRuleTypeDeserializerState::Remark(None));
                    *self.state = ProfileRefineRuleTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state = ProfileRefineRuleTypeDeserializerState::Remark(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    ProfileRefineRuleTypeDeserializerState::Remark(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = ProfileRefineRuleTypeDeserializerState::Remark(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = ProfileRefineRuleTypeDeserializerState::Remark(Some(
                                    deserializer,
                                ));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileRefineRuleType> for ProfileRefineRuleTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileRefineRuleType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileRefineRuleType>
            where
                R: DeserializeReader,
            {
                use ProfileRefineRuleTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ProfileRefineRuleTypeDeserializerState::Remark(None);
                            event
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"remark",
                                false,
                            )?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileRefineRuleType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileRefineRuleTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileRefineRuleType {
                    idref: self.idref,
                    weight: self.weight,
                    selector: self.selector,
                    severity: self.severity,
                    role: self.role,
                    remark: self.remark,
                })
            }
        }
        #[derive(Debug)]
        pub struct WarningTypeDeserializer {
            lang: Option<String>,
            override_: bool,
            category: super::WarningCategoryEnumType,
            content: Vec<super::WarningTypeContent>,
            state: Box<WarningTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum WarningTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::WarningTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl WarningTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut override_: Option<bool> = None;
                let mut category: Option<super::WarningCategoryEnumType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"category")
                    ) {
                        reader.read_attrib(&mut category, b"category", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    override_: override_.unwrap_or_else(super::WarningType::default_override_),
                    category: category.unwrap_or_else(super::WarningType::default_category),
                    content: Vec::new(),
                    state: Box::new(WarningTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: WarningTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let WarningTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::WarningTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::WarningTypeContent>,
                fallback: &mut Option<WarningTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(WarningTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = WarningTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = WarningTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(WarningTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = WarningTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::WarningType> for WarningTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::WarningType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::WarningType>
            where
                R: DeserializeReader,
            {
                use WarningTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: WarningTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::WarningType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, WarningTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::WarningType {
                    lang: self.lang,
                    override_: self.override_,
                    category: self.category,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct WarningTypeContentDeserializer {
            state: Box<WarningTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum WarningTypeContentDeserializerState {
            Init__,
            Sub(
                Option<super::SubType>,
                Option<<super::SubType as WithDeserializer>::Deserializer>,
            ),
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::WarningTypeContent),
            Unknown__,
        }
        impl WarningTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<WarningTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"sub")
                    ) {
                        let output = <super::SubType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_sub(reader, Default::default(), output, &mut *fallback);
                    }
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: WarningTypeContentDeserializerState,
            ) -> Result<super::WarningTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use WarningTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Sub(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_sub(&mut values, value)?;
                        }
                        Ok(super::WarningTypeContent::Sub(
                            values.ok_or_else(|| ErrorKind::MissingElement("sub".into()))?,
                        ))
                    }
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::WarningTypeContent::Any(values.ok_or_else(|| {
                            ErrorKind::MissingElement("any17".into())
                        })?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::WarningTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_sub(
                values: &mut Option<super::SubType>,
                value: super::SubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"sub")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any17",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SubType>,
                output: DeserializerOutput<'de, super::SubType>,
                fallback: &mut Option<WarningTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = WarningTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => WarningTypeContentDeserializerState::Sub(values, None),
                        Some(WarningTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                            WarningTypeContentDeserializerState::Sub(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(WarningTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_sub(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sub(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            WarningTypeContentDeserializerState::Sub(values, None),
                        )?;
                        *self.state = WarningTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            WarningTypeContentDeserializerState::Sub(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<WarningTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = WarningTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => WarningTypeContentDeserializerState::Any(values, None),
                        Some(WarningTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                            WarningTypeContentDeserializerState::Any(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(WarningTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            WarningTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = WarningTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            WarningTypeContentDeserializerState::Any(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<WarningTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = WarningTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => WarningTypeContentDeserializerState::Text(values, None),
                        Some(WarningTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                            WarningTypeContentDeserializerState::Text(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(WarningTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            WarningTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = WarningTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            WarningTypeContentDeserializerState::Text(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::WarningTypeContent> for WarningTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::WarningTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(WarningTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, WarningTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::WarningTypeContent>
            where
                R: DeserializeReader,
            {
                use WarningTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Sub(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sub(values, None), event) => {
                            let output = <super::SubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::WarningTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct SelStringTypeDeserializer {
            selector: String,
            content: Option<String>,
            state: Box<SelStringTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SelStringTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl SelStringTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut selector: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    selector: selector.unwrap_or_else(super::SelStringType::default_selector),
                    content: None,
                    state: Box::new(SelStringTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SelStringTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let SelStringTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::SelStringType>
            where
                R: DeserializeReader,
            {
                use SelStringTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SelStringType> for SelStringTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelStringType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelStringType>
            where
                R: DeserializeReader,
            {
                use SelStringTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SelStringType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, SelStringTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::SelStringType {
                    selector: self.selector,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SelComplexValueTypeDeserializer {
            selector: String,
            item: Vec<String>,
            state: Box<SelComplexValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SelComplexValueTypeDeserializerState {
            Init__,
            Item(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl SelComplexValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut selector: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    selector: selector.unwrap_or_else(super::SelComplexValueType::default_selector),
                    item: Vec::new(),
                    state: Box::new(SelComplexValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SelComplexValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use SelComplexValueTypeDeserializerState as S;
                match state {
                    S::Item(Some(deserializer)) => self.store_item(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_item(&mut self, value: String) -> Result<(), Error> {
                self.item.push(value);
                Ok(())
            }
            fn handle_item<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SelComplexValueTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(SelComplexValueTypeDeserializerState::Item(None));
                    *self.state = SelComplexValueTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_item(data)?;
                        *self.state = SelComplexValueTypeDeserializerState::Item(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(SelComplexValueTypeDeserializerState::Item(
                                    Some(deserializer),
                                ));
                                *self.state = SelComplexValueTypeDeserializerState::Item(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    SelComplexValueTypeDeserializerState::Item(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::SelComplexValueType> for SelComplexValueTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelComplexValueType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelComplexValueType>
            where
                R: DeserializeReader,
            {
                use SelComplexValueTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Item(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = SelComplexValueTypeDeserializerState::Item(None);
                            event
                        }
                        (S::Item(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"item",
                                false,
                            )?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SelComplexValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    SelComplexValueTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::SelComplexValueType {
                    selector: self.selector,
                    item: self.item,
                })
            }
        }
        #[derive(Debug)]
        pub struct SelNumTypeDeserializer {
            selector: String,
            content: Option<f64>,
            state: Box<SelNumTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SelNumTypeDeserializerState {
            Init__,
            Content__(<f64 as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl SelNumTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut selector: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    selector: selector.unwrap_or_else(super::SelNumType::default_selector),
                    content: None,
                    state: Box::new(SelNumTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SelNumTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let SelNumTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: f64) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, f64>,
            ) -> DeserializerResult<'de, super::SelNumType>
            where
                R: DeserializeReader,
            {
                use SelNumTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SelNumType> for SelNumTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::SelNumType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelNumType>
            where
                R: DeserializeReader,
            {
                use SelNumTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SelNumType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, SelNumTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::SelNumType {
                    selector: self.selector,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SelChoicesTypeDeserializer {
            must_match: Option<bool>,
            selector: String,
            content: Vec<super::SelChoicesTypeContent>,
            state: Box<SelChoicesTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SelChoicesTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::SelChoicesTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl SelChoicesTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut must_match: Option<bool> = None;
                let mut selector: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"mustMatch")
                    ) {
                        reader.read_attrib(&mut must_match, b"mustMatch", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    must_match: must_match,
                    selector: selector.unwrap_or_else(super::SelChoicesType::default_selector),
                    content: Vec::new(),
                    state: Box::new(SelChoicesTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: SelChoicesTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let SelChoicesTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::SelChoicesTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::SelChoicesTypeContent>,
                fallback: &mut Option<SelChoicesTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(SelChoicesTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = SelChoicesTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    SelChoicesTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(SelChoicesTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = SelChoicesTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::SelChoicesType> for SelChoicesTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelChoicesType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelChoicesType>
            where
                R: DeserializeReader,
            {
                use SelChoicesTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: SelChoicesTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::SelChoicesType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, SelChoicesTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::SelChoicesType {
                    must_match: self.must_match,
                    selector: self.selector,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct SelChoicesTypeContentDeserializer {
            state: Box<SelChoicesTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum SelChoicesTypeContentDeserializerState {
            Init__,
            Choice(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            ComplexChoice(
                Option<super::ComplexValueType>,
                Option<<super::ComplexValueType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::SelChoicesTypeContent),
            Unknown__,
        }
        impl SelChoicesTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<SelChoicesTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"choice")
                    ) {
                        let output =
                            <String as WithDeserializer>::Deserializer::init(reader, event)?;
                        return self.handle_choice(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-choice")
                    ) {
                        let output =
                            <super::ComplexValueType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_choice(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(SelChoicesTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: SelChoicesTypeContentDeserializerState,
            ) -> Result<super::SelChoicesTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use SelChoicesTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Choice(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_choice(&mut values, value)?;
                        }
                        Ok(super::SelChoicesTypeContent::Choice(values.ok_or_else(
                            || ErrorKind::MissingElement("choice".into()),
                        )?))
                    }
                    S::ComplexChoice(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_choice(&mut values, value)?;
                        }
                        Ok(super::SelChoicesTypeContent::ComplexChoice(
                            values.ok_or_else(|| {
                                ErrorKind::MissingElement("complex-choice".into())
                            })?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_choice(values: &mut Option<String>, value: String) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"choice",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_choice(
                values: &mut Option<super::ComplexValueType>,
                value: super::ComplexValueType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-choice",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_choice<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<String>,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SelChoicesTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = SelChoicesTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => SelChoicesTypeContentDeserializerState::Choice(values, None),
                        Some(SelChoicesTypeContentDeserializerState::Choice(
                            _,
                            Some(deserializer),
                        )) => SelChoicesTypeContentDeserializerState::Choice(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(SelChoicesTypeContentDeserializerState::Choice(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_choice(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_choice(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            SelChoicesTypeContentDeserializerState::Choice(values, None),
                        )?;
                        *self.state = SelChoicesTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = SelChoicesTypeContentDeserializerState::Choice(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_choice<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ComplexValueType>,
                output: DeserializerOutput<'de, super::ComplexValueType>,
                fallback: &mut Option<SelChoicesTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = SelChoicesTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => SelChoicesTypeContentDeserializerState::ComplexChoice(values, None),
                        Some(SelChoicesTypeContentDeserializerState::ComplexChoice(
                            _,
                            Some(deserializer),
                        )) => SelChoicesTypeContentDeserializerState::ComplexChoice(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(SelChoicesTypeContentDeserializerState::ComplexChoice(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_choice(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_choice(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            SelChoicesTypeContentDeserializerState::ComplexChoice(values, None),
                        )?;
                        *self.state = SelChoicesTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = SelChoicesTypeContentDeserializerState::ComplexChoice(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::SelChoicesTypeContent> for SelChoicesTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelChoicesTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(SelChoicesTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, SelChoicesTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SelChoicesTypeContent>
            where
                R: DeserializeReader,
            {
                use SelChoicesTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Choice(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_choice(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexChoice(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_choice(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Choice(values, None), event) => {
                            let output =
                                <String as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_choice(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexChoice(values, None), event) => {
                            let output =
                                <super::ComplexValueType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_complex_choice(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::SelChoicesTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct UriRefTypeDeserializer {
            uri: String,
            state: Box<UriRefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum UriRefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl UriRefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut uri: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"uri")
                    ) {
                        reader.read_attrib(&mut uri, b"uri", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    uri: uri.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("uri".into()))
                    })?,
                    state: Box::new(UriRefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: UriRefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::UriRefType> for UriRefTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::UriRefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::UriRefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::UriRefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, UriRefTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::UriRefType { uri: self.uri })
            }
        }
        #[derive(Debug)]
        pub struct IdrefListTypeDeserializer {
            idref: super::super::xs::EntitiesType,
            state: Box<IdrefListTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum IdrefListTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl IdrefListTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<super::super::xs::EntitiesType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    state: Box::new(IdrefListTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: IdrefListTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::IdrefListType> for IdrefListTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdrefListType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdrefListType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::IdrefListType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, IdrefListTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::IdrefListType { idref: self.idref })
            }
        }
        #[derive(Debug)]
        pub struct IdrefTypeDeserializer {
            idref: String,
            state: Box<IdrefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum IdrefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl IdrefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    state: Box::new(IdrefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: IdrefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::IdrefType> for IdrefTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::IdrefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdrefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::IdrefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, IdrefTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::IdrefType { idref: self.idref })
            }
        }
        #[derive(Debug)]
        pub struct IdentTypeDeserializer {
            system: String,
            any_attribute: AnyAttributes,
            content: Option<String>,
            state: Box<IdentTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum IdentTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl IdentTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut system: Option<String> = None;
                let mut any_attribute = AnyAttributes::default();
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else {
                        any_attribute.push(attrib)?;
                    }
                }
                Ok(Self {
                    system: system.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("system".into()))
                    })?,
                    any_attribute: any_attribute,
                    content: None,
                    state: Box::new(IdentTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: IdentTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let IdentTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::IdentType>
            where
                R: DeserializeReader,
            {
                use IdentTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::IdentType> for IdentTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::IdentType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdentType>
            where
                R: DeserializeReader,
            {
                use IdentTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::IdentType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, IdentTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::IdentType {
                    system: self.system,
                    any_attribute: self.any_attribute,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileNoteTypeDeserializer {
            lang: Option<String>,
            tag: String,
            content: Vec<super::ProfileNoteTypeContent>,
            state: Box<ProfileNoteTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ProfileNoteTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::ProfileNoteTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ProfileNoteTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut tag: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"tag")
                    ) {
                        reader.read_attrib(&mut tag, b"tag", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    tag: tag.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("tag".into()))
                    })?,
                    content: Vec::new(),
                    state: Box::new(ProfileNoteTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ProfileNoteTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ProfileNoteTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::ProfileNoteTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ProfileNoteTypeContent>,
                fallback: &mut Option<ProfileNoteTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(ProfileNoteTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = ProfileNoteTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ProfileNoteTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    ProfileNoteTypeDeserializerState::Content__(deserializer),
                                );
                                *self.state = ProfileNoteTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileNoteType> for ProfileNoteTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileNoteType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileNoteType>
            where
                R: DeserializeReader,
            {
                use ProfileNoteTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: ProfileNoteTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ProfileNoteType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ProfileNoteTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ProfileNoteType {
                    lang: self.lang,
                    tag: self.tag,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct ProfileNoteTypeContentDeserializer {
            state: Box<ProfileNoteTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum ProfileNoteTypeContentDeserializerState {
            Init__,
            Sub(
                Option<super::SubType>,
                Option<<super::SubType as WithDeserializer>::Deserializer>,
            ),
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::ProfileNoteTypeContent),
            Unknown__,
        }
        impl ProfileNoteTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<ProfileNoteTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"sub")
                    ) {
                        let output = <super::SubType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_sub(reader, Default::default(), output, &mut *fallback);
                    }
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: ProfileNoteTypeContentDeserializerState,
            ) -> Result<super::ProfileNoteTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use ProfileNoteTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Sub(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_sub(&mut values, value)?;
                        }
                        Ok(super::ProfileNoteTypeContent::Sub(
                            values.ok_or_else(|| ErrorKind::MissingElement("sub".into()))?,
                        ))
                    }
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::ProfileNoteTypeContent::Any(values.ok_or_else(
                            || ErrorKind::MissingElement("any19".into()),
                        )?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::ProfileNoteTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_sub(
                values: &mut Option<super::SubType>,
                value: super::SubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"sub")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any19",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SubType>,
                output: DeserializerOutput<'de, super::SubType>,
                fallback: &mut Option<ProfileNoteTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileNoteTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileNoteTypeContentDeserializerState::Sub(values, None),
                        Some(ProfileNoteTypeContentDeserializerState::Sub(
                            _,
                            Some(deserializer),
                        )) => {
                            ProfileNoteTypeContentDeserializerState::Sub(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileNoteTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_sub(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sub(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileNoteTypeContentDeserializerState::Sub(values, None),
                        )?;
                        *self.state = ProfileNoteTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileNoteTypeContentDeserializerState::Sub(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<ProfileNoteTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileNoteTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileNoteTypeContentDeserializerState::Any(values, None),
                        Some(ProfileNoteTypeContentDeserializerState::Any(
                            _,
                            Some(deserializer),
                        )) => {
                            ProfileNoteTypeContentDeserializerState::Any(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileNoteTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileNoteTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = ProfileNoteTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileNoteTypeContentDeserializerState::Any(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<ProfileNoteTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ProfileNoteTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ProfileNoteTypeContentDeserializerState::Text(values, None),
                        Some(ProfileNoteTypeContentDeserializerState::Text(
                            _,
                            Some(deserializer),
                        )) => ProfileNoteTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ProfileNoteTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ProfileNoteTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = ProfileNoteTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ProfileNoteTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ProfileNoteTypeContent> for ProfileNoteTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileNoteTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(ProfileNoteTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, ProfileNoteTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ProfileNoteTypeContent>
            where
                R: DeserializeReader,
            {
                use ProfileNoteTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Sub(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sub(values, None), event) => {
                            let output = <super::SubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::ProfileNoteTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct FixTextTypeDeserializer {
            lang: Option<String>,
            override_: bool,
            fixref: Option<String>,
            reboot: bool,
            strategy: super::FixStrategyEnumType,
            disruption: super::RatingEnumType,
            complexity: super::RatingEnumType,
            content: Vec<super::FixTextTypeContent>,
            state: Box<FixTextTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum FixTextTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::FixTextTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl FixTextTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                let mut override_: Option<bool> = None;
                let mut fixref: Option<String> = None;
                let mut reboot: Option<bool> = None;
                let mut strategy: Option<super::FixStrategyEnumType> = None;
                let mut disruption: Option<super::RatingEnumType> = None;
                let mut complexity: Option<super::RatingEnumType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        reader.read_attrib(&mut override_, b"override", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"fixref")
                    ) {
                        reader.read_attrib(&mut fixref, b"fixref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"reboot")
                    ) {
                        reader.read_attrib(&mut reboot, b"reboot", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"strategy")
                    ) {
                        reader.read_attrib(&mut strategy, b"strategy", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"disruption")
                    ) {
                        reader.read_attrib(&mut disruption, b"disruption", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"complexity")
                    ) {
                        reader.read_attrib(&mut complexity, b"complexity", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    override_: override_.unwrap_or_else(super::FixTextType::default_override_),
                    fixref: fixref,
                    reboot: reboot.unwrap_or_else(super::FixTextType::default_reboot),
                    strategy: strategy.unwrap_or_else(super::FixTextType::default_strategy),
                    disruption: disruption.unwrap_or_else(super::FixTextType::default_disruption),
                    complexity: complexity.unwrap_or_else(super::FixTextType::default_complexity),
                    content: Vec::new(),
                    state: Box::new(FixTextTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: FixTextTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let FixTextTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::FixTextTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::FixTextTypeContent>,
                fallback: &mut Option<FixTextTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(FixTextTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = FixTextTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = FixTextTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(FixTextTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = FixTextTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::FixTextType> for FixTextTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::FixTextType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixTextType>
            where
                R: DeserializeReader,
            {
                use FixTextTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: FixTextTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::FixTextType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, FixTextTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::FixTextType {
                    lang: self.lang,
                    override_: self.override_,
                    fixref: self.fixref,
                    reboot: self.reboot,
                    strategy: self.strategy,
                    disruption: self.disruption,
                    complexity: self.complexity,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct FixTextTypeContentDeserializer {
            state: Box<FixTextTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum FixTextTypeContentDeserializerState {
            Init__,
            Sub(
                Option<super::SubType>,
                Option<<super::SubType as WithDeserializer>::Deserializer>,
            ),
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::FixTextTypeContent),
            Unknown__,
        }
        impl FixTextTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<FixTextTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"sub")
                    ) {
                        let output = <super::SubType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_sub(reader, Default::default(), output, &mut *fallback);
                    }
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: FixTextTypeContentDeserializerState,
            ) -> Result<super::FixTextTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use FixTextTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Sub(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_sub(&mut values, value)?;
                        }
                        Ok(super::FixTextTypeContent::Sub(
                            values.ok_or_else(|| ErrorKind::MissingElement("sub".into()))?,
                        ))
                    }
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::FixTextTypeContent::Any(values.ok_or_else(|| {
                            ErrorKind::MissingElement("any17".into())
                        })?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::FixTextTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_sub(
                values: &mut Option<super::SubType>,
                value: super::SubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"sub")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any17",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SubType>,
                output: DeserializerOutput<'de, super::SubType>,
                fallback: &mut Option<FixTextTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTextTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTextTypeContentDeserializerState::Sub(values, None),
                        Some(FixTextTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                            FixTextTypeContentDeserializerState::Sub(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTextTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_sub(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sub(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTextTypeContentDeserializerState::Sub(values, None),
                        )?;
                        *self.state = FixTextTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTextTypeContentDeserializerState::Sub(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<FixTextTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTextTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTextTypeContentDeserializerState::Any(values, None),
                        Some(FixTextTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                            FixTextTypeContentDeserializerState::Any(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTextTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTextTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = FixTextTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTextTypeContentDeserializerState::Any(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<FixTextTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTextTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTextTypeContentDeserializerState::Text(values, None),
                        Some(FixTextTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                            FixTextTypeContentDeserializerState::Text(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTextTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTextTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = FixTextTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTextTypeContentDeserializerState::Text(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::FixTextTypeContent> for FixTextTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixTextTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(FixTextTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, FixTextTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixTextTypeContent>
            where
                R: DeserializeReader,
            {
                use FixTextTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Sub(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sub(values, None), event) => {
                            let output = <super::SubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::FixTextTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct FixTypeDeserializer {
            id: Option<String>,
            reboot: bool,
            strategy: super::FixStrategyEnumType,
            disruption: super::RatingEnumType,
            complexity: super::RatingEnumType,
            system: Option<String>,
            platform: Option<String>,
            content: Vec<super::FixTypeContent>,
            state: Box<FixTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum FixTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::FixTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl FixTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                let mut reboot: Option<bool> = None;
                let mut strategy: Option<super::FixStrategyEnumType> = None;
                let mut disruption: Option<super::RatingEnumType> = None;
                let mut complexity: Option<super::RatingEnumType> = None;
                let mut system: Option<String> = None;
                let mut platform: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"reboot")
                    ) {
                        reader.read_attrib(&mut reboot, b"reboot", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"strategy")
                    ) {
                        reader.read_attrib(&mut strategy, b"strategy", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"disruption")
                    ) {
                        reader.read_attrib(&mut disruption, b"disruption", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"complexity")
                    ) {
                        reader.read_attrib(&mut complexity, b"complexity", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"platform")
                    ) {
                        reader.read_attrib(&mut platform, b"platform", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id,
                    reboot: reboot.unwrap_or_else(super::FixType::default_reboot),
                    strategy: strategy.unwrap_or_else(super::FixType::default_strategy),
                    disruption: disruption.unwrap_or_else(super::FixType::default_disruption),
                    complexity: complexity.unwrap_or_else(super::FixType::default_complexity),
                    system: system,
                    platform: platform,
                    content: Vec::new(),
                    state: Box::new(FixTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: FixTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let FixTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::FixTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::FixTypeContent>,
                fallback: &mut Option<FixTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback.take().unwrap_or(FixTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = FixTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = FixTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(FixTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = FixTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::FixType> for FixTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::FixType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixType>
            where
                R: DeserializeReader,
            {
                use FixTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::FixTypeContent as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::FixType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, FixTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::FixType {
                    id: self.id,
                    reboot: self.reboot,
                    strategy: self.strategy,
                    disruption: self.disruption,
                    complexity: self.complexity,
                    system: self.system,
                    platform: self.platform,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct FixTypeContentDeserializer {
            state: Box<FixTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum FixTypeContentDeserializerState {
            Init__,
            Sub(
                Option<super::SubType>,
                Option<<super::SubType as WithDeserializer>::Deserializer>,
            ),
            Instance(
                Option<super::InstanceFixType>,
                Option<<super::InstanceFixType as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::FixTypeContent),
            Unknown__,
        }
        impl FixTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<FixTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"sub")
                    ) {
                        let output = <super::SubType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_sub(reader, Default::default(), output, &mut *fallback);
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"instance")
                    ) {
                        let output =
                            <super::InstanceFixType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_instance(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: FixTypeContentDeserializerState,
            ) -> Result<super::FixTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use FixTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Sub(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_sub(&mut values, value)?;
                        }
                        Ok(super::FixTypeContent::Sub(
                            values.ok_or_else(|| ErrorKind::MissingElement("sub".into()))?,
                        ))
                    }
                    S::Instance(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_instance(&mut values, value)?;
                        }
                        Ok(super::FixTypeContent::Instance(values.ok_or_else(
                            || ErrorKind::MissingElement("instance".into()),
                        )?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::FixTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_sub(
                values: &mut Option<super::SubType>,
                value: super::SubType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"sub")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_instance(
                values: &mut Option<super::InstanceFixType>,
                value: super::InstanceFixType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"instance",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_sub<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::SubType>,
                output: DeserializerOutput<'de, super::SubType>,
                fallback: &mut Option<FixTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTypeContentDeserializerState::Sub(values, None),
                        Some(FixTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                            FixTypeContentDeserializerState::Sub(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTypeContentDeserializerState::Sub(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_sub(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sub(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTypeContentDeserializerState::Sub(values, None),
                        )?;
                        *self.state = FixTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTypeContentDeserializerState::Sub(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_instance<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::InstanceFixType>,
                output: DeserializerOutput<'de, super::InstanceFixType>,
                fallback: &mut Option<FixTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTypeContentDeserializerState::Instance(values, None),
                        Some(FixTypeContentDeserializerState::Instance(_, Some(deserializer))) => {
                            FixTypeContentDeserializerState::Instance(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTypeContentDeserializerState::Instance(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_instance(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_instance(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTypeContentDeserializerState::Instance(values, None),
                        )?;
                        *self.state = FixTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTypeContentDeserializerState::Instance(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<FixTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = FixTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => FixTypeContentDeserializerState::Text(values, None),
                        Some(FixTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                            FixTypeContentDeserializerState::Text(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(FixTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            FixTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = FixTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            FixTypeContentDeserializerState::Text(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::FixTypeContent> for FixTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(FixTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, FixTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FixTypeContent>
            where
                R: DeserializeReader,
            {
                use FixTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Sub(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Instance(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_instance(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sub(values, None), event) => {
                            let output = <super::SubType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_sub(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Instance(values, None), event) => {
                            let output =
                                <super::InstanceFixType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_instance(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::FixTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct CheckTypeDeserializer {
            system: String,
            negate: bool,
            id: Option<String>,
            selector: String,
            multi_check: bool,
            base: Option<String>,
            check_import: Vec<super::CheckImportType>,
            check_export: Vec<super::CheckExportType>,
            check_content_ref: Vec<super::CheckContentRefType>,
            check_content: Option<super::CheckContentType>,
            state: Box<CheckTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckTypeDeserializerState {
            Init__,
            CheckImport(Option<<super::CheckImportType as WithDeserializer>::Deserializer>),
            CheckExport(Option<<super::CheckExportType as WithDeserializer>::Deserializer>),
            CheckContentRef(Option<<super::CheckContentRefType as WithDeserializer>::Deserializer>),
            CheckContent(Option<<super::CheckContentType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CheckTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut system: Option<String> = None;
                let mut negate: Option<bool> = None;
                let mut id: Option<String> = None;
                let mut selector: Option<String> = None;
                let mut multi_check: Option<bool> = None;
                let mut base: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"negate")
                    ) {
                        reader.read_attrib(&mut negate, b"negate", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"selector")
                    ) {
                        reader.read_attrib(&mut selector, b"selector", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"multi-check")
                    ) {
                        reader.read_attrib(&mut multi_check, b"multi-check", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"base")
                    ) {
                        reader.read_attrib(&mut base, b"base", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    system: system.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("system".into()))
                    })?,
                    negate: negate.unwrap_or_else(super::CheckType::default_negate),
                    id: id,
                    selector: selector.unwrap_or_else(super::CheckType::default_selector),
                    multi_check: multi_check.unwrap_or_else(super::CheckType::default_multi_check),
                    base: base,
                    check_import: Vec::new(),
                    check_export: Vec::new(),
                    check_content_ref: Vec::new(),
                    check_content: None,
                    state: Box::new(CheckTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use CheckTypeDeserializerState as S;
                match state {
                    S::CheckImport(Some(deserializer)) => {
                        self.store_check_import(deserializer.finish(reader)?)?
                    }
                    S::CheckExport(Some(deserializer)) => {
                        self.store_check_export(deserializer.finish(reader)?)?
                    }
                    S::CheckContentRef(Some(deserializer)) => {
                        self.store_check_content_ref(deserializer.finish(reader)?)?
                    }
                    S::CheckContent(Some(deserializer)) => {
                        self.store_check_content(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_check_import(&mut self, value: super::CheckImportType) -> Result<(), Error> {
                self.check_import.push(value);
                Ok(())
            }
            fn store_check_export(&mut self, value: super::CheckExportType) -> Result<(), Error> {
                self.check_export.push(value);
                Ok(())
            }
            fn store_check_content_ref(
                &mut self,
                value: super::CheckContentRefType,
            ) -> Result<(), Error> {
                self.check_content_ref.push(value);
                Ok(())
            }
            fn store_check_content(&mut self, value: super::CheckContentType) -> Result<(), Error> {
                if self.check_content.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"check-content",
                    )))?;
                }
                self.check_content = Some(value);
                Ok(())
            }
            fn handle_check_import<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckImportType>,
                fallback: &mut Option<CheckTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckTypeDeserializerState::CheckImport(None));
                    *self.state = CheckTypeDeserializerState::CheckExport(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_import(data)?;
                        *self.state = CheckTypeDeserializerState::CheckImport(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(CheckTypeDeserializerState::CheckImport(
                                    Some(deserializer),
                                ));
                                *self.state = CheckTypeDeserializerState::CheckImport(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckTypeDeserializerState::CheckImport(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_check_export<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckExportType>,
                fallback: &mut Option<CheckTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckTypeDeserializerState::CheckExport(None));
                    *self.state = CheckTypeDeserializerState::CheckContentRef(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_export(data)?;
                        *self.state = CheckTypeDeserializerState::CheckExport(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(CheckTypeDeserializerState::CheckExport(
                                    Some(deserializer),
                                ));
                                *self.state = CheckTypeDeserializerState::CheckExport(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckTypeDeserializerState::CheckExport(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_check_content_ref<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckContentRefType>,
                fallback: &mut Option<CheckTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckTypeDeserializerState::CheckContentRef(None));
                    *self.state = CheckTypeDeserializerState::CheckContent(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_content_ref(data)?;
                        *self.state = CheckTypeDeserializerState::CheckContentRef(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    CheckTypeDeserializerState::CheckContentRef(Some(deserializer)),
                                );
                                *self.state = CheckTypeDeserializerState::CheckContentRef(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckTypeDeserializerState::CheckContentRef(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_check_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckContentType>,
                fallback: &mut Option<CheckTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckTypeDeserializerState::CheckContent(None));
                    *self.state = CheckTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_content(data)?;
                        *self.state = CheckTypeDeserializerState::Done__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(CheckTypeDeserializerState::CheckContent(
                                    Some(deserializer),
                                ));
                                *self.state = CheckTypeDeserializerState::Done__;
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckTypeDeserializerState::CheckContent(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::CheckType> for CheckTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::CheckType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckType>
            where
                R: DeserializeReader,
            {
                use CheckTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::CheckImport(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check_import(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckExport(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check_export(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckContentRef(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check_content_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckContent(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = CheckTypeDeserializerState::CheckImport(None);
                            event
                        }
                        (S::CheckImport(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"check-import",
                                false,
                            )?;
                            match self.handle_check_import(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckExport(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"check-export",
                                false,
                            )?;
                            match self.handle_check_export(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckContentRef(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"check-content-ref",
                                false,
                            )?;
                            match self.handle_check_content_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckContent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"check-content",
                                true,
                            )?;
                            match self.handle_check_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, CheckTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::CheckType {
                    system: self.system,
                    negate: self.negate,
                    id: self.id,
                    selector: self.selector,
                    multi_check: self.multi_check,
                    base: self.base,
                    check_import: self.check_import,
                    check_export: self.check_export,
                    check_content_ref: self.check_content_ref,
                    check_content: self.check_content,
                })
            }
        }
        #[derive(Debug)]
        pub struct ComplexCheckTypeDeserializer {
            operator: super::CcOperatorEnumType,
            negate: bool,
            content: Vec<super::ComplexCheckTypeContent>,
            state: Box<ComplexCheckTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ComplexCheckTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::ComplexCheckTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ComplexCheckTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut operator: Option<super::CcOperatorEnumType> = None;
                let mut negate: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"operator")
                    ) {
                        reader.read_attrib(&mut operator, b"operator", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"negate")
                    ) {
                        reader.read_attrib(&mut negate, b"negate", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    operator: operator.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("operator".into()))
                    })?,
                    negate: negate.unwrap_or_else(super::ComplexCheckType::default_negate),
                    content: Vec::new(),
                    state: Box::new(ComplexCheckTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ComplexCheckTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ComplexCheckTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::ComplexCheckTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ComplexCheckTypeContent>,
                fallback: &mut Option<ComplexCheckTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(ComplexCheckTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = ComplexCheckTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ComplexCheckTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    ComplexCheckTypeDeserializerState::Content__(deserializer),
                                );
                                *self.state = ComplexCheckTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ComplexCheckType> for ComplexCheckTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexCheckType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexCheckType>
            where
                R: DeserializeReader,
            {
                use ComplexCheckTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: ComplexCheckTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ComplexCheckType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ComplexCheckTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ComplexCheckType {
                    operator: self.operator,
                    negate: self.negate,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct ComplexCheckTypeContentDeserializer {
            state: Box<ComplexCheckTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum ComplexCheckTypeContentDeserializerState {
            Init__,
            Check(
                Option<super::CheckType>,
                Option<<super::CheckType as WithDeserializer>::Deserializer>,
            ),
            ComplexCheck(
                Option<super::ComplexCheckType>,
                Option<<super::ComplexCheckType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::ComplexCheckTypeContent),
            Unknown__,
        }
        impl ComplexCheckTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<ComplexCheckTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"check")
                    ) {
                        let output = <super::CheckType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-check")
                    ) {
                        let output =
                            <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(ComplexCheckTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: ComplexCheckTypeContentDeserializerState,
            ) -> Result<super::ComplexCheckTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use ComplexCheckTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Check(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_check(&mut values, value)?;
                        }
                        Ok(super::ComplexCheckTypeContent::Check(values.ok_or_else(
                            || ErrorKind::MissingElement("check".into()),
                        )?))
                    }
                    S::ComplexCheck(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_check(&mut values, value)?;
                        }
                        Ok(super::ComplexCheckTypeContent::ComplexCheck(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("complex-check".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_check(
                values: &mut Option<super::CheckType>,
                value: super::CheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_check(
                values: &mut Option<super::ComplexCheckType>,
                value: super::ComplexCheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::CheckType>,
                output: DeserializerOutput<'de, super::CheckType>,
                fallback: &mut Option<ComplexCheckTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ComplexCheckTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => ComplexCheckTypeContentDeserializerState::Check(values, None),
                        Some(ComplexCheckTypeContentDeserializerState::Check(
                            _,
                            Some(deserializer),
                        )) => ComplexCheckTypeContentDeserializerState::Check(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ComplexCheckTypeContentDeserializerState::Check(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ComplexCheckTypeContentDeserializerState::Check(values, None),
                        )?;
                        *self.state = ComplexCheckTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ComplexCheckTypeContentDeserializerState::Check(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ComplexCheckType>,
                output: DeserializerOutput<'de, super::ComplexCheckType>,
                fallback: &mut Option<ComplexCheckTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = ComplexCheckTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => {
                            ComplexCheckTypeContentDeserializerState::ComplexCheck(values, None)
                        }
                        Some(ComplexCheckTypeContentDeserializerState::ComplexCheck(
                            _,
                            Some(deserializer),
                        )) => ComplexCheckTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(ComplexCheckTypeContentDeserializerState::ComplexCheck(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            ComplexCheckTypeContentDeserializerState::ComplexCheck(values, None),
                        )?;
                        *self.state = ComplexCheckTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = ComplexCheckTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ComplexCheckTypeContent>
            for ComplexCheckTypeContentDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexCheckTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(ComplexCheckTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state,
                            ComplexCheckTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexCheckTypeContent>
            where
                R: DeserializeReader,
            {
                use ComplexCheckTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Check(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Check(values, None), event) => {
                            let output =
                                <super::CheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, None), event) => {
                            let output =
                                <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::ComplexCheckTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct BenchmarkReferenceTypeDeserializer {
            href: String,
            id: Option<String>,
            state: Box<BenchmarkReferenceTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum BenchmarkReferenceTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl BenchmarkReferenceTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut href: Option<String> = None;
                let mut id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    href: href.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("href".into()))
                    })?,
                    id: id,
                    state: Box::new(BenchmarkReferenceTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: BenchmarkReferenceTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::BenchmarkReferenceType> for BenchmarkReferenceTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkReferenceType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::BenchmarkReferenceType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::BenchmarkReferenceType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    BenchmarkReferenceTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::BenchmarkReferenceType {
                    href: self.href,
                    id: self.id,
                })
            }
        }
        #[derive(Debug)]
        pub struct TailoringReferenceTypeDeserializer {
            href: String,
            id: String,
            version: String,
            time: String,
            state: Box<TailoringReferenceTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TailoringReferenceTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl TailoringReferenceTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut href: Option<String> = None;
                let mut id: Option<String> = None;
                let mut version: Option<String> = None;
                let mut time: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        reader.read_attrib(&mut version, b"version", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"time")
                    ) {
                        reader.read_attrib(&mut time, b"time", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    href: href.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("href".into()))
                    })?,
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    version: version.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("version".into()))
                    })?,
                    time: time.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("time".into()))
                    })?,
                    state: Box::new(TailoringReferenceTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TailoringReferenceTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::TailoringReferenceType> for TailoringReferenceTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TailoringReferenceType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TailoringReferenceType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TailoringReferenceType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    TailoringReferenceTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::TailoringReferenceType {
                    href: self.href,
                    id: self.id,
                    version: self.version,
                    time: self.time,
                })
            }
        }
        #[derive(Debug)]
        pub struct IdentityTypeDeserializer {
            authenticated: bool,
            privileged: bool,
            content: Option<String>,
            state: Box<IdentityTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum IdentityTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl IdentityTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut authenticated: Option<bool> = None;
                let mut privileged: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"authenticated")
                    ) {
                        reader.read_attrib(&mut authenticated, b"authenticated", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"privileged")
                    ) {
                        reader.read_attrib(&mut privileged, b"privileged", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    authenticated: authenticated.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("authenticated".into()))
                    })?,
                    privileged: privileged.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("privileged".into()))
                    })?,
                    content: None,
                    state: Box::new(IdentityTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: IdentityTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let IdentityTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::IdentityType>
            where
                R: DeserializeReader,
            {
                use IdentityTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::IdentityType> for IdentityTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdentityType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::IdentityType>
            where
                R: DeserializeReader,
            {
                use IdentityTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::IdentityType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, IdentityTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::IdentityType {
                    authenticated: self.authenticated,
                    privileged: self.privileged,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct TargetFactsTypeDeserializer {
            fact: Vec<super::FactType>,
            state: Box<TargetFactsTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TargetFactsTypeDeserializerState {
            Init__,
            Fact(Option<<super::FactType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl TargetFactsTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    fact: Vec::new(),
                    state: Box::new(TargetFactsTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TargetFactsTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use TargetFactsTypeDeserializerState as S;
                match state {
                    S::Fact(Some(deserializer)) => self.store_fact(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_fact(&mut self, value: super::FactType) -> Result<(), Error> {
                self.fact.push(value);
                Ok(())
            }
            fn handle_fact<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::FactType>,
                fallback: &mut Option<TargetFactsTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(TargetFactsTypeDeserializerState::Fact(None));
                    *self.state = TargetFactsTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fact(data)?;
                        *self.state = TargetFactsTypeDeserializerState::Fact(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(TargetFactsTypeDeserializerState::Fact(
                                    Some(deserializer),
                                ));
                                *self.state = TargetFactsTypeDeserializerState::Fact(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    TargetFactsTypeDeserializerState::Fact(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::TargetFactsType> for TargetFactsTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TargetFactsType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TargetFactsType>
            where
                R: DeserializeReader,
            {
                use TargetFactsTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Fact(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_fact(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = TargetFactsTypeDeserializerState::Fact(None);
                            event
                        }
                        (S::Fact(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"fact",
                                false,
                            )?;
                            match self.handle_fact(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TargetFactsType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    TargetFactsTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::TargetFactsType { fact: self.fact })
            }
        }
        #[derive(Debug)]
        pub struct TargetIdRefTypeDeserializer {
            system: String,
            href: String,
            name: Option<String>,
            state: Box<TargetIdRefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TargetIdRefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl TargetIdRefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut system: Option<String> = None;
                let mut href: Option<String> = None;
                let mut name: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"name")
                    ) {
                        reader.read_attrib(&mut name, b"name", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    system: system.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("system".into()))
                    })?,
                    href: href.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("href".into()))
                    })?,
                    name: name,
                    state: Box::new(TargetIdRefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TargetIdRefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::TargetIdRefType> for TargetIdRefTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TargetIdRefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TargetIdRefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TargetIdRefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    TargetIdRefTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::TargetIdRefType {
                    system: self.system,
                    href: self.href,
                    name: self.name,
                })
            }
        }
        #[derive(Debug)]
        pub struct RuleResultTypeDeserializer {
            idref: String,
            role: Option<super::RoleEnumType>,
            severity: Option<super::SeverityEnumType>,
            time: Option<String>,
            version: Option<String>,
            weight: Option<f64>,
            content: Vec<super::RuleResultTypeContent>,
            state: Box<RuleResultTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum RuleResultTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::RuleResultTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl RuleResultTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut idref: Option<String> = None;
                let mut role: Option<super::RoleEnumType> = None;
                let mut severity: Option<super::SeverityEnumType> = None;
                let mut time: Option<String> = None;
                let mut version: Option<String> = None;
                let mut weight: Option<f64> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"idref")
                    ) {
                        reader.read_attrib(&mut idref, b"idref", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"role")
                    ) {
                        reader.read_attrib(&mut role, b"role", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"severity")
                    ) {
                        reader.read_attrib(&mut severity, b"severity", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"time")
                    ) {
                        reader.read_attrib(&mut time, b"time", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"version")
                    ) {
                        reader.read_attrib(&mut version, b"version", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"weight")
                    ) {
                        reader.read_attrib(&mut weight, b"weight", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    idref: idref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("idref".into()))
                    })?,
                    role: role,
                    severity: severity,
                    time: time,
                    version: version,
                    weight: weight,
                    content: Vec::new(),
                    state: Box::new(RuleResultTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: RuleResultTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let RuleResultTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::RuleResultTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::RuleResultTypeContent>,
                fallback: &mut Option<RuleResultTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(RuleResultTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = RuleResultTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    RuleResultTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(RuleResultTypeDeserializerState::Content__(
                                    deserializer,
                                ));
                                *self.state = RuleResultTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::RuleResultType> for RuleResultTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleResultType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleResultType>
            where
                R: DeserializeReader,
            {
                use RuleResultTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: RuleResultTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::RuleResultType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, RuleResultTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::RuleResultType {
                    idref: self.idref,
                    role: self.role,
                    severity: self.severity,
                    time: self.time,
                    version: self.version,
                    weight: self.weight,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct RuleResultTypeContentDeserializer {
            state: Box<RuleResultTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum RuleResultTypeContentDeserializerState {
            Init__,
            Result(
                Option<super::ResultEnumType>,
                Option<<super::ResultEnumType as WithDeserializer>::Deserializer>,
            ),
            Override(
                Option<super::OverrideType>,
                Option<<super::OverrideType as WithDeserializer>::Deserializer>,
            ),
            Ident(
                Option<super::IdentType>,
                Option<<super::IdentType as WithDeserializer>::Deserializer>,
            ),
            Metadata(
                Option<super::MetadataType>,
                Option<<super::MetadataType as WithDeserializer>::Deserializer>,
            ),
            Message(
                Option<super::MessageType>,
                Option<<super::MessageType as WithDeserializer>::Deserializer>,
            ),
            Instance(
                Option<super::InstanceResultType>,
                Option<<super::InstanceResultType as WithDeserializer>::Deserializer>,
            ),
            Fix(
                Option<super::FixType>,
                Option<<super::FixType as WithDeserializer>::Deserializer>,
            ),
            Check(
                Option<super::CheckType>,
                Option<<super::CheckType as WithDeserializer>::Deserializer>,
            ),
            ComplexCheck(
                Option<super::ComplexCheckType>,
                Option<<super::ComplexCheckType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::RuleResultTypeContent),
            Unknown__,
        }
        impl RuleResultTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"result")
                    ) {
                        let output =
                            <super::ResultEnumType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_result(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"override")
                    ) {
                        let output = <super::OverrideType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_override_(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"ident")
                    ) {
                        let output = <super::IdentType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_ident(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"metadata")
                    ) {
                        let output = <super::MetadataType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_metadata(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"message")
                    ) {
                        let output = <super::MessageType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_message(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"instance")
                    ) {
                        let output =
                            <super::InstanceResultType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_instance(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"fix")
                    ) {
                        let output = <super::FixType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_fix(reader, Default::default(), output, &mut *fallback);
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"check")
                    ) {
                        let output = <super::CheckType as WithDeserializer>::Deserializer::init(
                            reader, event,
                        )?;
                        return self.handle_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                    if matches!(
                        reader.resolve_local_name(x.name(), &super::super::NS_CDF),
                        Some(b"complex-check")
                    ) {
                        let output =
                            <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                        return self.handle_complex_check(
                            reader,
                            Default::default(),
                            output,
                            &mut *fallback,
                        );
                    }
                }
                *self.state = fallback
                    .take()
                    .unwrap_or(RuleResultTypeContentDeserializerState::Init__);
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state<R>(
                reader: &R,
                state: RuleResultTypeContentDeserializerState,
            ) -> Result<super::RuleResultTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use RuleResultTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Result(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_result(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Result(values.ok_or_else(
                            || ErrorKind::MissingElement("result".into()),
                        )?))
                    }
                    S::Override(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_override_(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Override(values.ok_or_else(
                            || ErrorKind::MissingElement("override".into()),
                        )?))
                    }
                    S::Ident(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_ident(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Ident(values.ok_or_else(
                            || ErrorKind::MissingElement("ident".into()),
                        )?))
                    }
                    S::Metadata(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_metadata(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Metadata(values.ok_or_else(
                            || ErrorKind::MissingElement("metadata".into()),
                        )?))
                    }
                    S::Message(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_message(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Message(values.ok_or_else(
                            || ErrorKind::MissingElement("message".into()),
                        )?))
                    }
                    S::Instance(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_instance(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Instance(values.ok_or_else(
                            || ErrorKind::MissingElement("instance".into()),
                        )?))
                    }
                    S::Fix(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_fix(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Fix(
                            values.ok_or_else(|| ErrorKind::MissingElement("fix".into()))?,
                        ))
                    }
                    S::Check(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_check(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::Check(values.ok_or_else(
                            || ErrorKind::MissingElement("check".into()),
                        )?))
                    }
                    S::ComplexCheck(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_complex_check(&mut values, value)?;
                        }
                        Ok(super::RuleResultTypeContent::ComplexCheck(
                            values
                                .ok_or_else(|| ErrorKind::MissingElement("complex-check".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_result(
                values: &mut Option<super::ResultEnumType>,
                value: super::ResultEnumType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"result",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_override_(
                values: &mut Option<super::OverrideType>,
                value: super::OverrideType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"override",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_ident(
                values: &mut Option<super::IdentType>,
                value: super::IdentType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ident",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_metadata(
                values: &mut Option<super::MetadataType>,
                value: super::MetadataType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"metadata",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_message(
                values: &mut Option<super::MessageType>,
                value: super::MessageType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"message",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_instance(
                values: &mut Option<super::InstanceResultType>,
                value: super::InstanceResultType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"instance",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fix(
                values: &mut Option<super::FixType>,
                value: super::FixType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"fix")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_check(
                values: &mut Option<super::CheckType>,
                value: super::CheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_complex_check(
                values: &mut Option<super::ComplexCheckType>,
                value: super::ComplexCheckType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"complex-check",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_result<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ResultEnumType>,
                output: DeserializerOutput<'de, super::ResultEnumType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Result(values, None),
                        Some(RuleResultTypeContentDeserializerState::Result(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Result(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Result(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_result(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_result(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Result(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Result(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_override_<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::OverrideType>,
                output: DeserializerOutput<'de, super::OverrideType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Override(values, None),
                        Some(RuleResultTypeContentDeserializerState::Override(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Override(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Override(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_override_(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_override_(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Override(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Override(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_ident<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::IdentType>,
                output: DeserializerOutput<'de, super::IdentType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Ident(values, None),
                        Some(RuleResultTypeContentDeserializerState::Ident(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Ident(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Ident(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_ident(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_ident(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Ident(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Ident(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_metadata<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MetadataType>,
                output: DeserializerOutput<'de, super::MetadataType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Metadata(values, None),
                        Some(RuleResultTypeContentDeserializerState::Metadata(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Metadata(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_metadata(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_metadata(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Metadata(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Metadata(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_message<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::MessageType>,
                output: DeserializerOutput<'de, super::MessageType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Message(values, None),
                        Some(RuleResultTypeContentDeserializerState::Message(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Message(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Message(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_message(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_message(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Message(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Message(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_instance<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::InstanceResultType>,
                output: DeserializerOutput<'de, super::InstanceResultType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Instance(values, None),
                        Some(RuleResultTypeContentDeserializerState::Instance(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Instance(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Instance(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_instance(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_instance(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Instance(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Instance(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_fix<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::FixType>,
                output: DeserializerOutput<'de, super::FixType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Fix(values, None),
                        Some(RuleResultTypeContentDeserializerState::Fix(
                            _,
                            Some(deserializer),
                        )) => {
                            RuleResultTypeContentDeserializerState::Fix(values, Some(deserializer))
                        }
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Fix(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_fix(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fix(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Fix(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state =
                            RuleResultTypeContentDeserializerState::Fix(values, Some(deserializer));
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::CheckType>,
                output: DeserializerOutput<'de, super::CheckType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::Check(values, None),
                        Some(RuleResultTypeContentDeserializerState::Check(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::Check(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::Check(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::Check(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::Check(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_complex_check<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<super::ComplexCheckType>,
                output: DeserializerOutput<'de, super::ComplexCheckType>,
                fallback: &mut Option<RuleResultTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = RuleResultTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => RuleResultTypeContentDeserializerState::ComplexCheck(values, None),
                        Some(RuleResultTypeContentDeserializerState::ComplexCheck(
                            _,
                            Some(deserializer),
                        )) => RuleResultTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(RuleResultTypeContentDeserializerState::ComplexCheck(
                        _,
                        Some(deserializer),
                    )) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_complex_check(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_complex_check(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            RuleResultTypeContentDeserializerState::ComplexCheck(values, None),
                        )?;
                        *self.state = RuleResultTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = RuleResultTypeContentDeserializerState::ComplexCheck(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::RuleResultTypeContent> for RuleResultTypeContentDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleResultTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(RuleResultTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state, RuleResultTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::RuleResultTypeContent>
            where
                R: DeserializeReader,
            {
                use RuleResultTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Result(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Override(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_override_(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Ident(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_ident(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Message(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_message(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Instance(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_instance(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fix(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_fix(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Check(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Result(values, None), event) => {
                            let output =
                                <super::ResultEnumType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_result(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Override(values, None), event) => {
                            let output =
                                <super::OverrideType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_override_(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Ident(values, None), event) => {
                            let output =
                                <super::IdentType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_ident(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Metadata(values, None), event) => {
                            let output =
                                <super::MetadataType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_metadata(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Message(values, None), event) => {
                            let output =
                                <super::MessageType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_message(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Instance(values, None), event) => {
                            let output = < super :: InstanceResultType as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_instance(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fix(values, None), event) => {
                            let output = <super::FixType as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_fix(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Check(values, None), event) => {
                            let output =
                                <super::CheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_check(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ComplexCheck(values, None), event) => {
                            let output =
                                <super::ComplexCheckType as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                            match self.handle_complex_check(
                                reader,
                                values,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::RuleResultTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct ScoreTypeDeserializer {
            system: Option<String>,
            maximum: Option<f64>,
            content: Option<f64>,
            state: Box<ScoreTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ScoreTypeDeserializerState {
            Init__,
            Content__(<f64 as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ScoreTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut system: Option<String> = None;
                let mut maximum: Option<f64> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"maximum")
                    ) {
                        reader.read_attrib(&mut maximum, b"maximum", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    system: system,
                    maximum: maximum,
                    content: None,
                    state: Box::new(ScoreTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ScoreTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let ScoreTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: f64) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, f64>,
            ) -> DeserializerResult<'de, super::ScoreType>
            where
                R: DeserializeReader,
            {
                use ScoreTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ScoreType> for ScoreTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::ScoreType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ScoreType>
            where
                R: DeserializeReader,
            {
                use ScoreTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ScoreType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, ScoreTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::ScoreType {
                    system: self.system,
                    maximum: self.maximum,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ComplexValueTypeDeserializer {
            item: Vec<String>,
            state: Box<ComplexValueTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ComplexValueTypeDeserializerState {
            Init__,
            Item(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ComplexValueTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    item: Vec::new(),
                    state: Box::new(ComplexValueTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: ComplexValueTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use ComplexValueTypeDeserializerState as S;
                match state {
                    S::Item(Some(deserializer)) => self.store_item(deserializer.finish(reader)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_item(&mut self, value: String) -> Result<(), Error> {
                self.item.push(value);
                Ok(())
            }
            fn handle_item<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<ComplexValueTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(ComplexValueTypeDeserializerState::Item(None));
                    *self.state = ComplexValueTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_item(data)?;
                        *self.state = ComplexValueTypeDeserializerState::Item(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(ComplexValueTypeDeserializerState::Item(
                                    Some(deserializer),
                                ));
                                *self.state = ComplexValueTypeDeserializerState::Item(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    ComplexValueTypeDeserializerState::Item(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::ComplexValueType> for ComplexValueTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexValueType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ComplexValueType>
            where
                R: DeserializeReader,
            {
                use ComplexValueTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Item(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = ComplexValueTypeDeserializerState::Item(None);
                            event
                        }
                        (S::Item(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"item",
                                false,
                            )?;
                            match self.handle_item(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::ComplexValueType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    ComplexValueTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::ComplexValueType { item: self.item })
            }
        }
        #[derive(Debug)]
        pub struct InstanceFixTypeDeserializer {
            context: String,
            state: Box<InstanceFixTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum InstanceFixTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl InstanceFixTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut context: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"context")
                    ) {
                        reader.read_attrib(&mut context, b"context", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    context: context.unwrap_or_else(super::InstanceFixType::default_context),
                    state: Box::new(InstanceFixTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: InstanceFixTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::InstanceFixType> for InstanceFixTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::InstanceFixType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::InstanceFixType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::InstanceFixType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    InstanceFixTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::InstanceFixType {
                    context: self.context,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckImportTypeDeserializer {
            import_name: String,
            import_xpath: Option<String>,
            text_before: Option<Text>,
            any: Option<AnyElement>,
            text_after_any_36: Option<Text>,
            state: Box<CheckImportTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckImportTypeDeserializerState {
            Init__,
            TextBefore(Option<<Text as WithDeserializer>::Deserializer>),
            Any(Option<<AnyElement as WithDeserializer>::Deserializer>),
            TextAfterAny36(Option<<Text as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CheckImportTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut import_name: Option<String> = None;
                let mut import_xpath: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"import-name")
                    ) {
                        reader.read_attrib(&mut import_name, b"import-name", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"import-xpath")
                    ) {
                        reader.read_attrib(&mut import_xpath, b"import-xpath", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    import_name: import_name.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("import-name".into()))
                    })?,
                    import_xpath: import_xpath,
                    text_before: None,
                    any: None,
                    text_after_any_36: None,
                    state: Box::new(CheckImportTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckImportTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use CheckImportTypeDeserializerState as S;
                match state {
                    S::TextBefore(Some(deserializer)) => {
                        self.store_text_before(deserializer.finish(reader)?)?
                    }
                    S::Any(Some(deserializer)) => self.store_any(deserializer.finish(reader)?)?,
                    S::TextAfterAny36(Some(deserializer)) => {
                        self.store_text_after_any_36(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_text_before(&mut self, value: Text) -> Result<(), Error> {
                if self.text_before.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"text_before",
                    )))?;
                }
                self.text_before = Some(value);
                Ok(())
            }
            fn store_any(&mut self, value: AnyElement) -> Result<(), Error> {
                if self.any.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any36",
                    )))?;
                }
                self.any = Some(value);
                Ok(())
            }
            fn store_text_after_any_36(&mut self, value: Text) -> Result<(), Error> {
                if self.text_after_any_36.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"text_after_any36",
                    )))?;
                }
                self.text_after_any_36 = Some(value);
                Ok(())
            }
            fn handle_text_before<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<CheckImportTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckImportTypeDeserializerState::TextBefore(None));
                    *self.state = CheckImportTypeDeserializerState::Any(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_text_before(data)?;
                        *self.state = CheckImportTypeDeserializerState::Any(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    CheckImportTypeDeserializerState::TextBefore(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = CheckImportTypeDeserializerState::Any(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = CheckImportTypeDeserializerState::TextBefore(Some(
                                    deserializer,
                                ));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<CheckImportTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckImportTypeDeserializerState::Any(None));
                    *self.state = CheckImportTypeDeserializerState::TextAfterAny36(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_any(data)?;
                        *self.state = CheckImportTypeDeserializerState::TextAfterAny36(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(CheckImportTypeDeserializerState::Any(
                                    Some(deserializer),
                                ));
                                *self.state =
                                    CheckImportTypeDeserializerState::TextAfterAny36(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckImportTypeDeserializerState::Any(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_text_after_any_36<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<CheckImportTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(CheckImportTypeDeserializerState::TextAfterAny36(None));
                    *self.state = CheckImportTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_text_after_any_36(data)?;
                        *self.state = CheckImportTypeDeserializerState::Done__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    CheckImportTypeDeserializerState::TextAfterAny36(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = CheckImportTypeDeserializerState::Done__;
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = CheckImportTypeDeserializerState::TextAfterAny36(
                                    Some(deserializer),
                                );
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::CheckImportType> for CheckImportTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckImportType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckImportType>
            where
                R: DeserializeReader,
            {
                use CheckImportTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let mut is_any_retry = false;
                let mut any_fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::TextBefore(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::TextAfterAny36(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text_after_any_36(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = CheckImportTypeDeserializerState::TextBefore(None);
                            event
                        }
                        (S::TextBefore(None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text_before(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Any(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            if is_any_retry {
                                let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                    reader, event,
                                )?;
                                match self.handle_any(reader, output, &mut fallback)? {
                                    ElementHandlerOutput::Continue { event, allow_any } => {
                                        allow_any_element = allow_any_element || allow_any;
                                        event
                                    }
                                    ElementHandlerOutput::Break { event, allow_any } => {
                                        break (event, allow_any)
                                    }
                                }
                            } else {
                                any_fallback.get_or_insert(S::Any(None));
                                *self.state = S::TextAfterAny36(None);
                                event
                            }
                        }
                        (S::TextAfterAny36(None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text_after_any_36(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            if let Some(state) = any_fallback.take() {
                                is_any_retry = true;
                                *self.state = state;
                                event
                            } else {
                                fallback.get_or_insert(S::Done__);
                                break (DeserializerEvent::Continue(event), allow_any_element);
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckImportType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    CheckImportTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::CheckImportType {
                    import_name: self.import_name,
                    import_xpath: self.import_xpath,
                    text_before: self.text_before,
                    any: self.any,
                    text_after_any_36: self.text_after_any_36,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckExportTypeDeserializer {
            value_id: String,
            export_name: String,
            state: Box<CheckExportTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckExportTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CheckExportTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut value_id: Option<String> = None;
                let mut export_name: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"value-id")
                    ) {
                        reader.read_attrib(&mut value_id, b"value-id", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"export-name")
                    ) {
                        reader.read_attrib(&mut export_name, b"export-name", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    value_id: value_id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("value-id".into()))
                    })?,
                    export_name: export_name.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("export-name".into()))
                    })?,
                    state: Box::new(CheckExportTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckExportTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CheckExportType> for CheckExportTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckExportType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckExportType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckExportType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    CheckExportTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::CheckExportType {
                    value_id: self.value_id,
                    export_name: self.export_name,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckContentRefTypeDeserializer {
            href: String,
            name: Option<String>,
            state: Box<CheckContentRefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckContentRefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CheckContentRefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut href: Option<String> = None;
                let mut name: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"name")
                    ) {
                        reader.read_attrib(&mut name, b"name", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    href: href.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("href".into()))
                    })?,
                    name: name,
                    state: Box::new(CheckContentRefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckContentRefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CheckContentRefType> for CheckContentRefTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentRefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentRefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckContentRefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    CheckContentRefTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::CheckContentRefType {
                    href: self.href,
                    name: self.name,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckContentTypeDeserializer {
            content: Vec<super::CheckContentTypeContent>,
            state: Box<CheckContentTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckContentTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CheckContentTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CheckContentTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    content: Vec::new(),
                    state: Box::new(CheckContentTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckContentTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let CheckContentTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CheckContentTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckContentTypeContent>,
                fallback: &mut Option<CheckContentTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = fallback
                        .take()
                        .unwrap_or(CheckContentTypeDeserializerState::Next__);
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state = CheckContentTypeDeserializerState::Next__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    CheckContentTypeDeserializerState::Content__(deserializer);
                            }
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    CheckContentTypeDeserializerState::Content__(deserializer),
                                );
                                *self.state = CheckContentTypeDeserializerState::Next__;
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::CheckContentType> for CheckContentTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentType>
            where
                R: DeserializeReader,
            {
                use CheckContentTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: CheckContentTypeContent as WithDeserializer > :: Deserializer :: init (reader , event) ? ;
                            match self.handle_content(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckContentType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    CheckContentTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::CheckContentType {
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckContentTypeContentDeserializer {
            state: Box<CheckContentTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CheckContentTypeContentDeserializerState {
            Init__,
            Any(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<Text>,
                Option<<Text as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CheckContentTypeContent),
            Unknown__,
        }
        impl CheckContentTypeContentDeserializer {
            fn find_suitable<'de, R>(
                &mut self,
                reader: &R,
                event: Event<'de>,
                fallback: &mut Option<CheckContentTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let mut event = event;
                if let Event::Start(_) | Event::Empty(_) = &event {
                    event = {
                        let output =
                            <AnyElement as WithDeserializer>::Deserializer::init(reader, event)?;
                        match self.handle_any(reader, Default::default(), output, &mut *fallback)? {
                            ElementHandlerOutput::Continue { event, .. } => event,
                            output => {
                                return Ok(output);
                            }
                        }
                    };
                }
                let output = <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                self.handle_text(reader, Default::default(), output, &mut *fallback)
            }
            fn finish_state<R>(
                reader: &R,
                state: CheckContentTypeContentDeserializerState,
            ) -> Result<super::CheckContentTypeContent, Error>
            where
                R: DeserializeReader,
            {
                use CheckContentTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Any(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_any(&mut values, value)?;
                        }
                        Ok(super::CheckContentTypeContent::Any(values.ok_or_else(
                            || ErrorKind::MissingElement("any38".into()),
                        )?))
                    }
                    S::Text(mut values, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(reader)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::CheckContentTypeContent::Text(
                            values.ok_or_else(|| ErrorKind::MissingElement("text".into()))?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    S::Unknown__ => unreachable!(),
                }
            }
            fn store_any(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"any38",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(values: &mut Option<Text>, value: Text) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_any<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<AnyElement>,
                output: DeserializerOutput<'de, AnyElement>,
                fallback: &mut Option<CheckContentTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = CheckContentTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => CheckContentTypeContentDeserializerState::Any(values, None),
                        Some(CheckContentTypeContentDeserializerState::Any(
                            _,
                            Some(deserializer),
                        )) => CheckContentTypeContentDeserializerState::Any(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(CheckContentTypeContentDeserializerState::Any(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_any(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_any(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            CheckContentTypeContentDeserializerState::Any(values, None),
                        )?;
                        *self.state = CheckContentTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = CheckContentTypeContentDeserializerState::Any(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
            fn handle_text<'de, R>(
                &mut self,
                reader: &R,
                mut values: Option<Text>,
                output: DeserializerOutput<'de, Text>,
                fallback: &mut Option<CheckContentTypeContentDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state = match fallback.take() {
                        None if values.is_none() => {
                            *self.state = CheckContentTypeContentDeserializerState::Init__;
                            return Ok(ElementHandlerOutput::from_event(event, allow_any));
                        }
                        None => CheckContentTypeContentDeserializerState::Text(values, None),
                        Some(CheckContentTypeContentDeserializerState::Text(
                            _,
                            Some(deserializer),
                        )) => CheckContentTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        ),
                        _ => unreachable!(),
                    };
                    return Ok(ElementHandlerOutput::break_(event, allow_any));
                }
                match fallback.take() {
                    None => (),
                    Some(CheckContentTypeContentDeserializerState::Text(_, Some(deserializer))) => {
                        let data = deserializer.finish(reader)?;
                        Self::store_text(&mut values, data)?;
                    }
                    Some(_) => unreachable!(),
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(
                            reader,
                            CheckContentTypeContentDeserializerState::Text(values, None),
                        )?;
                        *self.state = CheckContentTypeContentDeserializerState::Done__(data);
                        ElementHandlerOutput::Break { event, allow_any }
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = CheckContentTypeContentDeserializerState::Text(
                            values,
                            Some(deserializer),
                        );
                        ElementHandlerOutput::from_event_end(event, allow_any)
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::CheckContentTypeContent>
            for CheckContentTypeContentDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentTypeContent>
            where
                R: DeserializeReader,
            {
                let deserializer = Self {
                    state: Box::new(CheckContentTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(reader, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state,
                            CheckContentTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckContentTypeContent>
            where
                R: DeserializeReader,
            {
                use CheckContentTypeContentDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Any(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    reader, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            match self.find_suitable(reader, event, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Any(values, None), event) => {
                            let output = <AnyElement as WithDeserializer>::Deserializer::init(
                                reader, event,
                            )?;
                            match self.handle_any(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, None), event) => {
                            let output =
                                <Text as WithDeserializer>::Deserializer::init(reader, event)?;
                            match self.handle_text(reader, values, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (s @ S::Done__(_), event) => {
                            *self.state = s;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (S::Unknown__, _) => unreachable!(),
                    }
                };
                let artifact = if matches!(&*self.state, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(reader)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish<R>(self, reader: &R) -> Result<super::CheckContentTypeContent, Error>
            where
                R: DeserializeReader,
            {
                Self::finish_state(reader, *self.state)
            }
        }
        #[derive(Debug)]
        pub struct FactTypeDeserializer {
            name: String,
            type_: super::ValueTypeType,
            content: Option<String>,
            state: Box<FactTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum FactTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl FactTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut name: Option<String> = None;
                let mut type_: Option<super::ValueTypeType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"name")
                    ) {
                        reader.read_attrib(&mut name, b"name", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"type")
                    ) {
                        reader.read_attrib(&mut type_, b"type", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("name".into()))
                    })?,
                    type_: type_.unwrap_or_else(super::FactType::default_type_),
                    content: None,
                    state: Box::new(FactTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: FactTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let FactTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::FactType>
            where
                R: DeserializeReader,
            {
                use FactTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::FactType> for FactTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::FactType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::FactType>
            where
                R: DeserializeReader,
            {
                use FactTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::FactType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, FactTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::FactType {
                    name: self.name,
                    type_: self.type_,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct OverrideTypeDeserializer {
            time: String,
            authority: String,
            old_result: Option<super::ResultEnumType>,
            new_result: Option<super::ResultEnumType>,
            remark: Option<super::TextType>,
            state: Box<OverrideTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OverrideTypeDeserializerState {
            Init__,
            OldResult(Option<<super::ResultEnumType as WithDeserializer>::Deserializer>),
            NewResult(Option<<super::ResultEnumType as WithDeserializer>::Deserializer>),
            Remark(Option<<super::TextType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl OverrideTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut time: Option<String> = None;
                let mut authority: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"time")
                    ) {
                        reader.read_attrib(&mut time, b"time", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"authority")
                    ) {
                        reader.read_attrib(&mut authority, b"authority", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    time: time.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("time".into()))
                    })?,
                    authority: authority.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("authority".into()))
                    })?,
                    old_result: None,
                    new_result: None,
                    remark: None,
                    state: Box::new(OverrideTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: OverrideTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use OverrideTypeDeserializerState as S;
                match state {
                    S::OldResult(Some(deserializer)) => {
                        self.store_old_result(deserializer.finish(reader)?)?
                    }
                    S::NewResult(Some(deserializer)) => {
                        self.store_new_result(deserializer.finish(reader)?)?
                    }
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_old_result(&mut self, value: super::ResultEnumType) -> Result<(), Error> {
                if self.old_result.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"old-result",
                    )))?;
                }
                self.old_result = Some(value);
                Ok(())
            }
            fn store_new_result(&mut self, value: super::ResultEnumType) -> Result<(), Error> {
                if self.new_result.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"new-result",
                    )))?;
                }
                self.new_result = Some(value);
                Ok(())
            }
            fn store_remark(&mut self, value: super::TextType) -> Result<(), Error> {
                if self.remark.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"remark",
                    )))?;
                }
                self.remark = Some(value);
                Ok(())
            }
            fn handle_old_result<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ResultEnumType>,
                fallback: &mut Option<OverrideTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.old_result.is_some() {
                        fallback.get_or_insert(OverrideTypeDeserializerState::OldResult(None));
                        *self.state = OverrideTypeDeserializerState::NewResult(None);
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    } else {
                        *self.state = OverrideTypeDeserializerState::OldResult(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_old_result(data)?;
                        *self.state = OverrideTypeDeserializerState::NewResult(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(OverrideTypeDeserializerState::OldResult(
                                    Some(deserializer),
                                ));
                                *self.state = OverrideTypeDeserializerState::NewResult(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    OverrideTypeDeserializerState::OldResult(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_new_result<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::ResultEnumType>,
                fallback: &mut Option<OverrideTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.new_result.is_some() {
                        fallback.get_or_insert(OverrideTypeDeserializerState::NewResult(None));
                        *self.state = OverrideTypeDeserializerState::Remark(None);
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    } else {
                        *self.state = OverrideTypeDeserializerState::NewResult(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_new_result(data)?;
                        *self.state = OverrideTypeDeserializerState::Remark(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(OverrideTypeDeserializerState::NewResult(
                                    Some(deserializer),
                                ));
                                *self.state = OverrideTypeDeserializerState::Remark(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    OverrideTypeDeserializerState::NewResult(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<OverrideTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.remark.is_some() {
                        fallback.get_or_insert(OverrideTypeDeserializerState::Remark(None));
                        *self.state = OverrideTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    } else {
                        *self.state = OverrideTypeDeserializerState::Remark(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state = OverrideTypeDeserializerState::Done__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(OverrideTypeDeserializerState::Remark(
                                    Some(deserializer),
                                ));
                                *self.state = OverrideTypeDeserializerState::Done__;
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    OverrideTypeDeserializerState::Remark(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::OverrideType> for OverrideTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OverrideType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OverrideType>
            where
                R: DeserializeReader,
            {
                use OverrideTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::OldResult(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_old_result(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::NewResult(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_new_result(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = OverrideTypeDeserializerState::OldResult(None);
                            event
                        }
                        (S::OldResult(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"old-result",
                                false,
                            )?;
                            match self.handle_old_result(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::NewResult(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"new-result",
                                false,
                            )?;
                            match self.handle_new_result(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CDF),
                                b"remark",
                                false,
                            )?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::OverrideType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, OverrideTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::OverrideType {
                    time: self.time,
                    authority: self.authority,
                    old_result: self
                        .old_result
                        .ok_or_else(|| ErrorKind::MissingElement("old-result".into()))?,
                    new_result: self
                        .new_result
                        .ok_or_else(|| ErrorKind::MissingElement("new-result".into()))?,
                    remark: self
                        .remark
                        .ok_or_else(|| ErrorKind::MissingElement("remark".into()))?,
                })
            }
        }
        #[derive(Debug)]
        pub struct MessageTypeDeserializer {
            severity: super::MsgSevEnumType,
            content: Option<String>,
            state: Box<MessageTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum MessageTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl MessageTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut severity: Option<super::MsgSevEnumType> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"severity")
                    ) {
                        reader.read_attrib(&mut severity, b"severity", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    severity: severity.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("severity".into()))
                    })?,
                    content: None,
                    state: Box::new(MessageTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: MessageTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let MessageTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::MessageType>
            where
                R: DeserializeReader,
            {
                use MessageTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::MessageType> for MessageTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::MessageType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::MessageType>
            where
                R: DeserializeReader,
            {
                use MessageTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::MessageType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, MessageTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::MessageType {
                    severity: self.severity,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct InstanceResultTypeDeserializer {
            context: String,
            parent_context: Option<String>,
            content: Option<String>,
            state: Box<InstanceResultTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum InstanceResultTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl InstanceResultTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut context: Option<String> = None;
                let mut parent_context: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"context")
                    ) {
                        reader.read_attrib(&mut context, b"context", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CDF),
                        Some(b"parentContext")
                    ) {
                        reader.read_attrib(&mut parent_context, b"parentContext", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    context: context.unwrap_or_else(super::InstanceResultType::default_context),
                    parent_context: parent_context,
                    content: None,
                    state: Box::new(InstanceResultTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: InstanceResultTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let InstanceResultTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::InstanceResultType>
            where
                R: DeserializeReader,
            {
                use InstanceResultTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::InstanceResultType> for InstanceResultTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::InstanceResultType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::InstanceResultType>
            where
                R: DeserializeReader,
            {
                use InstanceResultTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::InstanceResultType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    InstanceResultTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::InstanceResultType {
                    context: self.context,
                    parent_context: self.parent_context,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use core::iter::Iterator;
        use xsd_parser::{
            quick_xml::{
                write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
                WithSerializer,
            },
            xml::{AnyElement, Mixed, Text},
        };
        #[derive(Debug)]
        pub struct BenchmarkElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::BenchmarkElementType,
            pub(super) state: Box<BenchmarkElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum BenchmarkElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::BenchmarkElementTypeContent],
                    super::BenchmarkElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> BenchmarkElementTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        BenchmarkElementTypeSerializerState::Init__ => {
                            *self.state = BenchmarkElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            write_attrib(&mut bytes, "resolved", &self.value.resolved)?;
                            write_attrib_opt(&mut bytes, "style", &self.value.style)?;
                            write_attrib_opt(&mut bytes, "style-href", &self.value.style_href)?;
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        BenchmarkElementTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = BenchmarkElementTypeSerializerState::End__,
                            }
                        }
                        BenchmarkElementTypeSerializerState::End__ => {
                            *self.state = BenchmarkElementTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        BenchmarkElementTypeSerializerState::Done__ => return Ok(None),
                        BenchmarkElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for BenchmarkElementTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = BenchmarkElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct BenchmarkElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::BenchmarkElementTypeContent,
            pub(super) state: Box<BenchmarkElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum BenchmarkElementTypeContentSerializerState<'ser> {
            Init__,
            Status(<super::StatusElementType as WithSerializer>::Serializer<'ser>),
            DcStatus(<super::DcStatusType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextType as WithSerializer>::Serializer<'ser>),
            Description(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Notice(<super::NoticeType as WithSerializer>::Serializer<'ser>),
            FrontMatter(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            RearMatter(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Reference(<super::ReferenceType as WithSerializer>::Serializer<'ser>),
            PlainText(<super::PlainTextType as WithSerializer>::Serializer<'ser>),
            PlatformSpecification(
                <super::super::cpe::PlatformSpecificationType as WithSerializer>::Serializer<'ser>,
            ),
            Platform(<super::Cpe2IdrefType as WithSerializer>::Serializer<'ser>),
            Version(<super::VersionType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Model(<super::ModelElementType as WithSerializer>::Serializer<'ser>),
            Profile(<super::ProfileType as WithSerializer>::Serializer<'ser>),
            Value(<super::ValueType as WithSerializer>::Serializer<'ser>),
            Group(<super::GroupType as WithSerializer>::Serializer<'ser>),
            Rule(<super::RuleType as WithSerializer>::Serializer<'ser>),
            TestResult(<super::TestResultType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> BenchmarkElementTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        BenchmarkElementTypeContentSerializerState::Init__ => match self.value {
                            super::BenchmarkElementTypeContent::Status(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Status(
                                    WithSerializer::serializer(x, Some("cdf:status"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::DcStatus(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::DcStatus(
                                    WithSerializer::serializer(x, Some("cdf:dc-status"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Title(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Description(x) => {
                                *self.state =
                                    BenchmarkElementTypeContentSerializerState::Description(
                                        WithSerializer::serializer(
                                            x,
                                            Some("cdf:description"),
                                            false,
                                        )?,
                                    )
                            }
                            super::BenchmarkElementTypeContent::Notice(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Notice(
                                    WithSerializer::serializer(x, Some("cdf:notice"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::FrontMatter(x) => {
                                *self.state =
                                    BenchmarkElementTypeContentSerializerState::FrontMatter(
                                        WithSerializer::serializer(
                                            x,
                                            Some("cdf:front-matter"),
                                            false,
                                        )?,
                                    )
                            }
                            super::BenchmarkElementTypeContent::RearMatter(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::RearMatter(
                                    WithSerializer::serializer(x, Some("cdf:rear-matter"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Reference(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Reference(
                                    WithSerializer::serializer(x, Some("cdf:reference"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::PlainText(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::PlainText(
                                    WithSerializer::serializer(x, Some("cdf:plain-text"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::PlatformSpecification(x) => *self
                                .state =
                                BenchmarkElementTypeContentSerializerState::PlatformSpecification(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cpe:platform-specification"),
                                        false,
                                    )?,
                                ),
                            super::BenchmarkElementTypeContent::Platform(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Platform(
                                    WithSerializer::serializer(x, Some("cdf:platform"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Version(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Version(
                                    WithSerializer::serializer(x, Some("cdf:version"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Metadata(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Model(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Model(
                                    WithSerializer::serializer(x, Some("cdf:model"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Profile(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Profile(
                                    WithSerializer::serializer(x, Some("cdf:Profile"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Value(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Value(
                                    WithSerializer::serializer(x, Some("cdf:Value"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Group(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Group(
                                    WithSerializer::serializer(x, Some("cdf:Group"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Rule(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Rule(
                                    WithSerializer::serializer(x, Some("cdf:Rule"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::TestResult(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::TestResult(
                                    WithSerializer::serializer(x, Some("cdf:TestResult"), false)?,
                                )
                            }
                            super::BenchmarkElementTypeContent::Signature(x) => {
                                *self.state = BenchmarkElementTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        BenchmarkElementTypeContentSerializerState::Status(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::DcStatus(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Title(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Description(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Notice(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::FrontMatter(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::RearMatter(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Reference(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::PlainText(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::PlatformSpecification(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Platform(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Version(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Model(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Profile(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Value(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Group(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Rule(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::TestResult(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = BenchmarkElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        BenchmarkElementTypeContentSerializerState::Done__ => return Ok(None),
                        BenchmarkElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for BenchmarkElementTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = BenchmarkElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct StatusElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::StatusElementType,
            pub(super) state: Box<StatusElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum StatusElementTypeSerializerState<'ser> {
            Init__,
            Content__(<super::StatusType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> StatusElementTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        StatusElementTypeSerializerState::Init__ => {
                            *self.state = StatusElementTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "date", &self.value.date)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        StatusElementTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = StatusElementTypeSerializerState::End__,
                            }
                        }
                        StatusElementTypeSerializerState::End__ => {
                            *self.state = StatusElementTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        StatusElementTypeSerializerState::Done__ => return Ok(None),
                        StatusElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for StatusElementTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = StatusElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DcStatusTypeSerializer<'ser> {
            pub(super) value: &'ser super::DcStatusType,
            pub(super) state: Box<DcStatusTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DcStatusTypeSerializerState<'ser> {
            Init__,
            Any(IterSerializer<'ser, &'ser [AnyElement], AnyElement>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DcStatusTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DcStatusTypeSerializerState::Init__ => {
                            *self.state = DcStatusTypeSerializerState::Any(IterSerializer::new(
                                &self.value.any[..],
                                Some("any6"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DcStatusTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DcStatusTypeSerializerState::End__,
                        },
                        DcStatusTypeSerializerState::End__ => {
                            *self.state = DcStatusTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DcStatusTypeSerializerState::Done__ => return Ok(None),
                        DcStatusTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for DcStatusTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DcStatusTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TextTypeSerializer<'ser> {
            pub(super) value: &'ser super::TextType,
            pub(super) state: Box<TextTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TextTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TextTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TextTypeSerializerState::Init__ => {
                            *self.state = TextTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        TextTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TextTypeSerializerState::End__,
                        },
                        TextTypeSerializerState::End__ => {
                            *self.state = TextTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        TextTypeSerializerState::Done__ => return Ok(None),
                        TextTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TextTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TextTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct HtmlTextWithSubTypeSerializer<'ser> {
            pub(super) value: &'ser super::HtmlTextWithSubType,
            pub(super) state: Box<HtmlTextWithSubTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum HtmlTextWithSubTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::HtmlTextWithSubTypeContent],
                    super::HtmlTextWithSubTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> HtmlTextWithSubTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        HtmlTextWithSubTypeSerializerState::Init__ => {
                            *self.state = HtmlTextWithSubTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        HtmlTextWithSubTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = HtmlTextWithSubTypeSerializerState::End__,
                            }
                        }
                        HtmlTextWithSubTypeSerializerState::End__ => {
                            *self.state = HtmlTextWithSubTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        HtmlTextWithSubTypeSerializerState::Done__ => return Ok(None),
                        HtmlTextWithSubTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for HtmlTextWithSubTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = HtmlTextWithSubTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct HtmlTextWithSubTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::HtmlTextWithSubTypeContent,
            pub(super) state: Box<HtmlTextWithSubTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum HtmlTextWithSubTypeContentSerializerState<'ser> {
            Init__,
            Sub(<super::SubType as WithSerializer>::Serializer<'ser>),
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> HtmlTextWithSubTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        HtmlTextWithSubTypeContentSerializerState::Init__ => match self.value {
                            super::HtmlTextWithSubTypeContent::Sub(x) => {
                                *self.state = HtmlTextWithSubTypeContentSerializerState::Sub(
                                    WithSerializer::serializer(x, Some("cdf:sub"), false)?,
                                )
                            }
                            super::HtmlTextWithSubTypeContent::Any(x) => {
                                *self.state = HtmlTextWithSubTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any17"), false)?,
                                )
                            }
                            super::HtmlTextWithSubTypeContent::Text(x) => {
                                *self.state = HtmlTextWithSubTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        HtmlTextWithSubTypeContentSerializerState::Sub(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = HtmlTextWithSubTypeContentSerializerState::Done__
                                }
                            }
                        }
                        HtmlTextWithSubTypeContentSerializerState::Any(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = HtmlTextWithSubTypeContentSerializerState::Done__
                                }
                            }
                        }
                        HtmlTextWithSubTypeContentSerializerState::Text(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = HtmlTextWithSubTypeContentSerializerState::Done__
                                }
                            }
                        }
                        HtmlTextWithSubTypeContentSerializerState::Done__ => return Ok(None),
                        HtmlTextWithSubTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for HtmlTextWithSubTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = HtmlTextWithSubTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct NoticeTypeSerializer<'ser> {
            pub(super) value: &'ser super::NoticeType,
            pub(super) state: Box<NoticeTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum NoticeTypeSerializerState<'ser> {
            Init__,
            TextBefore(IterSerializer<'ser, Option<&'ser Text>, Text>),
            Any(IterSerializer<'ser, &'ser [Mixed<AnyElement>], Mixed<AnyElement>>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> NoticeTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        NoticeTypeSerializerState::Init__ => {
                            *self.state =
                                NoticeTypeSerializerState::TextBefore(IterSerializer::new(
                                    self.value.text_before.as_ref(),
                                    Some(""),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "id", &self.value.id)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        NoticeTypeSerializerState::TextBefore(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = NoticeTypeSerializerState::Any(IterSerializer::new(
                                    &self.value.any[..],
                                    Some("any4"),
                                    false,
                                ))
                            }
                        },
                        NoticeTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = NoticeTypeSerializerState::End__,
                        },
                        NoticeTypeSerializerState::End__ => {
                            *self.state = NoticeTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        NoticeTypeSerializerState::Done__ => return Ok(None),
                        NoticeTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for NoticeTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = NoticeTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ReferenceTypeSerializer<'ser> {
            pub(super) value: &'ser super::ReferenceType,
            pub(super) state: Box<ReferenceTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ReferenceTypeSerializerState<'ser> {
            Init__,
            TextBefore(IterSerializer<'ser, Option<&'ser Text>, Text>),
            Any(IterSerializer<'ser, &'ser [Mixed<AnyElement>], Mixed<AnyElement>>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ReferenceTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ReferenceTypeSerializerState::Init__ => {
                            *self.state =
                                ReferenceTypeSerializerState::TextBefore(IterSerializer::new(
                                    self.value.text_before.as_ref(),
                                    Some(""),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "href", &self.value.href)?;
                            write_attrib_opt(&mut bytes, "override", &self.value.override_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ReferenceTypeSerializerState::TextBefore(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        ReferenceTypeSerializerState::Any(IterSerializer::new(
                                            &self.value.any[..],
                                            Some("any8"),
                                            false,
                                        ))
                                }
                            }
                        }
                        ReferenceTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ReferenceTypeSerializerState::End__,
                        },
                        ReferenceTypeSerializerState::End__ => {
                            *self.state = ReferenceTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ReferenceTypeSerializerState::Done__ => return Ok(None),
                        ReferenceTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ReferenceTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ReferenceTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PlainTextTypeSerializer<'ser> {
            pub(super) value: &'ser super::PlainTextType,
            pub(super) state: Box<PlainTextTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PlainTextTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PlainTextTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PlainTextTypeSerializerState::Init__ => {
                            *self.state = PlainTextTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PlainTextTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PlainTextTypeSerializerState::End__,
                        },
                        PlainTextTypeSerializerState::End__ => {
                            *self.state = PlainTextTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PlainTextTypeSerializerState::Done__ => return Ok(None),
                        PlainTextTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for PlainTextTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PlainTextTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct Cpe2IdrefTypeSerializer<'ser> {
            pub(super) value: &'ser super::Cpe2IdrefType,
            pub(super) state: Box<Cpe2IdrefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum Cpe2IdrefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> Cpe2IdrefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        Cpe2IdrefTypeSerializerState::Init__ => {
                            *self.state = Cpe2IdrefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        Cpe2IdrefTypeSerializerState::Done__ => return Ok(None),
                        Cpe2IdrefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for Cpe2IdrefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = Cpe2IdrefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct VersionTypeSerializer<'ser> {
            pub(super) value: &'ser super::VersionType,
            pub(super) state: Box<VersionTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum VersionTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> VersionTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        VersionTypeSerializerState::Init__ => {
                            *self.state = VersionTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "time", &self.value.time)?;
                            write_attrib_opt(&mut bytes, "update", &self.value.update)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        VersionTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = VersionTypeSerializerState::End__,
                        },
                        VersionTypeSerializerState::End__ => {
                            *self.state = VersionTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        VersionTypeSerializerState::Done__ => return Ok(None),
                        VersionTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for VersionTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = VersionTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct MetadataTypeSerializer<'ser> {
            pub(super) value: &'ser super::MetadataType,
            pub(super) state: Box<MetadataTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum MetadataTypeSerializerState<'ser> {
            Init__,
            Any(IterSerializer<'ser, &'ser [AnyElement], AnyElement>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> MetadataTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        MetadataTypeSerializerState::Init__ => {
                            *self.state = MetadataTypeSerializerState::Any(IterSerializer::new(
                                &self.value.any[..],
                                Some("any12"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        MetadataTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = MetadataTypeSerializerState::End__,
                        },
                        MetadataTypeSerializerState::End__ => {
                            *self.state = MetadataTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        MetadataTypeSerializerState::Done__ => return Ok(None),
                        MetadataTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for MetadataTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = MetadataTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ModelElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ModelElementType,
            pub(super) state: Box<ModelElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ModelElementTypeSerializerState<'ser> {
            Init__,
            Param(IterSerializer<'ser, &'ser [super::ParamType], super::ParamType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ModelElementTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ModelElementTypeSerializerState::Init__ => {
                            *self.state =
                                ModelElementTypeSerializerState::Param(IterSerializer::new(
                                    &self.value.param[..],
                                    Some("cdf:param"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "system", &self.value.system)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ModelElementTypeSerializerState::Param(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ModelElementTypeSerializerState::End__,
                        },
                        ModelElementTypeSerializerState::End__ => {
                            *self.state = ModelElementTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ModelElementTypeSerializerState::Done__ => return Ok(None),
                        ModelElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ModelElementTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ModelElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileType,
            pub(super) state: Box<ProfileTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::ProfileTypeContent], super::ProfileTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileTypeSerializerState::Init__ => {
                            *self.state = ProfileTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib(
                                &mut bytes,
                                "prohibitChanges",
                                &self.value.prohibit_changes,
                            )?;
                            write_attrib(&mut bytes, "abstract", &self.value.abstract_)?;
                            write_attrib_opt(&mut bytes, "note-tag", &self.value.note_tag)?;
                            write_attrib_opt(&mut bytes, "extends", &self.value.extends)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProfileTypeSerializerState::End__,
                        },
                        ProfileTypeSerializerState::End__ => {
                            *self.state = ProfileTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileTypeSerializerState::Done__ => return Ok(None),
                        ProfileTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::ProfileTypeContent,
            pub(super) state: Box<ProfileTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum ProfileTypeContentSerializerState<'ser> {
            Init__,
            Status(<super::StatusElementType as WithSerializer>::Serializer<'ser>),
            DcStatus(<super::DcStatusType as WithSerializer>::Serializer<'ser>),
            Version(<super::VersionType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextWithSubType as WithSerializer>::Serializer<'ser>),
            Description(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Reference(<super::ReferenceType as WithSerializer>::Serializer<'ser>),
            Platform(<super::OverrideableCpe2IdrefType as WithSerializer>::Serializer<'ser>),
            Select(<super::ProfileSelectType as WithSerializer>::Serializer<'ser>),
            SetComplexValue(
                <super::ProfileSetComplexValueType as WithSerializer>::Serializer<'ser>,
            ),
            SetValue(<super::ProfileSetValueType as WithSerializer>::Serializer<'ser>),
            RefineValue(<super::ProfileRefineValueType as WithSerializer>::Serializer<'ser>),
            RefineRule(<super::ProfileRefineRuleType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileTypeContentSerializerState::Init__ => match self.value {
                            super::ProfileTypeContent::Status(x) => {
                                *self.state = ProfileTypeContentSerializerState::Status(
                                    WithSerializer::serializer(x, Some("cdf:status"), false)?,
                                )
                            }
                            super::ProfileTypeContent::DcStatus(x) => {
                                *self.state = ProfileTypeContentSerializerState::DcStatus(
                                    WithSerializer::serializer(x, Some("cdf:dc-status"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Version(x) => {
                                *self.state = ProfileTypeContentSerializerState::Version(
                                    WithSerializer::serializer(x, Some("cdf:version"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Title(x) => {
                                *self.state = ProfileTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Description(x) => {
                                *self.state = ProfileTypeContentSerializerState::Description(
                                    WithSerializer::serializer(x, Some("cdf:description"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Reference(x) => {
                                *self.state = ProfileTypeContentSerializerState::Reference(
                                    WithSerializer::serializer(x, Some("cdf:reference"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Platform(x) => {
                                *self.state = ProfileTypeContentSerializerState::Platform(
                                    WithSerializer::serializer(x, Some("cdf:platform"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Select(x) => {
                                *self.state = ProfileTypeContentSerializerState::Select(
                                    WithSerializer::serializer(x, Some("cdf:select"), false)?,
                                )
                            }
                            super::ProfileTypeContent::SetComplexValue(x) => {
                                *self.state = ProfileTypeContentSerializerState::SetComplexValue(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:set-complex-value"),
                                        false,
                                    )?,
                                )
                            }
                            super::ProfileTypeContent::SetValue(x) => {
                                *self.state = ProfileTypeContentSerializerState::SetValue(
                                    WithSerializer::serializer(x, Some("cdf:set-value"), false)?,
                                )
                            }
                            super::ProfileTypeContent::RefineValue(x) => {
                                *self.state = ProfileTypeContentSerializerState::RefineValue(
                                    WithSerializer::serializer(x, Some("cdf:refine-value"), false)?,
                                )
                            }
                            super::ProfileTypeContent::RefineRule(x) => {
                                *self.state = ProfileTypeContentSerializerState::RefineRule(
                                    WithSerializer::serializer(x, Some("cdf:refine-rule"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Metadata(x) => {
                                *self.state = ProfileTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::ProfileTypeContent::Signature(x) => {
                                *self.state = ProfileTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        ProfileTypeContentSerializerState::Status(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::DcStatus(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Version(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Title(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Description(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Reference(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Platform(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Select(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::SetComplexValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::SetValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::RefineValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::RefineRule(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileTypeContentSerializerState::Done__ => return Ok(None),
                        ProfileTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::ValueType,
            pub(super) state: Box<ValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ValueTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::ValueTypeContent], super::ValueTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ValueTypeSerializerState::Init__ => {
                            *self.state = ValueTypeSerializerState::Content__(IterSerializer::new(
                                &self.value.content[..],
                                None,
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "abstract", &self.value.abstract_)?;
                            write_attrib_opt(&mut bytes, "cluster-id", &self.value.cluster_id)?;
                            write_attrib_opt(&mut bytes, "extends", &self.value.extends)?;
                            write_attrib(&mut bytes, "hidden", &self.value.hidden)?;
                            write_attrib(
                                &mut bytes,
                                "prohibitChanges",
                                &self.value.prohibit_changes,
                            )?;
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib(&mut bytes, "type", &self.value.type_)?;
                            write_attrib(&mut bytes, "operator", &self.value.operator)?;
                            write_attrib(&mut bytes, "interactive", &self.value.interactive)?;
                            write_attrib_opt(
                                &mut bytes,
                                "interfaceHint",
                                &self.value.interface_hint,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ValueTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ValueTypeSerializerState::End__,
                        },
                        ValueTypeSerializerState::End__ => {
                            *self.state = ValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ValueTypeSerializerState::Done__ => return Ok(None),
                        ValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ValueTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::ValueTypeContent,
            pub(super) state: Box<ValueTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum ValueTypeContentSerializerState<'ser> {
            Init__,
            Status(<super::StatusElementType as WithSerializer>::Serializer<'ser>),
            DcStatus(<super::DcStatusType as WithSerializer>::Serializer<'ser>),
            Version(<super::VersionType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextWithSubType as WithSerializer>::Serializer<'ser>),
            Description(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Warning(<super::WarningType as WithSerializer>::Serializer<'ser>),
            Question(<super::TextType as WithSerializer>::Serializer<'ser>),
            Reference(<super::ReferenceType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Value(<super::SelStringType as WithSerializer>::Serializer<'ser>),
            ComplexValue(<super::SelComplexValueType as WithSerializer>::Serializer<'ser>),
            Default(<super::SelStringType as WithSerializer>::Serializer<'ser>),
            ComplexDefault(<super::SelComplexValueType as WithSerializer>::Serializer<'ser>),
            Match(<super::SelStringType as WithSerializer>::Serializer<'ser>),
            LowerBound(<super::SelNumType as WithSerializer>::Serializer<'ser>),
            UpperBound(<super::SelNumType as WithSerializer>::Serializer<'ser>),
            Choices(<super::SelChoicesType as WithSerializer>::Serializer<'ser>),
            Source(<super::UriRefType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ValueTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ValueTypeContentSerializerState::Init__ => match self.value {
                            super::ValueTypeContent::Status(x) => {
                                *self.state = ValueTypeContentSerializerState::Status(
                                    WithSerializer::serializer(x, Some("cdf:status"), false)?,
                                )
                            }
                            super::ValueTypeContent::DcStatus(x) => {
                                *self.state = ValueTypeContentSerializerState::DcStatus(
                                    WithSerializer::serializer(x, Some("cdf:dc-status"), false)?,
                                )
                            }
                            super::ValueTypeContent::Version(x) => {
                                *self.state = ValueTypeContentSerializerState::Version(
                                    WithSerializer::serializer(x, Some("cdf:version"), false)?,
                                )
                            }
                            super::ValueTypeContent::Title(x) => {
                                *self.state = ValueTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::ValueTypeContent::Description(x) => {
                                *self.state = ValueTypeContentSerializerState::Description(
                                    WithSerializer::serializer(x, Some("cdf:description"), false)?,
                                )
                            }
                            super::ValueTypeContent::Warning(x) => {
                                *self.state = ValueTypeContentSerializerState::Warning(
                                    WithSerializer::serializer(x, Some("cdf:warning"), false)?,
                                )
                            }
                            super::ValueTypeContent::Question(x) => {
                                *self.state = ValueTypeContentSerializerState::Question(
                                    WithSerializer::serializer(x, Some("cdf:question"), false)?,
                                )
                            }
                            super::ValueTypeContent::Reference(x) => {
                                *self.state = ValueTypeContentSerializerState::Reference(
                                    WithSerializer::serializer(x, Some("cdf:reference"), false)?,
                                )
                            }
                            super::ValueTypeContent::Metadata(x) => {
                                *self.state = ValueTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::ValueTypeContent::Value(x) => {
                                *self.state = ValueTypeContentSerializerState::Value(
                                    WithSerializer::serializer(x, Some("cdf:value"), false)?,
                                )
                            }
                            super::ValueTypeContent::ComplexValue(x) => {
                                *self.state = ValueTypeContentSerializerState::ComplexValue(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-value"),
                                        false,
                                    )?,
                                )
                            }
                            super::ValueTypeContent::Default(x) => {
                                *self.state = ValueTypeContentSerializerState::Default(
                                    WithSerializer::serializer(x, Some("cdf:default"), false)?,
                                )
                            }
                            super::ValueTypeContent::ComplexDefault(x) => {
                                *self.state = ValueTypeContentSerializerState::ComplexDefault(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-default"),
                                        false,
                                    )?,
                                )
                            }
                            super::ValueTypeContent::Match(x) => {
                                *self.state = ValueTypeContentSerializerState::Match(
                                    WithSerializer::serializer(x, Some("cdf:match"), false)?,
                                )
                            }
                            super::ValueTypeContent::LowerBound(x) => {
                                *self.state = ValueTypeContentSerializerState::LowerBound(
                                    WithSerializer::serializer(x, Some("cdf:lower-bound"), false)?,
                                )
                            }
                            super::ValueTypeContent::UpperBound(x) => {
                                *self.state = ValueTypeContentSerializerState::UpperBound(
                                    WithSerializer::serializer(x, Some("cdf:upper-bound"), false)?,
                                )
                            }
                            super::ValueTypeContent::Choices(x) => {
                                *self.state = ValueTypeContentSerializerState::Choices(
                                    WithSerializer::serializer(x, Some("cdf:choices"), false)?,
                                )
                            }
                            super::ValueTypeContent::Source(x) => {
                                *self.state = ValueTypeContentSerializerState::Source(
                                    WithSerializer::serializer(x, Some("cdf:source"), false)?,
                                )
                            }
                            super::ValueTypeContent::Signature(x) => {
                                *self.state = ValueTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        ValueTypeContentSerializerState::Status(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::DcStatus(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Version(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Title(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ValueTypeContentSerializerState::Done__,
                        },
                        ValueTypeContentSerializerState::Description(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Warning(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Question(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Reference(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Value(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ValueTypeContentSerializerState::Done__,
                        },
                        ValueTypeContentSerializerState::ComplexValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Default(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::ComplexDefault(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Match(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ValueTypeContentSerializerState::Done__,
                        },
                        ValueTypeContentSerializerState::LowerBound(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::UpperBound(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Choices(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Source(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ValueTypeContentSerializerState::Done__,
                            }
                        }
                        ValueTypeContentSerializerState::Done__ => return Ok(None),
                        ValueTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ValueTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ValueTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct GroupTypeSerializer<'ser> {
            pub(super) value: &'ser super::GroupType,
            pub(super) state: Box<GroupTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum GroupTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::GroupTypeContent], super::GroupTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> GroupTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        GroupTypeSerializerState::Init__ => {
                            *self.state = GroupTypeSerializerState::Content__(IterSerializer::new(
                                &self.value.content[..],
                                None,
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "abstract", &self.value.abstract_)?;
                            write_attrib_opt(&mut bytes, "cluster-id", &self.value.cluster_id)?;
                            write_attrib_opt(&mut bytes, "extends", &self.value.extends)?;
                            write_attrib(&mut bytes, "hidden", &self.value.hidden)?;
                            write_attrib(
                                &mut bytes,
                                "prohibitChanges",
                                &self.value.prohibit_changes,
                            )?;
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            write_attrib(&mut bytes, "selected", &self.value.selected)?;
                            write_attrib(&mut bytes, "weight", &self.value.weight)?;
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        GroupTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = GroupTypeSerializerState::End__,
                        },
                        GroupTypeSerializerState::End__ => {
                            *self.state = GroupTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        GroupTypeSerializerState::Done__ => return Ok(None),
                        GroupTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for GroupTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = GroupTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct GroupTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::GroupTypeContent,
            pub(super) state: Box<GroupTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum GroupTypeContentSerializerState<'ser> {
            Init__,
            Status(<super::StatusElementType as WithSerializer>::Serializer<'ser>),
            DcStatus(<super::DcStatusType as WithSerializer>::Serializer<'ser>),
            Version(<super::VersionType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextWithSubType as WithSerializer>::Serializer<'ser>),
            Description(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Warning(<super::WarningType as WithSerializer>::Serializer<'ser>),
            Question(<super::TextType as WithSerializer>::Serializer<'ser>),
            Reference(<super::ReferenceType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Rationale(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Platform(<super::OverrideableCpe2IdrefType as WithSerializer>::Serializer<'ser>),
            Requires(<super::IdrefListType as WithSerializer>::Serializer<'ser>),
            Conflicts(<super::IdrefType as WithSerializer>::Serializer<'ser>),
            Value(<super::ValueType as WithSerializer>::Serializer<'ser>),
            Group(<super::GroupType as WithSerializer>::Serializer<'ser>),
            Rule(<super::RuleType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> GroupTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        GroupTypeContentSerializerState::Init__ => match self.value {
                            super::GroupTypeContent::Status(x) => {
                                *self.state = GroupTypeContentSerializerState::Status(
                                    WithSerializer::serializer(x, Some("cdf:status"), false)?,
                                )
                            }
                            super::GroupTypeContent::DcStatus(x) => {
                                *self.state = GroupTypeContentSerializerState::DcStatus(
                                    WithSerializer::serializer(x, Some("cdf:dc-status"), false)?,
                                )
                            }
                            super::GroupTypeContent::Version(x) => {
                                *self.state = GroupTypeContentSerializerState::Version(
                                    WithSerializer::serializer(x, Some("cdf:version"), false)?,
                                )
                            }
                            super::GroupTypeContent::Title(x) => {
                                *self.state = GroupTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::GroupTypeContent::Description(x) => {
                                *self.state = GroupTypeContentSerializerState::Description(
                                    WithSerializer::serializer(x, Some("cdf:description"), false)?,
                                )
                            }
                            super::GroupTypeContent::Warning(x) => {
                                *self.state = GroupTypeContentSerializerState::Warning(
                                    WithSerializer::serializer(x, Some("cdf:warning"), false)?,
                                )
                            }
                            super::GroupTypeContent::Question(x) => {
                                *self.state = GroupTypeContentSerializerState::Question(
                                    WithSerializer::serializer(x, Some("cdf:question"), false)?,
                                )
                            }
                            super::GroupTypeContent::Reference(x) => {
                                *self.state = GroupTypeContentSerializerState::Reference(
                                    WithSerializer::serializer(x, Some("cdf:reference"), false)?,
                                )
                            }
                            super::GroupTypeContent::Metadata(x) => {
                                *self.state = GroupTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::GroupTypeContent::Rationale(x) => {
                                *self.state = GroupTypeContentSerializerState::Rationale(
                                    WithSerializer::serializer(x, Some("cdf:rationale"), false)?,
                                )
                            }
                            super::GroupTypeContent::Platform(x) => {
                                *self.state = GroupTypeContentSerializerState::Platform(
                                    WithSerializer::serializer(x, Some("cdf:platform"), false)?,
                                )
                            }
                            super::GroupTypeContent::Requires(x) => {
                                *self.state = GroupTypeContentSerializerState::Requires(
                                    WithSerializer::serializer(x, Some("cdf:requires"), false)?,
                                )
                            }
                            super::GroupTypeContent::Conflicts(x) => {
                                *self.state = GroupTypeContentSerializerState::Conflicts(
                                    WithSerializer::serializer(x, Some("cdf:conflicts"), false)?,
                                )
                            }
                            super::GroupTypeContent::Value(x) => {
                                *self.state = GroupTypeContentSerializerState::Value(
                                    WithSerializer::serializer(x, Some("cdf:Value"), false)?,
                                )
                            }
                            super::GroupTypeContent::Group(x) => {
                                *self.state = GroupTypeContentSerializerState::Group(
                                    WithSerializer::serializer(x, Some("cdf:Group"), false)?,
                                )
                            }
                            super::GroupTypeContent::Rule(x) => {
                                *self.state = GroupTypeContentSerializerState::Rule(
                                    WithSerializer::serializer(x, Some("cdf:Rule"), false)?,
                                )
                            }
                            super::GroupTypeContent::Signature(x) => {
                                *self.state = GroupTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        GroupTypeContentSerializerState::Status(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::DcStatus(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Version(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Title(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = GroupTypeContentSerializerState::Done__,
                        },
                        GroupTypeContentSerializerState::Description(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Warning(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Question(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Reference(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Rationale(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Platform(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Requires(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Conflicts(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Value(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = GroupTypeContentSerializerState::Done__,
                        },
                        GroupTypeContentSerializerState::Group(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = GroupTypeContentSerializerState::Done__,
                        },
                        GroupTypeContentSerializerState::Rule(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = GroupTypeContentSerializerState::Done__,
                        },
                        GroupTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = GroupTypeContentSerializerState::Done__,
                            }
                        }
                        GroupTypeContentSerializerState::Done__ => return Ok(None),
                        GroupTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for GroupTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = GroupTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct RuleTypeSerializer<'ser> {
            pub(super) value: &'ser super::RuleType,
            pub(super) state: Box<RuleTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum RuleTypeSerializerState<'ser> {
            Init__,
            Content__(IterSerializer<'ser, &'ser [super::RuleTypeContent], super::RuleTypeContent>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> RuleTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        RuleTypeSerializerState::Init__ => {
                            *self.state = RuleTypeSerializerState::Content__(IterSerializer::new(
                                &self.value.content[..],
                                None,
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "abstract", &self.value.abstract_)?;
                            write_attrib_opt(&mut bytes, "cluster-id", &self.value.cluster_id)?;
                            write_attrib_opt(&mut bytes, "extends", &self.value.extends)?;
                            write_attrib(&mut bytes, "hidden", &self.value.hidden)?;
                            write_attrib(
                                &mut bytes,
                                "prohibitChanges",
                                &self.value.prohibit_changes,
                            )?;
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            write_attrib(&mut bytes, "selected", &self.value.selected)?;
                            write_attrib(&mut bytes, "weight", &self.value.weight)?;
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib(&mut bytes, "role", &self.value.role)?;
                            write_attrib(&mut bytes, "severity", &self.value.severity)?;
                            write_attrib(&mut bytes, "multiple", &self.value.multiple)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        RuleTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeSerializerState::End__,
                        },
                        RuleTypeSerializerState::End__ => {
                            *self.state = RuleTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        RuleTypeSerializerState::Done__ => return Ok(None),
                        RuleTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for RuleTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = RuleTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct RuleTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::RuleTypeContent,
            pub(super) state: Box<RuleTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum RuleTypeContentSerializerState<'ser> {
            Init__,
            Status(<super::StatusElementType as WithSerializer>::Serializer<'ser>),
            DcStatus(<super::DcStatusType as WithSerializer>::Serializer<'ser>),
            Version(<super::VersionType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextWithSubType as WithSerializer>::Serializer<'ser>),
            Description(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Warning(<super::WarningType as WithSerializer>::Serializer<'ser>),
            Question(<super::TextType as WithSerializer>::Serializer<'ser>),
            Reference(<super::ReferenceType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Rationale(<super::HtmlTextWithSubType as WithSerializer>::Serializer<'ser>),
            Platform(<super::OverrideableCpe2IdrefType as WithSerializer>::Serializer<'ser>),
            Requires(<super::IdrefListType as WithSerializer>::Serializer<'ser>),
            Conflicts(<super::IdrefType as WithSerializer>::Serializer<'ser>),
            Ident(<super::IdentType as WithSerializer>::Serializer<'ser>),
            ImpactMetric(<String as WithSerializer>::Serializer<'ser>),
            ProfileNote(<super::ProfileNoteType as WithSerializer>::Serializer<'ser>),
            Fixtext(<super::FixTextType as WithSerializer>::Serializer<'ser>),
            Fix(<super::FixType as WithSerializer>::Serializer<'ser>),
            Check(<super::CheckType as WithSerializer>::Serializer<'ser>),
            ComplexCheck(<super::ComplexCheckType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> RuleTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        RuleTypeContentSerializerState::Init__ => match self.value {
                            super::RuleTypeContent::Status(x) => {
                                *self.state = RuleTypeContentSerializerState::Status(
                                    WithSerializer::serializer(x, Some("cdf:status"), false)?,
                                )
                            }
                            super::RuleTypeContent::DcStatus(x) => {
                                *self.state = RuleTypeContentSerializerState::DcStatus(
                                    WithSerializer::serializer(x, Some("cdf:dc-status"), false)?,
                                )
                            }
                            super::RuleTypeContent::Version(x) => {
                                *self.state = RuleTypeContentSerializerState::Version(
                                    WithSerializer::serializer(x, Some("cdf:version"), false)?,
                                )
                            }
                            super::RuleTypeContent::Title(x) => {
                                *self.state = RuleTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::RuleTypeContent::Description(x) => {
                                *self.state = RuleTypeContentSerializerState::Description(
                                    WithSerializer::serializer(x, Some("cdf:description"), false)?,
                                )
                            }
                            super::RuleTypeContent::Warning(x) => {
                                *self.state = RuleTypeContentSerializerState::Warning(
                                    WithSerializer::serializer(x, Some("cdf:warning"), false)?,
                                )
                            }
                            super::RuleTypeContent::Question(x) => {
                                *self.state = RuleTypeContentSerializerState::Question(
                                    WithSerializer::serializer(x, Some("cdf:question"), false)?,
                                )
                            }
                            super::RuleTypeContent::Reference(x) => {
                                *self.state = RuleTypeContentSerializerState::Reference(
                                    WithSerializer::serializer(x, Some("cdf:reference"), false)?,
                                )
                            }
                            super::RuleTypeContent::Metadata(x) => {
                                *self.state = RuleTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::RuleTypeContent::Rationale(x) => {
                                *self.state = RuleTypeContentSerializerState::Rationale(
                                    WithSerializer::serializer(x, Some("cdf:rationale"), false)?,
                                )
                            }
                            super::RuleTypeContent::Platform(x) => {
                                *self.state = RuleTypeContentSerializerState::Platform(
                                    WithSerializer::serializer(x, Some("cdf:platform"), false)?,
                                )
                            }
                            super::RuleTypeContent::Requires(x) => {
                                *self.state = RuleTypeContentSerializerState::Requires(
                                    WithSerializer::serializer(x, Some("cdf:requires"), false)?,
                                )
                            }
                            super::RuleTypeContent::Conflicts(x) => {
                                *self.state = RuleTypeContentSerializerState::Conflicts(
                                    WithSerializer::serializer(x, Some("cdf:conflicts"), false)?,
                                )
                            }
                            super::RuleTypeContent::Ident(x) => {
                                *self.state = RuleTypeContentSerializerState::Ident(
                                    WithSerializer::serializer(x, Some("cdf:ident"), false)?,
                                )
                            }
                            super::RuleTypeContent::ImpactMetric(x) => {
                                *self.state = RuleTypeContentSerializerState::ImpactMetric(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:impact-metric"),
                                        false,
                                    )?,
                                )
                            }
                            super::RuleTypeContent::ProfileNote(x) => {
                                *self.state = RuleTypeContentSerializerState::ProfileNote(
                                    WithSerializer::serializer(x, Some("cdf:profile-note"), false)?,
                                )
                            }
                            super::RuleTypeContent::Fixtext(x) => {
                                *self.state = RuleTypeContentSerializerState::Fixtext(
                                    WithSerializer::serializer(x, Some("cdf:fixtext"), false)?,
                                )
                            }
                            super::RuleTypeContent::Fix(x) => {
                                *self.state = RuleTypeContentSerializerState::Fix(
                                    WithSerializer::serializer(x, Some("cdf:fix"), false)?,
                                )
                            }
                            super::RuleTypeContent::Check(x) => {
                                *self.state = RuleTypeContentSerializerState::Check(
                                    WithSerializer::serializer(x, Some("cdf:check"), false)?,
                                )
                            }
                            super::RuleTypeContent::ComplexCheck(x) => {
                                *self.state = RuleTypeContentSerializerState::ComplexCheck(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-check"),
                                        false,
                                    )?,
                                )
                            }
                            super::RuleTypeContent::Signature(x) => {
                                *self.state = RuleTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        RuleTypeContentSerializerState::Status(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeContentSerializerState::Done__,
                        },
                        RuleTypeContentSerializerState::DcStatus(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Version(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Title(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeContentSerializerState::Done__,
                        },
                        RuleTypeContentSerializerState::Description(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Warning(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Question(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Reference(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Rationale(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Platform(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Requires(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Conflicts(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Ident(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeContentSerializerState::Done__,
                        },
                        RuleTypeContentSerializerState::ImpactMetric(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::ProfileNote(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Fixtext(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Fix(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeContentSerializerState::Done__,
                        },
                        RuleTypeContentSerializerState::Check(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = RuleTypeContentSerializerState::Done__,
                        },
                        RuleTypeContentSerializerState::ComplexCheck(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleTypeContentSerializerState::Done__,
                            }
                        }
                        RuleTypeContentSerializerState::Done__ => return Ok(None),
                        RuleTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for RuleTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = RuleTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TestResultTypeSerializer<'ser> {
            pub(super) value: &'ser super::TestResultType,
            pub(super) state: Box<TestResultTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TestResultTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::TestResultTypeContent],
                    super::TestResultTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TestResultTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TestResultTypeSerializerState::Init__ => {
                            *self.state = TestResultTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib_opt(&mut bytes, "start-time", &self.value.start_time)?;
                            write_attrib(&mut bytes, "end-time", &self.value.end_time)?;
                            write_attrib_opt(&mut bytes, "test-system", &self.value.test_system)?;
                            write_attrib_opt(&mut bytes, "version", &self.value.version)?;
                            write_attrib_opt(&mut bytes, "Id", &self.value.xml_id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        TestResultTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeSerializerState::End__,
                            }
                        }
                        TestResultTypeSerializerState::End__ => {
                            *self.state = TestResultTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        TestResultTypeSerializerState::Done__ => return Ok(None),
                        TestResultTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TestResultTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TestResultTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TestResultTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::TestResultTypeContent,
            pub(super) state: Box<TestResultTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum TestResultTypeContentSerializerState<'ser> {
            Init__,
            Benchmark(<super::BenchmarkReferenceType as WithSerializer>::Serializer<'ser>),
            TailoringFile(<super::TailoringReferenceType as WithSerializer>::Serializer<'ser>),
            Title(<super::TextType as WithSerializer>::Serializer<'ser>),
            Remark(<super::TextType as WithSerializer>::Serializer<'ser>),
            Organization(<String as WithSerializer>::Serializer<'ser>),
            Identity(<super::IdentityType as WithSerializer>::Serializer<'ser>),
            Profile(<super::IdrefType as WithSerializer>::Serializer<'ser>),
            Target(<String as WithSerializer>::Serializer<'ser>),
            TargetAddress(<String as WithSerializer>::Serializer<'ser>),
            TargetFacts(<super::TargetFactsType as WithSerializer>::Serializer<'ser>),
            TargetIdRef(<super::TargetIdRefType as WithSerializer>::Serializer<'ser>),
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Platform(<super::Cpe2IdrefType as WithSerializer>::Serializer<'ser>),
            SetValue(<super::ProfileSetValueType as WithSerializer>::Serializer<'ser>),
            SetComplexValue(
                <super::ProfileSetComplexValueType as WithSerializer>::Serializer<'ser>,
            ),
            RuleResult(<super::RuleResultType as WithSerializer>::Serializer<'ser>),
            Score(<super::ScoreType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Signature(<super::SignatureType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TestResultTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TestResultTypeContentSerializerState::Init__ => match self.value {
                            super::TestResultTypeContent::Benchmark(x) => {
                                *self.state = TestResultTypeContentSerializerState::Benchmark(
                                    WithSerializer::serializer(x, Some("cdf:benchmark"), false)?,
                                )
                            }
                            super::TestResultTypeContent::TailoringFile(x) => {
                                *self.state = TestResultTypeContentSerializerState::TailoringFile(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:tailoring-file"),
                                        false,
                                    )?,
                                )
                            }
                            super::TestResultTypeContent::Title(x) => {
                                *self.state = TestResultTypeContentSerializerState::Title(
                                    WithSerializer::serializer(x, Some("cdf:title"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Remark(x) => {
                                *self.state = TestResultTypeContentSerializerState::Remark(
                                    WithSerializer::serializer(x, Some("cdf:remark"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Organization(x) => {
                                *self.state = TestResultTypeContentSerializerState::Organization(
                                    WithSerializer::serializer(x, Some("cdf:organization"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Identity(x) => {
                                *self.state = TestResultTypeContentSerializerState::Identity(
                                    WithSerializer::serializer(x, Some("cdf:identity"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Profile(x) => {
                                *self.state = TestResultTypeContentSerializerState::Profile(
                                    WithSerializer::serializer(x, Some("cdf:profile"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Target(x) => {
                                *self.state = TestResultTypeContentSerializerState::Target(
                                    WithSerializer::serializer(x, Some("cdf:target"), false)?,
                                )
                            }
                            super::TestResultTypeContent::TargetAddress(x) => {
                                *self.state = TestResultTypeContentSerializerState::TargetAddress(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:target-address"),
                                        false,
                                    )?,
                                )
                            }
                            super::TestResultTypeContent::TargetFacts(x) => {
                                *self.state = TestResultTypeContentSerializerState::TargetFacts(
                                    WithSerializer::serializer(x, Some("cdf:target-facts"), false)?,
                                )
                            }
                            super::TestResultTypeContent::TargetIdRef(x) => {
                                *self.state = TestResultTypeContentSerializerState::TargetIdRef(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:target-id-ref"),
                                        false,
                                    )?,
                                )
                            }
                            super::TestResultTypeContent::Any(x) => {
                                *self.state = TestResultTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any54"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Platform(x) => {
                                *self.state = TestResultTypeContentSerializerState::Platform(
                                    WithSerializer::serializer(x, Some("cdf:platform"), false)?,
                                )
                            }
                            super::TestResultTypeContent::SetValue(x) => {
                                *self.state = TestResultTypeContentSerializerState::SetValue(
                                    WithSerializer::serializer(x, Some("cdf:set-value"), false)?,
                                )
                            }
                            super::TestResultTypeContent::SetComplexValue(x) => {
                                *self.state = TestResultTypeContentSerializerState::SetComplexValue(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:set-complex-value"),
                                        false,
                                    )?,
                                )
                            }
                            super::TestResultTypeContent::RuleResult(x) => {
                                *self.state = TestResultTypeContentSerializerState::RuleResult(
                                    WithSerializer::serializer(x, Some("cdf:rule-result"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Score(x) => {
                                *self.state = TestResultTypeContentSerializerState::Score(
                                    WithSerializer::serializer(x, Some("cdf:score"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Metadata(x) => {
                                *self.state = TestResultTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::TestResultTypeContent::Signature(x) => {
                                *self.state = TestResultTypeContentSerializerState::Signature(
                                    WithSerializer::serializer(x, Some("cdf:signature"), false)?,
                                )
                            }
                        },
                        TestResultTypeContentSerializerState::Benchmark(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::TailoringFile(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Title(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Remark(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Organization(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Identity(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Profile(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Target(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::TargetAddress(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::TargetFacts(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::TargetIdRef(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Any(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Platform(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::SetValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::SetComplexValue(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::RuleResult(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Score(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Signature(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = TestResultTypeContentSerializerState::Done__,
                            }
                        }
                        TestResultTypeContentSerializerState::Done__ => return Ok(None),
                        TestResultTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TestResultTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TestResultTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SignatureTypeSerializer<'ser> {
            pub(super) value: &'ser super::SignatureType,
            pub(super) state: Box<SignatureTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SignatureTypeSerializerState<'ser> {
            Init__,
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SignatureTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SignatureTypeSerializerState::Init__ => {
                            *self.state = SignatureTypeSerializerState::Any(
                                WithSerializer::serializer(&self.value.any, Some("any10"), false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SignatureTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SignatureTypeSerializerState::End__,
                        },
                        SignatureTypeSerializerState::End__ => {
                            *self.state = SignatureTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SignatureTypeSerializerState::Done__ => return Ok(None),
                        SignatureTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SignatureTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SignatureTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SubTypeSerializer<'ser> {
            pub(super) value: &'ser super::SubType,
            pub(super) state: Box<SubTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SubTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SubTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SubTypeSerializerState::Init__ => {
                            *self.state = SubTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib(&mut bytes, "use", &self.value.use_)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        SubTypeSerializerState::Done__ => return Ok(None),
                        SubTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SubTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SubTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ParamTypeSerializer<'ser> {
            pub(super) value: &'ser super::ParamType,
            pub(super) state: Box<ParamTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ParamTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ParamTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ParamTypeSerializerState::Init__ => {
                            *self.state = ParamTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "name", &self.value.name)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ParamTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ParamTypeSerializerState::End__,
                        },
                        ParamTypeSerializerState::End__ => {
                            *self.state = ParamTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ParamTypeSerializerState::Done__ => return Ok(None),
                        ParamTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ParamTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ParamTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TextWithSubTypeSerializer<'ser> {
            pub(super) value: &'ser super::TextWithSubType,
            pub(super) state: Box<TextWithSubTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TextWithSubTypeSerializerState<'ser> {
            Init__,
            TextBefore(IterSerializer<'ser, Option<&'ser Text>, Text>),
            Sub(IterSerializer<'ser, &'ser [Mixed<super::SubType>], Mixed<super::SubType>>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TextWithSubTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TextWithSubTypeSerializerState::Init__ => {
                            *self.state =
                                TextWithSubTypeSerializerState::TextBefore(IterSerializer::new(
                                    self.value.text_before.as_ref(),
                                    Some(""),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        TextWithSubTypeSerializerState::TextBefore(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        TextWithSubTypeSerializerState::Sub(IterSerializer::new(
                                            &self.value.sub[..],
                                            Some("cdf:sub"),
                                            false,
                                        ))
                                }
                            }
                        }
                        TextWithSubTypeSerializerState::Sub(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TextWithSubTypeSerializerState::End__,
                        },
                        TextWithSubTypeSerializerState::End__ => {
                            *self.state = TextWithSubTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        TextWithSubTypeSerializerState::Done__ => return Ok(None),
                        TextWithSubTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TextWithSubTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TextWithSubTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OverrideableCpe2IdrefTypeSerializer<'ser> {
            pub(super) value: &'ser super::OverrideableCpe2IdrefType,
            pub(super) state: Box<OverrideableCpe2IdrefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OverrideableCpe2IdrefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OverrideableCpe2IdrefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OverrideableCpe2IdrefTypeSerializerState::Init__ => {
                            *self.state = OverrideableCpe2IdrefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        OverrideableCpe2IdrefTypeSerializerState::Done__ => return Ok(None),
                        OverrideableCpe2IdrefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for OverrideableCpe2IdrefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OverrideableCpe2IdrefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileSelectTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileSelectType,
            pub(super) state: Box<ProfileSelectTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileSelectTypeSerializerState<'ser> {
            Init__,
            Remark(IterSerializer<'ser, &'ser [super::TextType], super::TextType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileSelectTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileSelectTypeSerializerState::Init__ => {
                            *self.state =
                                ProfileSelectTypeSerializerState::Remark(IterSerializer::new(
                                    &self.value.remark[..],
                                    Some("cdf:remark"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib(&mut bytes, "selected", &self.value.selected)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileSelectTypeSerializerState::Remark(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileSelectTypeSerializerState::End__,
                            }
                        }
                        ProfileSelectTypeSerializerState::End__ => {
                            *self.state = ProfileSelectTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileSelectTypeSerializerState::Done__ => return Ok(None),
                        ProfileSelectTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileSelectTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileSelectTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileSetComplexValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileSetComplexValueType,
            pub(super) state: Box<ProfileSetComplexValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileSetComplexValueTypeSerializerState<'ser> {
            Init__,
            Item(IterSerializer<'ser, &'ser [String], String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileSetComplexValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileSetComplexValueTypeSerializerState::Init__ => {
                            *self.state = ProfileSetComplexValueTypeSerializerState::Item(
                                IterSerializer::new(&self.value.item[..], Some("cdf:item"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileSetComplexValueTypeSerializerState::Item(x) => match x
                            .next()
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ProfileSetComplexValueTypeSerializerState::End__,
                        },
                        ProfileSetComplexValueTypeSerializerState::End__ => {
                            *self.state = ProfileSetComplexValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileSetComplexValueTypeSerializerState::Done__ => return Ok(None),
                        ProfileSetComplexValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileSetComplexValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileSetComplexValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileSetValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileSetValueType,
            pub(super) state: Box<ProfileSetValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileSetValueTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileSetValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileSetValueTypeSerializerState::Init__ => {
                            *self.state = ProfileSetValueTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileSetValueTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileSetValueTypeSerializerState::End__,
                            }
                        }
                        ProfileSetValueTypeSerializerState::End__ => {
                            *self.state = ProfileSetValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileSetValueTypeSerializerState::Done__ => return Ok(None),
                        ProfileSetValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileSetValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileSetValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileRefineValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileRefineValueType,
            pub(super) state: Box<ProfileRefineValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileRefineValueTypeSerializerState<'ser> {
            Init__,
            Remark(IterSerializer<'ser, &'ser [super::TextType], super::TextType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileRefineValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileRefineValueTypeSerializerState::Init__ => {
                            *self.state =
                                ProfileRefineValueTypeSerializerState::Remark(IterSerializer::new(
                                    &self.value.remark[..],
                                    Some("cdf:remark"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib_opt(&mut bytes, "selector", &self.value.selector)?;
                            write_attrib_opt(&mut bytes, "operator", &self.value.operator)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileRefineValueTypeSerializerState::Remark(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileRefineValueTypeSerializerState::End__,
                            }
                        }
                        ProfileRefineValueTypeSerializerState::End__ => {
                            *self.state = ProfileRefineValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileRefineValueTypeSerializerState::Done__ => return Ok(None),
                        ProfileRefineValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileRefineValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileRefineValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileRefineRuleTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileRefineRuleType,
            pub(super) state: Box<ProfileRefineRuleTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileRefineRuleTypeSerializerState<'ser> {
            Init__,
            Remark(IterSerializer<'ser, &'ser [super::TextType], super::TextType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileRefineRuleTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileRefineRuleTypeSerializerState::Init__ => {
                            *self.state =
                                ProfileRefineRuleTypeSerializerState::Remark(IterSerializer::new(
                                    &self.value.remark[..],
                                    Some("cdf:remark"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib_opt(&mut bytes, "weight", &self.value.weight)?;
                            write_attrib_opt(&mut bytes, "selector", &self.value.selector)?;
                            write_attrib_opt(&mut bytes, "severity", &self.value.severity)?;
                            write_attrib_opt(&mut bytes, "role", &self.value.role)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileRefineRuleTypeSerializerState::Remark(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileRefineRuleTypeSerializerState::End__,
                            }
                        }
                        ProfileRefineRuleTypeSerializerState::End__ => {
                            *self.state = ProfileRefineRuleTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileRefineRuleTypeSerializerState::Done__ => return Ok(None),
                        ProfileRefineRuleTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileRefineRuleTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileRefineRuleTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct WarningTypeSerializer<'ser> {
            pub(super) value: &'ser super::WarningType,
            pub(super) state: Box<WarningTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum WarningTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::WarningTypeContent], super::WarningTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> WarningTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        WarningTypeSerializerState::Init__ => {
                            *self.state = WarningTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            write_attrib(&mut bytes, "category", &self.value.category)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        WarningTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = WarningTypeSerializerState::End__,
                        },
                        WarningTypeSerializerState::End__ => {
                            *self.state = WarningTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        WarningTypeSerializerState::Done__ => return Ok(None),
                        WarningTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for WarningTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = WarningTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct WarningTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::WarningTypeContent,
            pub(super) state: Box<WarningTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum WarningTypeContentSerializerState<'ser> {
            Init__,
            Sub(<super::SubType as WithSerializer>::Serializer<'ser>),
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> WarningTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        WarningTypeContentSerializerState::Init__ => match self.value {
                            super::WarningTypeContent::Sub(x) => {
                                *self.state = WarningTypeContentSerializerState::Sub(
                                    WithSerializer::serializer(x, Some("cdf:sub"), false)?,
                                )
                            }
                            super::WarningTypeContent::Any(x) => {
                                *self.state = WarningTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any17"), false)?,
                                )
                            }
                            super::WarningTypeContent::Text(x) => {
                                *self.state = WarningTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        WarningTypeContentSerializerState::Sub(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = WarningTypeContentSerializerState::Done__,
                        },
                        WarningTypeContentSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = WarningTypeContentSerializerState::Done__,
                        },
                        WarningTypeContentSerializerState::Text(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = WarningTypeContentSerializerState::Done__,
                            }
                        }
                        WarningTypeContentSerializerState::Done__ => return Ok(None),
                        WarningTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for WarningTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = WarningTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SelStringTypeSerializer<'ser> {
            pub(super) value: &'ser super::SelStringType,
            pub(super) state: Box<SelStringTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SelStringTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SelStringTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SelStringTypeSerializerState::Init__ => {
                            *self.state = SelStringTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "selector", &self.value.selector)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SelStringTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SelStringTypeSerializerState::End__,
                        },
                        SelStringTypeSerializerState::End__ => {
                            *self.state = SelStringTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SelStringTypeSerializerState::Done__ => return Ok(None),
                        SelStringTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SelStringTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SelStringTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SelComplexValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::SelComplexValueType,
            pub(super) state: Box<SelComplexValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SelComplexValueTypeSerializerState<'ser> {
            Init__,
            Item(IterSerializer<'ser, &'ser [String], String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SelComplexValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SelComplexValueTypeSerializerState::Init__ => {
                            *self.state = SelComplexValueTypeSerializerState::Item(
                                IterSerializer::new(&self.value.item[..], Some("cdf:item"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "selector", &self.value.selector)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SelComplexValueTypeSerializerState::Item(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SelComplexValueTypeSerializerState::End__,
                            }
                        }
                        SelComplexValueTypeSerializerState::End__ => {
                            *self.state = SelComplexValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SelComplexValueTypeSerializerState::Done__ => return Ok(None),
                        SelComplexValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SelComplexValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SelComplexValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SelNumTypeSerializer<'ser> {
            pub(super) value: &'ser super::SelNumType,
            pub(super) state: Box<SelNumTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SelNumTypeSerializerState<'ser> {
            Init__,
            Content__(<f64 as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SelNumTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SelNumTypeSerializerState::Init__ => {
                            *self.state = SelNumTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "selector", &self.value.selector)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SelNumTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = SelNumTypeSerializerState::End__,
                        },
                        SelNumTypeSerializerState::End__ => {
                            *self.state = SelNumTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SelNumTypeSerializerState::Done__ => return Ok(None),
                        SelNumTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SelNumTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SelNumTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SelChoicesTypeSerializer<'ser> {
            pub(super) value: &'ser super::SelChoicesType,
            pub(super) state: Box<SelChoicesTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SelChoicesTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::SelChoicesTypeContent],
                    super::SelChoicesTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SelChoicesTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SelChoicesTypeSerializerState::Init__ => {
                            *self.state = SelChoicesTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "mustMatch", &self.value.must_match)?;
                            write_attrib(&mut bytes, "selector", &self.value.selector)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SelChoicesTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SelChoicesTypeSerializerState::End__,
                            }
                        }
                        SelChoicesTypeSerializerState::End__ => {
                            *self.state = SelChoicesTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SelChoicesTypeSerializerState::Done__ => return Ok(None),
                        SelChoicesTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SelChoicesTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SelChoicesTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SelChoicesTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::SelChoicesTypeContent,
            pub(super) state: Box<SelChoicesTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum SelChoicesTypeContentSerializerState<'ser> {
            Init__,
            Choice(<String as WithSerializer>::Serializer<'ser>),
            ComplexChoice(<super::ComplexValueType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SelChoicesTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SelChoicesTypeContentSerializerState::Init__ => match self.value {
                            super::SelChoicesTypeContent::Choice(x) => {
                                *self.state = SelChoicesTypeContentSerializerState::Choice(
                                    WithSerializer::serializer(x, Some("cdf:choice"), false)?,
                                )
                            }
                            super::SelChoicesTypeContent::ComplexChoice(x) => {
                                *self.state = SelChoicesTypeContentSerializerState::ComplexChoice(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-choice"),
                                        false,
                                    )?,
                                )
                            }
                        },
                        SelChoicesTypeContentSerializerState::Choice(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SelChoicesTypeContentSerializerState::Done__,
                            }
                        }
                        SelChoicesTypeContentSerializerState::ComplexChoice(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SelChoicesTypeContentSerializerState::Done__,
                            }
                        }
                        SelChoicesTypeContentSerializerState::Done__ => return Ok(None),
                        SelChoicesTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for SelChoicesTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SelChoicesTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct UriRefTypeSerializer<'ser> {
            pub(super) value: &'ser super::UriRefType,
            pub(super) state: Box<UriRefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum UriRefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> UriRefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        UriRefTypeSerializerState::Init__ => {
                            *self.state = UriRefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "uri", &self.value.uri)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        UriRefTypeSerializerState::Done__ => return Ok(None),
                        UriRefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for UriRefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = UriRefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct IdrefListTypeSerializer<'ser> {
            pub(super) value: &'ser super::IdrefListType,
            pub(super) state: Box<IdrefListTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum IdrefListTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> IdrefListTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        IdrefListTypeSerializerState::Init__ => {
                            *self.state = IdrefListTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        IdrefListTypeSerializerState::Done__ => return Ok(None),
                        IdrefListTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for IdrefListTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = IdrefListTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct IdrefTypeSerializer<'ser> {
            pub(super) value: &'ser super::IdrefType,
            pub(super) state: Box<IdrefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum IdrefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> IdrefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        IdrefTypeSerializerState::Init__ => {
                            *self.state = IdrefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        IdrefTypeSerializerState::Done__ => return Ok(None),
                        IdrefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for IdrefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = IdrefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct IdentTypeSerializer<'ser> {
            pub(super) value: &'ser super::IdentType,
            pub(super) state: Box<IdentTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum IdentTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> IdentTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        IdentTypeSerializerState::Init__ => {
                            *self.state = IdentTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "system", &self.value.system)?;
                            bytes.extend_attributes(self.value.any_attribute.attributes());
                            return Ok(Some(Event::Start(bytes)));
                        }
                        IdentTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = IdentTypeSerializerState::End__,
                        },
                        IdentTypeSerializerState::End__ => {
                            *self.state = IdentTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        IdentTypeSerializerState::Done__ => return Ok(None),
                        IdentTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for IdentTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = IdentTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileNoteTypeSerializer<'ser> {
            pub(super) value: &'ser super::ProfileNoteType,
            pub(super) state: Box<ProfileNoteTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ProfileNoteTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::ProfileNoteTypeContent],
                    super::ProfileNoteTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileNoteTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileNoteTypeSerializerState::Init__ => {
                            *self.state = ProfileNoteTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "tag", &self.value.tag)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ProfileNoteTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileNoteTypeSerializerState::End__,
                            }
                        }
                        ProfileNoteTypeSerializerState::End__ => {
                            *self.state = ProfileNoteTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ProfileNoteTypeSerializerState::Done__ => return Ok(None),
                        ProfileNoteTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileNoteTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileNoteTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ProfileNoteTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::ProfileNoteTypeContent,
            pub(super) state: Box<ProfileNoteTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum ProfileNoteTypeContentSerializerState<'ser> {
            Init__,
            Sub(<super::SubType as WithSerializer>::Serializer<'ser>),
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ProfileNoteTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ProfileNoteTypeContentSerializerState::Init__ => match self.value {
                            super::ProfileNoteTypeContent::Sub(x) => {
                                *self.state = ProfileNoteTypeContentSerializerState::Sub(
                                    WithSerializer::serializer(x, Some("cdf:sub"), false)?,
                                )
                            }
                            super::ProfileNoteTypeContent::Any(x) => {
                                *self.state = ProfileNoteTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any19"), false)?,
                                )
                            }
                            super::ProfileNoteTypeContent::Text(x) => {
                                *self.state = ProfileNoteTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        ProfileNoteTypeContentSerializerState::Sub(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileNoteTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileNoteTypeContentSerializerState::Any(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileNoteTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileNoteTypeContentSerializerState::Text(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ProfileNoteTypeContentSerializerState::Done__,
                            }
                        }
                        ProfileNoteTypeContentSerializerState::Done__ => return Ok(None),
                        ProfileNoteTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ProfileNoteTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ProfileNoteTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct FixTextTypeSerializer<'ser> {
            pub(super) value: &'ser super::FixTextType,
            pub(super) state: Box<FixTextTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum FixTextTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::FixTextTypeContent], super::FixTextTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> FixTextTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        FixTextTypeSerializerState::Init__ => {
                            *self.state = FixTextTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            write_attrib(&mut bytes, "override", &self.value.override_)?;
                            write_attrib_opt(&mut bytes, "fixref", &self.value.fixref)?;
                            write_attrib(&mut bytes, "reboot", &self.value.reboot)?;
                            write_attrib(&mut bytes, "strategy", &self.value.strategy)?;
                            write_attrib(&mut bytes, "disruption", &self.value.disruption)?;
                            write_attrib(&mut bytes, "complexity", &self.value.complexity)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        FixTextTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTextTypeSerializerState::End__,
                        },
                        FixTextTypeSerializerState::End__ => {
                            *self.state = FixTextTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        FixTextTypeSerializerState::Done__ => return Ok(None),
                        FixTextTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for FixTextTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = FixTextTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct FixTextTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::FixTextTypeContent,
            pub(super) state: Box<FixTextTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum FixTextTypeContentSerializerState<'ser> {
            Init__,
            Sub(<super::SubType as WithSerializer>::Serializer<'ser>),
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> FixTextTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        FixTextTypeContentSerializerState::Init__ => match self.value {
                            super::FixTextTypeContent::Sub(x) => {
                                *self.state = FixTextTypeContentSerializerState::Sub(
                                    WithSerializer::serializer(x, Some("cdf:sub"), false)?,
                                )
                            }
                            super::FixTextTypeContent::Any(x) => {
                                *self.state = FixTextTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any17"), false)?,
                                )
                            }
                            super::FixTextTypeContent::Text(x) => {
                                *self.state = FixTextTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        FixTextTypeContentSerializerState::Sub(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTextTypeContentSerializerState::Done__,
                        },
                        FixTextTypeContentSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTextTypeContentSerializerState::Done__,
                        },
                        FixTextTypeContentSerializerState::Text(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = FixTextTypeContentSerializerState::Done__,
                            }
                        }
                        FixTextTypeContentSerializerState::Done__ => return Ok(None),
                        FixTextTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for FixTextTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = FixTextTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct FixTypeSerializer<'ser> {
            pub(super) value: &'ser super::FixType,
            pub(super) state: Box<FixTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum FixTypeSerializerState<'ser> {
            Init__,
            Content__(IterSerializer<'ser, &'ser [super::FixTypeContent], super::FixTypeContent>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> FixTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        FixTypeSerializerState::Init__ => {
                            *self.state = FixTypeSerializerState::Content__(IterSerializer::new(
                                &self.value.content[..],
                                None,
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "id", &self.value.id)?;
                            write_attrib(&mut bytes, "reboot", &self.value.reboot)?;
                            write_attrib(&mut bytes, "strategy", &self.value.strategy)?;
                            write_attrib(&mut bytes, "disruption", &self.value.disruption)?;
                            write_attrib(&mut bytes, "complexity", &self.value.complexity)?;
                            write_attrib_opt(&mut bytes, "system", &self.value.system)?;
                            write_attrib_opt(&mut bytes, "platform", &self.value.platform)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        FixTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTypeSerializerState::End__,
                        },
                        FixTypeSerializerState::End__ => {
                            *self.state = FixTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        FixTypeSerializerState::Done__ => return Ok(None),
                        FixTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for FixTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = FixTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct FixTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::FixTypeContent,
            pub(super) state: Box<FixTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum FixTypeContentSerializerState<'ser> {
            Init__,
            Sub(<super::SubType as WithSerializer>::Serializer<'ser>),
            Instance(<super::InstanceFixType as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> FixTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        FixTypeContentSerializerState::Init__ => match self.value {
                            super::FixTypeContent::Sub(x) => {
                                *self.state = FixTypeContentSerializerState::Sub(
                                    WithSerializer::serializer(x, Some("cdf:sub"), false)?,
                                )
                            }
                            super::FixTypeContent::Instance(x) => {
                                *self.state = FixTypeContentSerializerState::Instance(
                                    WithSerializer::serializer(x, Some("cdf:instance"), false)?,
                                )
                            }
                            super::FixTypeContent::Text(x) => {
                                *self.state = FixTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        FixTypeContentSerializerState::Sub(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTypeContentSerializerState::Done__,
                        },
                        FixTypeContentSerializerState::Instance(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = FixTypeContentSerializerState::Done__,
                            }
                        }
                        FixTypeContentSerializerState::Text(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FixTypeContentSerializerState::Done__,
                        },
                        FixTypeContentSerializerState::Done__ => return Ok(None),
                        FixTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for FixTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = FixTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckType,
            pub(super) state: Box<CheckTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckTypeSerializerState<'ser> {
            Init__,
            CheckImport(
                IterSerializer<'ser, &'ser [super::CheckImportType], super::CheckImportType>,
            ),
            CheckExport(
                IterSerializer<'ser, &'ser [super::CheckExportType], super::CheckExportType>,
            ),
            CheckContentRef(
                IterSerializer<
                    'ser,
                    &'ser [super::CheckContentRefType],
                    super::CheckContentRefType,
                >,
            ),
            CheckContent(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CheckContentType>,
                    super::CheckContentType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckTypeSerializerState::Init__ => {
                            *self.state =
                                CheckTypeSerializerState::CheckImport(IterSerializer::new(
                                    &self.value.check_import[..],
                                    Some("cdf:check-import"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "system", &self.value.system)?;
                            write_attrib(&mut bytes, "negate", &self.value.negate)?;
                            write_attrib_opt(&mut bytes, "id", &self.value.id)?;
                            write_attrib(&mut bytes, "selector", &self.value.selector)?;
                            write_attrib(&mut bytes, "multi-check", &self.value.multi_check)?;
                            write_attrib_opt(&mut bytes, "base", &self.value.base)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CheckTypeSerializerState::CheckImport(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CheckTypeSerializerState::CheckExport(IterSerializer::new(
                                        &self.value.check_export[..],
                                        Some("cdf:check-export"),
                                        false,
                                    ))
                            }
                        },
                        CheckTypeSerializerState::CheckExport(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CheckTypeSerializerState::CheckContentRef(IterSerializer::new(
                                        &self.value.check_content_ref[..],
                                        Some("cdf:check-content-ref"),
                                        false,
                                    ))
                            }
                        },
                        CheckTypeSerializerState::CheckContentRef(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CheckTypeSerializerState::CheckContent(IterSerializer::new(
                                            self.value.check_content.as_ref(),
                                            Some("cdf:check-content"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CheckTypeSerializerState::CheckContent(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CheckTypeSerializerState::End__,
                        },
                        CheckTypeSerializerState::End__ => {
                            *self.state = CheckTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CheckTypeSerializerState::Done__ => return Ok(None),
                        CheckTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ComplexCheckTypeSerializer<'ser> {
            pub(super) value: &'ser super::ComplexCheckType,
            pub(super) state: Box<ComplexCheckTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ComplexCheckTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::ComplexCheckTypeContent],
                    super::ComplexCheckTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ComplexCheckTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ComplexCheckTypeSerializerState::Init__ => {
                            *self.state = ComplexCheckTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "operator", &self.value.operator)?;
                            write_attrib(&mut bytes, "negate", &self.value.negate)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ComplexCheckTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ComplexCheckTypeSerializerState::End__,
                            }
                        }
                        ComplexCheckTypeSerializerState::End__ => {
                            *self.state = ComplexCheckTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ComplexCheckTypeSerializerState::Done__ => return Ok(None),
                        ComplexCheckTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ComplexCheckTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ComplexCheckTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ComplexCheckTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::ComplexCheckTypeContent,
            pub(super) state: Box<ComplexCheckTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum ComplexCheckTypeContentSerializerState<'ser> {
            Init__,
            Check(<super::CheckType as WithSerializer>::Serializer<'ser>),
            ComplexCheck(<super::ComplexCheckType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ComplexCheckTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ComplexCheckTypeContentSerializerState::Init__ => match self.value {
                            super::ComplexCheckTypeContent::Check(x) => {
                                *self.state = ComplexCheckTypeContentSerializerState::Check(
                                    WithSerializer::serializer(x, Some("cdf:check"), false)?,
                                )
                            }
                            super::ComplexCheckTypeContent::ComplexCheck(x) => {
                                *self.state = ComplexCheckTypeContentSerializerState::ComplexCheck(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-check"),
                                        false,
                                    )?,
                                )
                            }
                        },
                        ComplexCheckTypeContentSerializerState::Check(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = ComplexCheckTypeContentSerializerState::Done__
                                }
                            }
                        }
                        ComplexCheckTypeContentSerializerState::ComplexCheck(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = ComplexCheckTypeContentSerializerState::Done__
                                }
                            }
                        }
                        ComplexCheckTypeContentSerializerState::Done__ => return Ok(None),
                        ComplexCheckTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ComplexCheckTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ComplexCheckTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct BenchmarkReferenceTypeSerializer<'ser> {
            pub(super) value: &'ser super::BenchmarkReferenceType,
            pub(super) state: Box<BenchmarkReferenceTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum BenchmarkReferenceTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> BenchmarkReferenceTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        BenchmarkReferenceTypeSerializerState::Init__ => {
                            *self.state = BenchmarkReferenceTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "href", &self.value.href)?;
                            write_attrib_opt(&mut bytes, "id", &self.value.id)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        BenchmarkReferenceTypeSerializerState::Done__ => return Ok(None),
                        BenchmarkReferenceTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for BenchmarkReferenceTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = BenchmarkReferenceTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TailoringReferenceTypeSerializer<'ser> {
            pub(super) value: &'ser super::TailoringReferenceType,
            pub(super) state: Box<TailoringReferenceTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TailoringReferenceTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TailoringReferenceTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TailoringReferenceTypeSerializerState::Init__ => {
                            *self.state = TailoringReferenceTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "href", &self.value.href)?;
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            write_attrib(&mut bytes, "version", &self.value.version)?;
                            write_attrib(&mut bytes, "time", &self.value.time)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        TailoringReferenceTypeSerializerState::Done__ => return Ok(None),
                        TailoringReferenceTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TailoringReferenceTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TailoringReferenceTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct IdentityTypeSerializer<'ser> {
            pub(super) value: &'ser super::IdentityType,
            pub(super) state: Box<IdentityTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum IdentityTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> IdentityTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        IdentityTypeSerializerState::Init__ => {
                            *self.state = IdentityTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "authenticated", &self.value.authenticated)?;
                            write_attrib(&mut bytes, "privileged", &self.value.privileged)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        IdentityTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = IdentityTypeSerializerState::End__,
                        },
                        IdentityTypeSerializerState::End__ => {
                            *self.state = IdentityTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        IdentityTypeSerializerState::Done__ => return Ok(None),
                        IdentityTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for IdentityTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = IdentityTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TargetFactsTypeSerializer<'ser> {
            pub(super) value: &'ser super::TargetFactsType,
            pub(super) state: Box<TargetFactsTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TargetFactsTypeSerializerState<'ser> {
            Init__,
            Fact(IterSerializer<'ser, &'ser [super::FactType], super::FactType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TargetFactsTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TargetFactsTypeSerializerState::Init__ => {
                            *self.state = TargetFactsTypeSerializerState::Fact(
                                IterSerializer::new(&self.value.fact[..], Some("cdf:fact"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        TargetFactsTypeSerializerState::Fact(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TargetFactsTypeSerializerState::End__,
                        },
                        TargetFactsTypeSerializerState::End__ => {
                            *self.state = TargetFactsTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        TargetFactsTypeSerializerState::Done__ => return Ok(None),
                        TargetFactsTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TargetFactsTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TargetFactsTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TargetIdRefTypeSerializer<'ser> {
            pub(super) value: &'ser super::TargetIdRefType,
            pub(super) state: Box<TargetIdRefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TargetIdRefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TargetIdRefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TargetIdRefTypeSerializerState::Init__ => {
                            *self.state = TargetIdRefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "system", &self.value.system)?;
                            write_attrib(&mut bytes, "href", &self.value.href)?;
                            write_attrib_opt(&mut bytes, "name", &self.value.name)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        TargetIdRefTypeSerializerState::Done__ => return Ok(None),
                        TargetIdRefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TargetIdRefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TargetIdRefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct RuleResultTypeSerializer<'ser> {
            pub(super) value: &'ser super::RuleResultType,
            pub(super) state: Box<RuleResultTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum RuleResultTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::RuleResultTypeContent],
                    super::RuleResultTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> RuleResultTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        RuleResultTypeSerializerState::Init__ => {
                            *self.state = RuleResultTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "idref", &self.value.idref)?;
                            write_attrib_opt(&mut bytes, "role", &self.value.role)?;
                            write_attrib_opt(&mut bytes, "severity", &self.value.severity)?;
                            write_attrib_opt(&mut bytes, "time", &self.value.time)?;
                            write_attrib_opt(&mut bytes, "version", &self.value.version)?;
                            write_attrib_opt(&mut bytes, "weight", &self.value.weight)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        RuleResultTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeSerializerState::End__,
                            }
                        }
                        RuleResultTypeSerializerState::End__ => {
                            *self.state = RuleResultTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        RuleResultTypeSerializerState::Done__ => return Ok(None),
                        RuleResultTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for RuleResultTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = RuleResultTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct RuleResultTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::RuleResultTypeContent,
            pub(super) state: Box<RuleResultTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum RuleResultTypeContentSerializerState<'ser> {
            Init__,
            Result(<super::ResultEnumType as WithSerializer>::Serializer<'ser>),
            Override(<super::OverrideType as WithSerializer>::Serializer<'ser>),
            Ident(<super::IdentType as WithSerializer>::Serializer<'ser>),
            Metadata(<super::MetadataType as WithSerializer>::Serializer<'ser>),
            Message(<super::MessageType as WithSerializer>::Serializer<'ser>),
            Instance(<super::InstanceResultType as WithSerializer>::Serializer<'ser>),
            Fix(<super::FixType as WithSerializer>::Serializer<'ser>),
            Check(<super::CheckType as WithSerializer>::Serializer<'ser>),
            ComplexCheck(<super::ComplexCheckType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> RuleResultTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        RuleResultTypeContentSerializerState::Init__ => match self.value {
                            super::RuleResultTypeContent::Result(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Result(
                                    WithSerializer::serializer(x, Some("cdf:result"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Override(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Override(
                                    WithSerializer::serializer(x, Some("cdf:override"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Ident(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Ident(
                                    WithSerializer::serializer(x, Some("cdf:ident"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Metadata(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Metadata(
                                    WithSerializer::serializer(x, Some("cdf:metadata"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Message(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Message(
                                    WithSerializer::serializer(x, Some("cdf:message"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Instance(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Instance(
                                    WithSerializer::serializer(x, Some("cdf:instance"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Fix(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Fix(
                                    WithSerializer::serializer(x, Some("cdf:fix"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::Check(x) => {
                                *self.state = RuleResultTypeContentSerializerState::Check(
                                    WithSerializer::serializer(x, Some("cdf:check"), false)?,
                                )
                            }
                            super::RuleResultTypeContent::ComplexCheck(x) => {
                                *self.state = RuleResultTypeContentSerializerState::ComplexCheck(
                                    WithSerializer::serializer(
                                        x,
                                        Some("cdf:complex-check"),
                                        false,
                                    )?,
                                )
                            }
                        },
                        RuleResultTypeContentSerializerState::Result(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Override(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Ident(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Metadata(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Message(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Instance(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Fix(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Check(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::ComplexCheck(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = RuleResultTypeContentSerializerState::Done__,
                            }
                        }
                        RuleResultTypeContentSerializerState::Done__ => return Ok(None),
                        RuleResultTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for RuleResultTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = RuleResultTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ScoreTypeSerializer<'ser> {
            pub(super) value: &'ser super::ScoreType,
            pub(super) state: Box<ScoreTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ScoreTypeSerializerState<'ser> {
            Init__,
            Content__(<f64 as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ScoreTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ScoreTypeSerializerState::Init__ => {
                            *self.state = ScoreTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "system", &self.value.system)?;
                            write_attrib_opt(&mut bytes, "maximum", &self.value.maximum)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ScoreTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ScoreTypeSerializerState::End__,
                        },
                        ScoreTypeSerializerState::End__ => {
                            *self.state = ScoreTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ScoreTypeSerializerState::Done__ => return Ok(None),
                        ScoreTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ScoreTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ScoreTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ComplexValueTypeSerializer<'ser> {
            pub(super) value: &'ser super::ComplexValueType,
            pub(super) state: Box<ComplexValueTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ComplexValueTypeSerializerState<'ser> {
            Init__,
            Item(IterSerializer<'ser, &'ser [String], String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ComplexValueTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ComplexValueTypeSerializerState::Init__ => {
                            *self.state = ComplexValueTypeSerializerState::Item(
                                IterSerializer::new(&self.value.item[..], Some("cdf:item"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ComplexValueTypeSerializerState::Item(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ComplexValueTypeSerializerState::End__,
                        },
                        ComplexValueTypeSerializerState::End__ => {
                            *self.state = ComplexValueTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ComplexValueTypeSerializerState::Done__ => return Ok(None),
                        ComplexValueTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for ComplexValueTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ComplexValueTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct InstanceFixTypeSerializer<'ser> {
            pub(super) value: &'ser super::InstanceFixType,
            pub(super) state: Box<InstanceFixTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum InstanceFixTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> InstanceFixTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        InstanceFixTypeSerializerState::Init__ => {
                            *self.state = InstanceFixTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "context", &self.value.context)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        InstanceFixTypeSerializerState::Done__ => return Ok(None),
                        InstanceFixTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for InstanceFixTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = InstanceFixTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckImportTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckImportType,
            pub(super) state: Box<CheckImportTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckImportTypeSerializerState<'ser> {
            Init__,
            TextBefore(IterSerializer<'ser, Option<&'ser Text>, Text>),
            Any(IterSerializer<'ser, Option<&'ser AnyElement>, AnyElement>),
            TextAfterAny36(IterSerializer<'ser, Option<&'ser Text>, Text>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckImportTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckImportTypeSerializerState::Init__ => {
                            *self.state =
                                CheckImportTypeSerializerState::TextBefore(IterSerializer::new(
                                    self.value.text_before.as_ref(),
                                    Some("text_before"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "import-name", &self.value.import_name)?;
                            write_attrib_opt(&mut bytes, "import-xpath", &self.value.import_xpath)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CheckImportTypeSerializerState::TextBefore(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CheckImportTypeSerializerState::Any(IterSerializer::new(
                                            self.value.any.as_ref(),
                                            Some("any36"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CheckImportTypeSerializerState::Any(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = CheckImportTypeSerializerState::TextAfterAny36(
                                    IterSerializer::new(
                                        self.value.text_after_any_36.as_ref(),
                                        Some("text_after_any36"),
                                        false,
                                    ),
                                )
                            }
                        },
                        CheckImportTypeSerializerState::TextAfterAny36(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CheckImportTypeSerializerState::End__,
                            }
                        }
                        CheckImportTypeSerializerState::End__ => {
                            *self.state = CheckImportTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CheckImportTypeSerializerState::Done__ => return Ok(None),
                        CheckImportTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckImportTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckImportTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckExportTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckExportType,
            pub(super) state: Box<CheckExportTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckExportTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckExportTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckExportTypeSerializerState::Init__ => {
                            *self.state = CheckExportTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "value-id", &self.value.value_id)?;
                            write_attrib(&mut bytes, "export-name", &self.value.export_name)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CheckExportTypeSerializerState::Done__ => return Ok(None),
                        CheckExportTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckExportTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckExportTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckContentRefTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckContentRefType,
            pub(super) state: Box<CheckContentRefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckContentRefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckContentRefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckContentRefTypeSerializerState::Init__ => {
                            *self.state = CheckContentRefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "href", &self.value.href)?;
                            write_attrib_opt(&mut bytes, "name", &self.value.name)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CheckContentRefTypeSerializerState::Done__ => return Ok(None),
                        CheckContentRefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckContentRefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckContentRefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckContentTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckContentType,
            pub(super) state: Box<CheckContentTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckContentTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CheckContentTypeContent],
                    super::CheckContentTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckContentTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckContentTypeSerializerState::Init__ => {
                            *self.state = CheckContentTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CheckContentTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CheckContentTypeSerializerState::End__,
                            }
                        }
                        CheckContentTypeSerializerState::End__ => {
                            *self.state = CheckContentTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CheckContentTypeSerializerState::Done__ => return Ok(None),
                        CheckContentTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckContentTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckContentTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckContentTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CheckContentTypeContent,
            pub(super) state: Box<CheckContentTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CheckContentTypeContentSerializerState<'ser> {
            Init__,
            Any(<AnyElement as WithSerializer>::Serializer<'ser>),
            Text(<Text as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckContentTypeContentSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckContentTypeContentSerializerState::Init__ => match self.value {
                            super::CheckContentTypeContent::Any(x) => {
                                *self.state = CheckContentTypeContentSerializerState::Any(
                                    WithSerializer::serializer(x, Some("any38"), false)?,
                                )
                            }
                            super::CheckContentTypeContent::Text(x) => {
                                *self.state = CheckContentTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("text"), false)?,
                                )
                            }
                        },
                        CheckContentTypeContentSerializerState::Any(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CheckContentTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CheckContentTypeContentSerializerState::Text(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CheckContentTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CheckContentTypeContentSerializerState::Done__ => return Ok(None),
                        CheckContentTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckContentTypeContentSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckContentTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct FactTypeSerializer<'ser> {
            pub(super) value: &'ser super::FactType,
            pub(super) state: Box<FactTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum FactTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> FactTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        FactTypeSerializerState::Init__ => {
                            *self.state = FactTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "name", &self.value.name)?;
                            write_attrib(&mut bytes, "type", &self.value.type_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        FactTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = FactTypeSerializerState::End__,
                        },
                        FactTypeSerializerState::End__ => {
                            *self.state = FactTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        FactTypeSerializerState::Done__ => return Ok(None),
                        FactTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for FactTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = FactTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OverrideTypeSerializer<'ser> {
            pub(super) value: &'ser super::OverrideType,
            pub(super) state: Box<OverrideTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OverrideTypeSerializerState<'ser> {
            Init__,
            OldResult(<super::ResultEnumType as WithSerializer>::Serializer<'ser>),
            NewResult(<super::ResultEnumType as WithSerializer>::Serializer<'ser>),
            Remark(<super::TextType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OverrideTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OverrideTypeSerializerState::Init__ => {
                            *self.state =
                                OverrideTypeSerializerState::OldResult(WithSerializer::serializer(
                                    &self.value.old_result,
                                    Some("cdf:old-result"),
                                    false,
                                )?);
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "time", &self.value.time)?;
                            write_attrib(&mut bytes, "authority", &self.value.authority)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        OverrideTypeSerializerState::OldResult(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = OverrideTypeSerializerState::NewResult(
                                    WithSerializer::serializer(
                                        &self.value.new_result,
                                        Some("cdf:new-result"),
                                        false,
                                    )?,
                                )
                            }
                        },
                        OverrideTypeSerializerState::NewResult(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    OverrideTypeSerializerState::Remark(WithSerializer::serializer(
                                        &self.value.remark,
                                        Some("cdf:remark"),
                                        false,
                                    )?)
                            }
                        },
                        OverrideTypeSerializerState::Remark(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = OverrideTypeSerializerState::End__,
                        },
                        OverrideTypeSerializerState::End__ => {
                            *self.state = OverrideTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        OverrideTypeSerializerState::Done__ => return Ok(None),
                        OverrideTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for OverrideTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OverrideTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct MessageTypeSerializer<'ser> {
            pub(super) value: &'ser super::MessageType,
            pub(super) state: Box<MessageTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum MessageTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> MessageTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        MessageTypeSerializerState::Init__ => {
                            *self.state = MessageTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "severity", &self.value.severity)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        MessageTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = MessageTypeSerializerState::End__,
                        },
                        MessageTypeSerializerState::End__ => {
                            *self.state = MessageTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        MessageTypeSerializerState::Done__ => return Ok(None),
                        MessageTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for MessageTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = MessageTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct InstanceResultTypeSerializer<'ser> {
            pub(super) value: &'ser super::InstanceResultType,
            pub(super) state: Box<InstanceResultTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum InstanceResultTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> InstanceResultTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        InstanceResultTypeSerializerState::Init__ => {
                            *self.state = InstanceResultTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "context", &self.value.context)?;
                            write_attrib_opt(
                                &mut bytes,
                                "parentContext",
                                &self.value.parent_context,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        InstanceResultTypeSerializerState::Content__(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = InstanceResultTypeSerializerState::End__,
                            }
                        }
                        InstanceResultTypeSerializerState::End__ => {
                            *self.state = InstanceResultTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        InstanceResultTypeSerializerState::Done__ => return Ok(None),
                        InstanceResultTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for InstanceResultTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = InstanceResultTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod cpe {
    use std::borrow::Cow;
    use xsd_parser::quick_xml::{
        DeserializeBytes, DeserializeReader, Error, ErrorKind, RawByteStr, SerializeBytes,
        WithDeserializer, WithSerializer,
    };
    #[derive(Debug)]
    pub struct PlatformSpecificationType {
        pub platform: Vec<PlatformType>,
    }
    impl WithSerializer for PlatformSpecificationType {
        type Serializer<'x> = quick_xml_serialize::PlatformSpecificationTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PlatformSpecificationTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PlatformSpecificationTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("cpe:platformSpecificationType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PlatformSpecificationType {
        type Deserializer = quick_xml_deserialize::PlatformSpecificationTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct PlatformType {
        ///A locally unique name for the platform. There is no defined
        ///format for this id; however, it must be unique within the containing CPE Applicability
        ///Language document.
        pub id: String,
        ///A human-readable title for a platform. To support uses intended for
        ///multiple languages, the title element supports the ‘xml:lang’ attribute. At most one title
        ///element can appear for each language.
        pub title: Vec<TextType>,
        ///An additional description. To support uses intended for multiple
        ///languages, the remark element supports the ‘xml:lang’ attribute. There can be multiple remarks
        ///for a single language.
        pub remark: Vec<TextType>,
        ///Definition of test using logical operators (AND, OR,
        ///negate).
        pub logical_test: LogicalTestType,
    }
    impl WithSerializer for PlatformType {
        type Serializer<'x> = quick_xml_serialize::PlatformTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PlatformTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::PlatformTypeSerializerState::Init__),
                name: name.unwrap_or("cpe:PlatformType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PlatformType {
        type Deserializer = quick_xml_deserialize::PlatformTypeDeserializer;
    }
    ///This type allows the xml:lang attribute to associate a specific language
    ///with an element's string content.
    #[derive(Debug)]
    pub struct TextType {
        pub lang: Option<String>,
        pub content: String,
    }
    impl WithSerializer for TextType {
        type Serializer<'x> = quick_xml_serialize::TextTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::TextTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::TextTypeSerializerState::Init__),
                name: name.unwrap_or("cpe:TextType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for TextType {
        type Deserializer = quick_xml_deserialize::TextTypeDeserializer;
    }
    ///The logical-test element appears as a child of a platform element, and may
    ///also be nested to create more complex logical tests. The content consists of one or more elements:
    ///fact-ref, check-fact-ref, and logical-test children are permitted. The operator to be applied, and
    ///optional negation of the test, are given as attributes.
    #[derive(Debug)]
    pub struct LogicalTestType {
        ///The operator applied to the results of evaluating the fact-ref,
        ///check-fact-ref, and logical-test elements. The permitted operators are "AND" and
        ///"OR".
        pub operator: OperatorEnumerationType,
        ///Whether the result of applying the operator should be negated. Possible
        ///values are "TRUE" and "FALSE". This does not apply if the initial result is
        ///ERROR.
        pub negate: bool,
        ///Definition of complex logical test using AND, OR, and/or negate
        ///operators. Evaluates to a TRUE, FALSE, or ERROR result.
        pub logical_test: Vec<LogicalTestType>,
        ///A reference to a bound form of a WFN; the reference always
        ///evaluates to a boolean result. The bound name contained within a fact-ref is meant to describe a
        ///possible set of products and is not meant to identify a unique product
        ///class.
        pub fact_ref: Vec<CpeFactRefType>,
        ///A reference to a check that always evaluates to TRUE, FALSE, or
        ///ERROR. Examples of types of checks are OVAL and OCIL checks.
        pub check_fact_ref: Vec<CheckFactRefType>,
    }
    impl WithSerializer for LogicalTestType {
        type Serializer<'x> = quick_xml_serialize::LogicalTestTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::LogicalTestTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::LogicalTestTypeSerializerState::Init__),
                name: name.unwrap_or("cpe:LogicalTestType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for LogicalTestType {
        type Deserializer = quick_xml_deserialize::LogicalTestTypeDeserializer;
    }
    ///The OperatorEnumeration simple type defines acceptable operators. Each
    ///operator defines how to evaluate multiple arguments.
    #[derive(Debug)]
    pub enum OperatorEnumerationType {
        And,
        Or,
    }
    impl SerializeBytes for OperatorEnumerationType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::And => Ok(Some(Cow::Borrowed("AND"))),
                Self::Or => Ok(Some(Cow::Borrowed("OR"))),
            }
        }
    }
    impl DeserializeBytes for OperatorEnumerationType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            match bytes {
                b"AND" => Ok(Self::And),
                b"OR" => Ok(Self::Or),
                x => {
                    Err(reader
                        .map_error(ErrorKind::UnknownOrInvalidValue(RawByteStr::from_slice(x))))
                }
            }
        }
    }
    ///A reference to a CPE Name that always evaluates to a Boolean
    ///result.
    #[derive(Debug)]
    pub struct CpeFactRefType {
        pub description: Option<String>,
        pub name: String,
    }
    impl WithSerializer for CpeFactRefType {
        type Serializer<'x> = quick_xml_serialize::CpeFactRefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CpeFactRefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CpeFactRefTypeSerializerState::Init__),
                name: name.unwrap_or("cpe:CPEFactRefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CpeFactRefType {
        type Deserializer = quick_xml_deserialize::CpeFactRefTypeDeserializer;
    }
    ///A reference to a check that always evaluates to a TRUE, FALSE, or ERROR
    ///result.
    ///The CheckFactRefType complex type is used to define an element for holding
    ///information about an individual check. It includes a checking system specification URI, string content
    ///identifying the check content to invoke, and an external reference. The checking system specification
    ///should be the URI that uniquely identifies a revision of a check system language, and the id-ref will be
    ///an identifier of a test written in that language. The external reference should be used to point to the
    ///content in which the check identifier is defined.
    #[derive(Debug)]
    pub struct CheckFactRefType {
        pub description: Option<String>,
        pub system: String,
        pub href: String,
        pub id_ref: String,
    }
    impl WithSerializer for CheckFactRefType {
        type Serializer<'x> = quick_xml_serialize::CheckFactRefTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CheckFactRefTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CheckFactRefTypeSerializerState::Init__),
                name: name.unwrap_or("cpe:CheckFactRefType"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CheckFactRefType {
        type Deserializer = quick_xml_deserialize::CheckFactRefTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser::quick_xml::{
            filter_xmlns_attributes, BytesStart, ContentDeserializer, DeserializeReader,
            Deserializer, DeserializerArtifact, DeserializerEvent, DeserializerOutput,
            DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr,
            WithDeserializer,
        };
        #[derive(Debug)]
        pub struct PlatformSpecificationTypeDeserializer {
            platform: Vec<super::PlatformType>,
            state: Box<PlatformSpecificationTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PlatformSpecificationTypeDeserializerState {
            Init__,
            Platform(Option<<super::PlatformType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl PlatformSpecificationTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    reader.raise_unexpected_attrib_checked(attrib)?;
                }
                Ok(Self {
                    platform: Vec::new(),
                    state: Box::new(PlatformSpecificationTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: PlatformSpecificationTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use PlatformSpecificationTypeDeserializerState as S;
                match state {
                    S::Platform(Some(deserializer)) => {
                        self.store_platform(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_platform(&mut self, value: super::PlatformType) -> Result<(), Error> {
                self.platform.push(value);
                Ok(())
            }
            fn handle_platform<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::PlatformType>,
                fallback: &mut Option<PlatformSpecificationTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.platform.len() < 1usize {
                        *self.state = PlatformSpecificationTypeDeserializerState::Platform(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        fallback.get_or_insert(
                            PlatformSpecificationTypeDeserializerState::Platform(None),
                        );
                        *self.state = PlatformSpecificationTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_platform(data)?;
                        *self.state = PlatformSpecificationTypeDeserializerState::Platform(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    PlatformSpecificationTypeDeserializerState::Platform(Some(
                                        deserializer,
                                    )),
                                );
                                if self.platform.len().saturating_add(1) < 1usize {
                                    *self.state =
                                        PlatformSpecificationTypeDeserializerState::Platform(None);
                                } else {
                                    *self.state =
                                        PlatformSpecificationTypeDeserializerState::Done__;
                                }
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = PlatformSpecificationTypeDeserializerState::Platform(
                                    Some(deserializer),
                                );
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::PlatformSpecificationType>
            for PlatformSpecificationTypeDeserializer
        {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlatformSpecificationType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlatformSpecificationType>
            where
                R: DeserializeReader,
            {
                use PlatformSpecificationTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Platform(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_platform(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state =
                                PlatformSpecificationTypeDeserializerState::Platform(None);
                            event
                        }
                        (S::Platform(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"platform",
                                false,
                            )?;
                            match self.handle_platform(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::PlatformSpecificationType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    PlatformSpecificationTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::PlatformSpecificationType {
                    platform: self.platform,
                })
            }
        }
        #[derive(Debug)]
        pub struct PlatformTypeDeserializer {
            id: String,
            title: Vec<super::TextType>,
            remark: Vec<super::TextType>,
            logical_test: Option<super::LogicalTestType>,
            state: Box<PlatformTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PlatformTypeDeserializerState {
            Init__,
            Title(Option<<super::TextType as WithDeserializer>::Deserializer>),
            Remark(Option<<super::TextType as WithDeserializer>::Deserializer>),
            LogicalTest(Option<<super::LogicalTestType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl PlatformTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut id: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"id")
                    ) {
                        reader.read_attrib(&mut id, b"id", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id".into()))
                    })?,
                    title: Vec::new(),
                    remark: Vec::new(),
                    logical_test: None,
                    state: Box::new(PlatformTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: PlatformTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use PlatformTypeDeserializerState as S;
                match state {
                    S::Title(Some(deserializer)) => {
                        self.store_title(deserializer.finish(reader)?)?
                    }
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(reader)?)?
                    }
                    S::LogicalTest(Some(deserializer)) => {
                        self.store_logical_test(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_title(&mut self, value: super::TextType) -> Result<(), Error> {
                self.title.push(value);
                Ok(())
            }
            fn store_remark(&mut self, value: super::TextType) -> Result<(), Error> {
                self.remark.push(value);
                Ok(())
            }
            fn store_logical_test(&mut self, value: super::LogicalTestType) -> Result<(), Error> {
                if self.logical_test.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"logical-test",
                    )))?;
                }
                self.logical_test = Some(value);
                Ok(())
            }
            fn handle_title<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<PlatformTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(PlatformTypeDeserializerState::Title(None));
                    *self.state = PlatformTypeDeserializerState::Remark(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_title(data)?;
                        *self.state = PlatformTypeDeserializerState::Title(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(PlatformTypeDeserializerState::Title(Some(
                                    deserializer,
                                )));
                                *self.state = PlatformTypeDeserializerState::Title(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    PlatformTypeDeserializerState::Title(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_remark<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::TextType>,
                fallback: &mut Option<PlatformTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(PlatformTypeDeserializerState::Remark(None));
                    *self.state = PlatformTypeDeserializerState::LogicalTest(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state = PlatformTypeDeserializerState::Remark(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(PlatformTypeDeserializerState::Remark(
                                    Some(deserializer),
                                ));
                                *self.state = PlatformTypeDeserializerState::Remark(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    PlatformTypeDeserializerState::Remark(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_logical_test<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::LogicalTestType>,
                fallback: &mut Option<PlatformTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if self.logical_test.is_some() {
                        fallback.get_or_insert(PlatformTypeDeserializerState::LogicalTest(None));
                        *self.state = PlatformTypeDeserializerState::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    } else {
                        *self.state = PlatformTypeDeserializerState::LogicalTest(None);
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_logical_test(data)?;
                        *self.state = PlatformTypeDeserializerState::Done__;
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(PlatformTypeDeserializerState::LogicalTest(
                                    Some(deserializer),
                                ));
                                *self.state = PlatformTypeDeserializerState::Done__;
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    PlatformTypeDeserializerState::LogicalTest(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::PlatformType> for PlatformTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlatformType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PlatformType>
            where
                R: DeserializeReader,
            {
                use PlatformTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::Title(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_title(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::LogicalTest(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_logical_test(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = PlatformTypeDeserializerState::Title(None);
                            event
                        }
                        (S::Title(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"title",
                                false,
                            )?;
                            match self.handle_title(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"remark",
                                false,
                            )?;
                            match self.handle_remark(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::LogicalTest(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"logical-test",
                                false,
                            )?;
                            match self.handle_logical_test(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::PlatformType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, PlatformTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::PlatformType {
                    id: self.id,
                    title: self.title,
                    remark: self.remark,
                    logical_test: self
                        .logical_test
                        .ok_or_else(|| ErrorKind::MissingElement("logical-test".into()))?,
                })
            }
        }
        #[derive(Debug)]
        pub struct TextTypeDeserializer {
            lang: Option<String>,
            content: Option<String>,
            state: Box<TextTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum TextTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl TextTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut lang: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_XML),
                        Some(b"lang")
                    ) {
                        reader.read_attrib(&mut lang, b"lang", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    lang: lang,
                    content: None,
                    state: Box::new(TextTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: TextTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                if let TextTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(reader)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de, R>(
                mut self,
                reader: &R,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                use TextTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(reader)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::TextType> for TextTypeDeserializer {
            fn init<R>(reader: &R, event: Event<'de>) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(reader, x)?.next(reader, event)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::TextType>
            where
                R: DeserializeReader,
            {
                use TextTypeDeserializerState as S;
                match replace(&mut *self.state, S::Unknown__) {
                    S::Init__ => {
                        let output = ContentDeserializer::init(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(reader, event)?;
                        self.handle_content(reader, output)
                    }
                    S::Unknown__ => unreachable!(),
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::TextType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, TextTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::TextType {
                    lang: self.lang,
                    content: self.content.ok_or_else(|| ErrorKind::MissingContent)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct LogicalTestTypeDeserializer {
            operator: super::OperatorEnumerationType,
            negate: bool,
            logical_test: Vec<super::LogicalTestType>,
            fact_ref: Vec<super::CpeFactRefType>,
            check_fact_ref: Vec<super::CheckFactRefType>,
            state: Box<LogicalTestTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum LogicalTestTypeDeserializerState {
            Init__,
            LogicalTest(Option<<super::LogicalTestType as WithDeserializer>::Deserializer>),
            FactRef(Option<<super::CpeFactRefType as WithDeserializer>::Deserializer>),
            CheckFactRef(Option<<super::CheckFactRefType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl LogicalTestTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut operator: Option<super::OperatorEnumerationType> = None;
                let mut negate: Option<bool> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"operator")
                    ) {
                        reader.read_attrib(&mut operator, b"operator", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"negate")
                    ) {
                        reader.read_attrib(&mut negate, b"negate", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    operator: operator.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("operator".into()))
                    })?,
                    negate: negate.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("negate".into()))
                    })?,
                    logical_test: Vec::new(),
                    fact_ref: Vec::new(),
                    check_fact_ref: Vec::new(),
                    state: Box::new(LogicalTestTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: LogicalTestTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                use LogicalTestTypeDeserializerState as S;
                match state {
                    S::LogicalTest(Some(deserializer)) => {
                        self.store_logical_test(deserializer.finish(reader)?)?
                    }
                    S::FactRef(Some(deserializer)) => {
                        self.store_fact_ref(deserializer.finish(reader)?)?
                    }
                    S::CheckFactRef(Some(deserializer)) => {
                        self.store_check_fact_ref(deserializer.finish(reader)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_logical_test(&mut self, value: super::LogicalTestType) -> Result<(), Error> {
                self.logical_test.push(value);
                Ok(())
            }
            fn store_fact_ref(&mut self, value: super::CpeFactRefType) -> Result<(), Error> {
                self.fact_ref.push(value);
                Ok(())
            }
            fn store_check_fact_ref(
                &mut self,
                value: super::CheckFactRefType,
            ) -> Result<(), Error> {
                self.check_fact_ref.push(value);
                Ok(())
            }
            fn handle_logical_test<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::LogicalTestType>,
                fallback: &mut Option<LogicalTestTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(LogicalTestTypeDeserializerState::LogicalTest(None));
                    *self.state = LogicalTestTypeDeserializerState::FactRef(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_logical_test(data)?;
                        *self.state = LogicalTestTypeDeserializerState::LogicalTest(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    LogicalTestTypeDeserializerState::LogicalTest(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = LogicalTestTypeDeserializerState::LogicalTest(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = LogicalTestTypeDeserializerState::LogicalTest(Some(
                                    deserializer,
                                ));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_fact_ref<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CpeFactRefType>,
                fallback: &mut Option<LogicalTestTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(LogicalTestTypeDeserializerState::FactRef(None));
                    *self.state = LogicalTestTypeDeserializerState::CheckFactRef(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fact_ref(data)?;
                        *self.state = LogicalTestTypeDeserializerState::FactRef(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(LogicalTestTypeDeserializerState::FactRef(
                                    Some(deserializer),
                                ));
                                *self.state = LogicalTestTypeDeserializerState::FactRef(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state =
                                    LogicalTestTypeDeserializerState::FactRef(Some(deserializer));
                            }
                        }
                        ret
                    }
                })
            }
            fn handle_check_fact_ref<'de, R>(
                &mut self,
                reader: &R,
                output: DeserializerOutput<'de, super::CheckFactRefType>,
                fallback: &mut Option<LogicalTestTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error>
            where
                R: DeserializeReader,
            {
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(LogicalTestTypeDeserializerState::CheckFactRef(None));
                    *self.state = LogicalTestTypeDeserializerState::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(reader, fallback)?;
                }
                Ok(match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_fact_ref(data)?;
                        *self.state = LogicalTestTypeDeserializerState::CheckFactRef(None);
                        ElementHandlerOutput::from_event(event, allow_any)
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        let ret = ElementHandlerOutput::from_event(event, allow_any);
                        match &ret {
                            ElementHandlerOutput::Continue { .. } => {
                                fallback.get_or_insert(
                                    LogicalTestTypeDeserializerState::CheckFactRef(Some(
                                        deserializer,
                                    )),
                                );
                                *self.state = LogicalTestTypeDeserializerState::CheckFactRef(None);
                            }
                            ElementHandlerOutput::Break { .. } => {
                                *self.state = LogicalTestTypeDeserializerState::CheckFactRef(Some(
                                    deserializer,
                                ));
                            }
                        }
                        ret
                    }
                })
            }
        }
        impl<'de> Deserializer<'de, super::LogicalTestType> for LogicalTestTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::LogicalTestType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::LogicalTestType>
            where
                R: DeserializeReader,
            {
                use LogicalTestTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state, S::Unknown__);
                    event = match (state, event) {
                        (S::LogicalTest(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_logical_test(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FactRef(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_fact_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckFactRef(Some(deserializer)), event) => {
                            let output = deserializer.next(reader, event)?;
                            match self.handle_check_fact_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(reader, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(reader)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state = LogicalTestTypeDeserializerState::LogicalTest(None);
                            event
                        }
                        (S::LogicalTest(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"logical-test",
                                false,
                            )?;
                            match self.handle_logical_test(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FactRef(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"fact-ref",
                                false,
                            )?;
                            match self.handle_fact_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CheckFactRef(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = reader.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_CPE),
                                b"check-fact-ref",
                                false,
                            )?;
                            match self.handle_check_fact_ref(reader, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            fallback.get_or_insert(S::Done__);
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (S::Unknown__, _) => unreachable!(),
                        (state, event) => {
                            *self.state = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::LogicalTestType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    LogicalTestTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::LogicalTestType {
                    operator: self.operator,
                    negate: self.negate,
                    logical_test: self.logical_test,
                    fact_ref: self.fact_ref,
                    check_fact_ref: self.check_fact_ref,
                })
            }
        }
        #[derive(Debug)]
        pub struct CpeFactRefTypeDeserializer {
            description: Option<String>,
            name: String,
            state: Box<CpeFactRefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CpeFactRefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CpeFactRefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut description: Option<String> = None;
                let mut name: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"description")
                    ) {
                        reader.read_attrib(&mut description, b"description", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"name")
                    ) {
                        reader.read_attrib(&mut name, b"name", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    description: description,
                    name: name.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("name".into()))
                    })?,
                    state: Box::new(CpeFactRefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CpeFactRefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CpeFactRefType> for CpeFactRefTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CpeFactRefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CpeFactRefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CpeFactRefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(&mut *self.state, CpeFactRefTypeDeserializerState::Unknown__);
                self.finish_state(reader, state)?;
                Ok(super::CpeFactRefType {
                    description: self.description,
                    name: self.name,
                })
            }
        }
        #[derive(Debug)]
        pub struct CheckFactRefTypeDeserializer {
            description: Option<String>,
            system: String,
            href: String,
            id_ref: String,
            state: Box<CheckFactRefTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CheckFactRefTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CheckFactRefTypeDeserializer {
            fn from_bytes_start<R>(reader: &R, bytes_start: &BytesStart<'_>) -> Result<Self, Error>
            where
                R: DeserializeReader,
            {
                let mut description: Option<String> = None;
                let mut system: Option<String> = None;
                let mut href: Option<String> = None;
                let mut id_ref: Option<String> = None;
                for attrib in filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"description")
                    ) {
                        reader.read_attrib(&mut description, b"description", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"system")
                    ) {
                        reader.read_attrib(&mut system, b"system", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"href")
                    ) {
                        reader.read_attrib(&mut href, b"href", &attrib.value)?;
                    } else if matches!(
                        reader.resolve_local_name(attrib.key, &super::super::NS_CPE),
                        Some(b"id-ref")
                    ) {
                        reader.read_attrib(&mut id_ref, b"id-ref", &attrib.value)?;
                    } else {
                        reader.raise_unexpected_attrib_checked(attrib)?;
                    }
                }
                Ok(Self {
                    description: description,
                    system: system.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("system".into()))
                    })?,
                    href: href.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("href".into()))
                    })?,
                    id_ref: id_ref.ok_or_else(|| {
                        reader.map_error(ErrorKind::MissingAttribute("id-ref".into()))
                    })?,
                    state: Box::new(CheckFactRefTypeDeserializerState::Init__),
                })
            }
            fn finish_state<R>(
                &mut self,
                reader: &R,
                state: CheckFactRefTypeDeserializerState,
            ) -> Result<(), Error>
            where
                R: DeserializeReader,
            {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CheckFactRefType> for CheckFactRefTypeDeserializer {
            fn init<R>(
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckFactRefType>
            where
                R: DeserializeReader,
            {
                reader.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next<R>(
                mut self,
                reader: &R,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CheckFactRefType>
            where
                R: DeserializeReader,
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(reader)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish<R>(mut self, reader: &R) -> Result<super::CheckFactRefType, Error>
            where
                R: DeserializeReader,
            {
                let state = replace(
                    &mut *self.state,
                    CheckFactRefTypeDeserializerState::Unknown__,
                );
                self.finish_state(reader, state)?;
                Ok(super::CheckFactRefType {
                    description: self.description,
                    system: self.system,
                    href: self.href,
                    id_ref: self.id_ref,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use core::iter::Iterator;
        use xsd_parser::quick_xml::{
            write_attrib, write_attrib_opt, BytesEnd, BytesStart, Error, Event, IterSerializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct PlatformSpecificationTypeSerializer<'ser> {
            pub(super) value: &'ser super::PlatformSpecificationType,
            pub(super) state: Box<PlatformSpecificationTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PlatformSpecificationTypeSerializerState<'ser> {
            Init__,
            Platform(IterSerializer<'ser, &'ser [super::PlatformType], super::PlatformType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PlatformSpecificationTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PlatformSpecificationTypeSerializerState::Init__ => {
                            *self.state = PlatformSpecificationTypeSerializerState::Platform(
                                IterSerializer::new(
                                    &self.value.platform[..],
                                    Some("cpe:platform"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PlatformSpecificationTypeSerializerState::Platform(x) => match x
                            .next()
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PlatformSpecificationTypeSerializerState::End__,
                        },
                        PlatformSpecificationTypeSerializerState::End__ => {
                            *self.state = PlatformSpecificationTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PlatformSpecificationTypeSerializerState::Done__ => return Ok(None),
                        PlatformSpecificationTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for PlatformSpecificationTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PlatformSpecificationTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PlatformTypeSerializer<'ser> {
            pub(super) value: &'ser super::PlatformType,
            pub(super) state: Box<PlatformTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PlatformTypeSerializerState<'ser> {
            Init__,
            Title(IterSerializer<'ser, &'ser [super::TextType], super::TextType>),
            Remark(IterSerializer<'ser, &'ser [super::TextType], super::TextType>),
            LogicalTest(<super::LogicalTestType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PlatformTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PlatformTypeSerializerState::Init__ => {
                            *self.state = PlatformTypeSerializerState::Title(IterSerializer::new(
                                &self.value.title[..],
                                Some("cpe:title"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "id", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PlatformTypeSerializerState::Title(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    PlatformTypeSerializerState::Remark(IterSerializer::new(
                                        &self.value.remark[..],
                                        Some("cpe:remark"),
                                        false,
                                    ))
                            }
                        },
                        PlatformTypeSerializerState::Remark(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = PlatformTypeSerializerState::LogicalTest(
                                    WithSerializer::serializer(
                                        &self.value.logical_test,
                                        Some("cpe:logical-test"),
                                        false,
                                    )?,
                                )
                            }
                        },
                        PlatformTypeSerializerState::LogicalTest(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = PlatformTypeSerializerState::End__,
                            }
                        }
                        PlatformTypeSerializerState::End__ => {
                            *self.state = PlatformTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PlatformTypeSerializerState::Done__ => return Ok(None),
                        PlatformTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for PlatformTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PlatformTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct TextTypeSerializer<'ser> {
            pub(super) value: &'ser super::TextType,
            pub(super) state: Box<TextTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum TextTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> TextTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        TextTypeSerializerState::Init__ => {
                            *self.state = TextTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "lang", &self.value.lang)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        TextTypeSerializerState::Content__(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = TextTypeSerializerState::End__,
                        },
                        TextTypeSerializerState::End__ => {
                            *self.state = TextTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        TextTypeSerializerState::Done__ => return Ok(None),
                        TextTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for TextTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = TextTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct LogicalTestTypeSerializer<'ser> {
            pub(super) value: &'ser super::LogicalTestType,
            pub(super) state: Box<LogicalTestTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum LogicalTestTypeSerializerState<'ser> {
            Init__,
            LogicalTest(
                IterSerializer<'ser, &'ser [super::LogicalTestType], super::LogicalTestType>,
            ),
            FactRef(IterSerializer<'ser, &'ser [super::CpeFactRefType], super::CpeFactRefType>),
            CheckFactRef(
                IterSerializer<'ser, &'ser [super::CheckFactRefType], super::CheckFactRefType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> LogicalTestTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        LogicalTestTypeSerializerState::Init__ => {
                            *self.state =
                                LogicalTestTypeSerializerState::LogicalTest(IterSerializer::new(
                                    &self.value.logical_test[..],
                                    Some("cpe:logical-test"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib(&mut bytes, "operator", &self.value.operator)?;
                            write_attrib(&mut bytes, "negate", &self.value.negate)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        LogicalTestTypeSerializerState::LogicalTest(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = LogicalTestTypeSerializerState::FactRef(
                                        IterSerializer::new(
                                            &self.value.fact_ref[..],
                                            Some("cpe:fact-ref"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        LogicalTestTypeSerializerState::FactRef(x) => match x.next().transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state = LogicalTestTypeSerializerState::CheckFactRef(
                                    IterSerializer::new(
                                        &self.value.check_fact_ref[..],
                                        Some("cpe:check-fact-ref"),
                                        false,
                                    ),
                                )
                            }
                        },
                        LogicalTestTypeSerializerState::CheckFactRef(x) => {
                            match x.next().transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = LogicalTestTypeSerializerState::End__,
                            }
                        }
                        LogicalTestTypeSerializerState::End__ => {
                            *self.state = LogicalTestTypeSerializerState::Done__;
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        LogicalTestTypeSerializerState::Done__ => return Ok(None),
                        LogicalTestTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for LogicalTestTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = LogicalTestTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CpeFactRefTypeSerializer<'ser> {
            pub(super) value: &'ser super::CpeFactRefType,
            pub(super) state: Box<CpeFactRefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CpeFactRefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CpeFactRefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CpeFactRefTypeSerializerState::Init__ => {
                            *self.state = CpeFactRefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "description", &self.value.description)?;
                            write_attrib(&mut bytes, "name", &self.value.name)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CpeFactRefTypeSerializerState::Done__ => return Ok(None),
                        CpeFactRefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CpeFactRefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CpeFactRefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CheckFactRefTypeSerializer<'ser> {
            pub(super) value: &'ser super::CheckFactRefType,
            pub(super) state: Box<CheckFactRefTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CheckFactRefTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CheckFactRefTypeSerializer<'ser> {
            fn next_event(&mut self) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CheckFactRefTypeSerializerState::Init__ => {
                            *self.state = CheckFactRefTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            if self.is_root {
                                bytes
                                    .push_attribute((&b"xmlns:cdf"[..], &super::super::NS_CDF[..]));
                                bytes
                                    .push_attribute((&b"xmlns:cpe"[..], &super::super::NS_CPE[..]));
                                bytes.push_attribute((
                                    &b"xmlns:cpe_4"[..],
                                    &super::super::NS_CPE_4[..],
                                ));
                            }
                            write_attrib_opt(&mut bytes, "description", &self.value.description)?;
                            write_attrib(&mut bytes, "system", &self.value.system)?;
                            write_attrib(&mut bytes, "href", &self.value.href)?;
                            write_attrib(&mut bytes, "id-ref", &self.value.id_ref)?;
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CheckFactRefTypeSerializerState::Done__ => return Ok(None),
                        CheckFactRefTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Iterator for CheckFactRefTypeSerializer<'ser> {
            type Item = Result<Event<'ser>, Error>;
            fn next(&mut self) -> Option<Self::Item> {
                match self.next_event() {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CheckFactRefTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod xs {
    use std::borrow::Cow;
    use xsd_parser::quick_xml::{DeserializeBytes, DeserializeReader, Error, SerializeBytes};
    #[derive(Debug, Default)]
    pub struct EntitiesType(pub Vec<String>);
    impl SerializeBytes for EntitiesType {
        fn serialize_bytes(&self) -> Result<Option<Cow<'_, str>>, Error> {
            if self.0.is_empty() {
                return Ok(None);
            }
            let mut data = String::new();
            for item in &self.0 {
                if let Some(bytes) = item.serialize_bytes()? {
                    if !data.is_empty() {
                        data.push(' ');
                    }
                    data.push_str(&bytes);
                }
            }
            Ok(Some(Cow::Owned(data)))
        }
    }
    impl DeserializeBytes for EntitiesType {
        fn deserialize_bytes<R>(reader: &R, bytes: &[u8]) -> Result<Self, Error>
        where
            R: DeserializeReader,
        {
            Ok(Self(
                bytes
                    .split(|b| *b == b' ' || *b == b'|' || *b == b',' || *b == b';')
                    .map(|bytes| String::deserialize_bytes(reader, bytes))
                    .collect::<Result<Vec<_>, _>>()?,
            ))
        }
    }
}
