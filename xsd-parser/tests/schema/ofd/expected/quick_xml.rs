use xsd_parser_types::misc::{Namespace, NamespacePrefix};
pub const NS_XS: Namespace = Namespace::new_const(b"http://www.w3.org/2001/XMLSchema");
pub const NS_XML: Namespace = Namespace::new_const(b"http://www.w3.org/XML/1998/namespace");
pub const NS_UNNAMED_2: Namespace = Namespace::new_const(b"http://www.ofdspec.org/2016");
pub const PREFIX_XS: NamespacePrefix = NamespacePrefix::new_const(b"xs");
pub const PREFIX_XML: NamespacePrefix = NamespacePrefix::new_const(b"xml");
pub mod annotations {
    use xsd_parser_types::quick_xml::{Error, WithDeserializer, WithSerializer};
    pub type Annotations = AnnotationsXElementType;
    #[derive(Debug)]
    pub struct AnnotationsXElementType {
        pub page: Vec<AnnotationsPageXElementType>,
    }
    impl WithSerializer for AnnotationsXElementType {
        type Serializer<'x> = quick_xml_serialize::AnnotationsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::AnnotationsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::AnnotationsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("Annotations"),
                is_root,
            })
        }
    }
    impl WithDeserializer for AnnotationsXElementType {
        type Deserializer = quick_xml_deserialize::AnnotationsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct AnnotationsPageXElementType {
        pub page_id: u32,
        pub file_loc: String,
    }
    impl WithSerializer for AnnotationsPageXElementType {
        type Serializer<'x> = quick_xml_serialize::AnnotationsPageXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::AnnotationsPageXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::AnnotationsPageXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("AnnotationsPage"),
                is_root,
            })
        }
    }
    impl WithDeserializer for AnnotationsPageXElementType {
        type Deserializer = quick_xml_deserialize::AnnotationsPageXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct AnnotationsXElementTypeDeserializer {
            page: Vec<super::AnnotationsPageXElementType>,
            state__: Box<AnnotationsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum AnnotationsXElementTypeDeserializerState {
            Init__,
            Page(Option<<super::AnnotationsPageXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl AnnotationsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    page: Vec::new(),
                    state__: Box::new(AnnotationsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: AnnotationsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use AnnotationsXElementTypeDeserializerState as S;
                match state {
                    S::Page(Some(deserializer)) => self.store_page(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_page(
                &mut self,
                value: super::AnnotationsPageXElementType,
            ) -> Result<(), Error> {
                self.page.push(value);
                Ok(())
            }
            fn handle_page<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::AnnotationsPageXElementType>,
                fallback: &mut Option<AnnotationsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use AnnotationsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Page(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_page(data)?;
                        *self.state__ = S::Page(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Page(Some(deserializer)));
                        *self.state__ = S::Page(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::AnnotationsXElementType>
            for AnnotationsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnnotationsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnnotationsXElementType> {
                use AnnotationsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Page(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Page(None);
                            event
                        }
                        (S::Page(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Page",
                                false,
                            )?;
                            match self.handle_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::AnnotationsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    AnnotationsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::AnnotationsXElementType { page: self.page })
            }
        }
        #[derive(Debug)]
        pub struct AnnotationsPageXElementTypeDeserializer {
            page_id: u32,
            file_loc: Option<String>,
            state__: Box<AnnotationsPageXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum AnnotationsPageXElementTypeDeserializerState {
            Init__,
            FileLoc(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl AnnotationsPageXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut page_id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"PageID")
                    ) {
                        helper.read_attrib(&mut page_id, b"PageID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    page_id: page_id.ok_or_else(|| ErrorKind::MissingAttribute("PageID".into()))?,
                    file_loc: None,
                    state__: Box::new(AnnotationsPageXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: AnnotationsPageXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use AnnotationsPageXElementTypeDeserializerState as S;
                match state {
                    S::FileLoc(Some(deserializer)) => {
                        self.store_file_loc(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
                if self.file_loc.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FileLoc",
                    )))?;
                }
                self.file_loc = Some(value);
                Ok(())
            }
            fn handle_file_loc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<AnnotationsPageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use AnnotationsPageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FileLoc(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_file_loc(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FileLoc(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::AnnotationsPageXElementType>
            for AnnotationsPageXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnnotationsPageXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AnnotationsPageXElementType> {
                use AnnotationsPageXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FileLoc(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FileLoc(None);
                            event
                        }
                        (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FileLoc",
                                false,
                            )?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::AnnotationsPageXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    AnnotationsPageXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::AnnotationsPageXElementType {
                    page_id: self.page_id,
                    file_loc: helper.finish_element("FileLoc", self.file_loc)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct AnnotationsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::AnnotationsXElementType,
            pub(super) state: Box<AnnotationsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum AnnotationsXElementTypeSerializerState<'ser> {
            Init__,
            Page(
                IterSerializer<
                    'ser,
                    &'ser [super::AnnotationsPageXElementType],
                    super::AnnotationsPageXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> AnnotationsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        AnnotationsXElementTypeSerializerState::Init__ => {
                            *self.state = AnnotationsXElementTypeSerializerState::Page(
                                IterSerializer::new(&self.value.page[..], Some("Page"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        AnnotationsXElementTypeSerializerState::Page(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = AnnotationsXElementTypeSerializerState::End__,
                            }
                        }
                        AnnotationsXElementTypeSerializerState::End__ => {
                            *self.state = AnnotationsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        AnnotationsXElementTypeSerializerState::Done__ => return Ok(None),
                        AnnotationsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for AnnotationsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = AnnotationsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct AnnotationsPageXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::AnnotationsPageXElementType,
            pub(super) state: Box<AnnotationsPageXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum AnnotationsPageXElementTypeSerializerState<'ser> {
            Init__,
            FileLoc(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> AnnotationsPageXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        AnnotationsPageXElementTypeSerializerState::Init__ => {
                            *self.state = AnnotationsPageXElementTypeSerializerState::FileLoc(
                                WithSerializer::serializer(
                                    &self.value.file_loc,
                                    Some("FileLoc"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "PageID", &self.value.page_id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        AnnotationsPageXElementTypeSerializerState::FileLoc(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = AnnotationsPageXElementTypeSerializerState::End__,
                        },
                        AnnotationsPageXElementTypeSerializerState::End__ => {
                            *self.state = AnnotationsPageXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        AnnotationsPageXElementTypeSerializerState::Done__ => return Ok(None),
                        AnnotationsPageXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for AnnotationsPageXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = AnnotationsPageXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod annotion {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    pub type PageAnnot = PageAnnotXElementType;
    #[derive(Debug)]
    pub struct PageAnnotXElementType {
        pub annot: Vec<PageAnnotAnnotXElementType>,
    }
    impl WithSerializer for PageAnnotXElementType {
        type Serializer<'x> = quick_xml_serialize::PageAnnotXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PageAnnotXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::PageAnnotXElementTypeSerializerState::Init__),
                name: name.unwrap_or("PageAnnot"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PageAnnotXElementType {
        type Deserializer = quick_xml_deserialize::PageAnnotXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotXElementType {
        pub id: u32,
        pub type_: PageAnnotAnnotTypeXType,
        pub creator: String,
        pub last_mod_date: String,
        pub visible: bool,
        pub subtype: Option<String>,
        pub print: bool,
        pub no_zoom: bool,
        pub no_rotate: bool,
        pub read_only: bool,
        pub remark: Option<String>,
        pub parameters: Option<PageAnnotAnnotParametersXElementType>,
        pub appearance: PageAnnotAnnotAppearanceXElementType,
    }
    impl PageAnnotAnnotXElementType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_print() -> bool {
            true
        }
        #[must_use]
        pub fn default_no_zoom() -> bool {
            false
        }
        #[must_use]
        pub fn default_no_rotate() -> bool {
            false
        }
        #[must_use]
        pub fn default_read_only() -> bool {
            true
        }
    }
    impl WithSerializer for PageAnnotAnnotXElementType {
        type Serializer<'x> = quick_xml_serialize::PageAnnotAnnotXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PageAnnotAnnotXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PageAnnotAnnotXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PageAnnotAnnot"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PageAnnotAnnotXElementType {
        type Deserializer = quick_xml_deserialize::PageAnnotAnnotXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum PageAnnotAnnotTypeXType {
        Link,
        Path,
        Highlight,
        Stamp,
        Watermark,
    }
    impl SerializeBytes for PageAnnotAnnotTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Link => Ok(Some(Cow::Borrowed("Link"))),
                Self::Path => Ok(Some(Cow::Borrowed("Path"))),
                Self::Highlight => Ok(Some(Cow::Borrowed("Highlight"))),
                Self::Stamp => Ok(Some(Cow::Borrowed("Stamp"))),
                Self::Watermark => Ok(Some(Cow::Borrowed("Watermark"))),
            }
        }
    }
    impl DeserializeBytes for PageAnnotAnnotTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Link" => Ok(Self::Link),
                b"Path" => Ok(Self::Path),
                b"Highlight" => Ok(Self::Highlight),
                b"Stamp" => Ok(Self::Stamp),
                b"Watermark" => Ok(Self::Watermark),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotParametersXElementType {
        pub parameter: Vec<super::ofd::CtDocInfoCustomDatasCustomDataXElementType>,
    }
    impl WithSerializer for PageAnnotAnnotParametersXElementType {
        type Serializer<'x> =
            quick_xml_serialize::PageAnnotAnnotParametersXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: PageAnnotAnnotParametersXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotParametersXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("PageAnnotAnnotParameters") , is_root , })
        }
    }
    impl WithDeserializer for PageAnnotAnnotParametersXElementType {
        type Deserializer = quick_xml_deserialize::PageAnnotAnnotParametersXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct PageAnnotAnnotAppearanceXElementType {
        pub boundary: Option<String>,
        pub content: Vec<PageAnnotAnnotAppearanceXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum PageAnnotAnnotAppearanceXElementTypeContent {
        TextObject(super::page::CtPageBlockTextObjectXElementType),
        PathObject(super::page::CtPageBlockPathObjectXElementType),
        ImageObject(super::page::CtPageBlockImageObjectXElementType),
        CompositeObject(super::page::CtPageBlockCompositeObjectXElementType),
        PageBlock(super::page::CtPageBlockPageBlockXElementType),
    }
    impl WithSerializer for PageAnnotAnnotAppearanceXElementType {
        type Serializer<'x> =
            quick_xml_serialize::PageAnnotAnnotAppearanceXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("PageAnnotAnnotAppearance") , is_root , })
        }
    }
    impl WithSerializer for PageAnnotAnnotAppearanceXElementTypeContent {
        type Serializer<'x> =
            quick_xml_serialize::PageAnnotAnnotAppearanceXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Init__) , })
        }
    }
    impl WithDeserializer for PageAnnotAnnotAppearanceXElementType {
        type Deserializer = quick_xml_deserialize::PageAnnotAnnotAppearanceXElementTypeDeserializer;
    }
    impl WithDeserializer for PageAnnotAnnotAppearanceXElementTypeContent {
        type Deserializer =
            quick_xml_deserialize::PageAnnotAnnotAppearanceXElementTypeContentDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct PageAnnotXElementTypeDeserializer {
            annot: Vec<super::PageAnnotAnnotXElementType>,
            state__: Box<PageAnnotXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageAnnotXElementTypeDeserializerState {
            Init__,
            Annot(Option<<super::PageAnnotAnnotXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl PageAnnotXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    annot: Vec::new(),
                    state__: Box::new(PageAnnotXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageAnnotXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use PageAnnotXElementTypeDeserializerState as S;
                match state {
                    S::Annot(Some(deserializer)) => {
                        self.store_annot(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_annot(
                &mut self,
                value: super::PageAnnotAnnotXElementType,
            ) -> Result<(), Error> {
                self.annot.push(value);
                Ok(())
            }
            fn handle_annot<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageAnnotAnnotXElementType>,
                fallback: &mut Option<PageAnnotXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.annot.len() < 1usize {
                        fallback.get_or_insert(S::Annot(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Annot(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_annot(data)?;
                        *self.state__ = S::Annot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Annot(Some(deserializer)));
                        *self.state__ = S::Annot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageAnnotXElementType> for PageAnnotXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotXElementType> {
                use PageAnnotXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Annot(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Annot(None);
                            event
                        }
                        (S::Annot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Annot",
                                false,
                            )?;
                            match self.handle_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageAnnotXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageAnnotXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageAnnotXElementType {
                    annot: helper.finish_vec(1usize, None, self.annot)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotXElementTypeDeserializer {
            id: u32,
            type_: super::PageAnnotAnnotTypeXType,
            creator: String,
            last_mod_date: String,
            visible: bool,
            subtype: Option<String>,
            print: bool,
            no_zoom: bool,
            no_rotate: bool,
            read_only: bool,
            remark: Option<String>,
            parameters: Option<super::PageAnnotAnnotParametersXElementType>,
            appearance: Option<super::PageAnnotAnnotAppearanceXElementType>,
            state__: Box<PageAnnotAnnotXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageAnnotAnnotXElementTypeDeserializerState {
            Init__,
            Remark(Option<<String as WithDeserializer>::Deserializer>),
            Parameters(
                Option<
                    <super::PageAnnotAnnotParametersXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Appearance(
                Option<
                    <super::PageAnnotAnnotAppearanceXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl PageAnnotAnnotXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<u32> = None;
                let mut type_: Option<super::PageAnnotAnnotTypeXType> = None;
                let mut creator: Option<String> = None;
                let mut last_mod_date: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut subtype: Option<String> = None;
                let mut print: Option<bool> = None;
                let mut no_zoom: Option<bool> = None;
                let mut no_rotate: Option<bool> = None;
                let mut read_only: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Creator")
                    ) {
                        helper.read_attrib(&mut creator, b"Creator", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LastModDate")
                    ) {
                        helper.read_attrib(&mut last_mod_date, b"LastModDate", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Subtype")
                    ) {
                        helper.read_attrib(&mut subtype, b"Subtype", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Print")
                    ) {
                        helper.read_attrib(&mut print, b"Print", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"NoZoom")
                    ) {
                        helper.read_attrib(&mut no_zoom, b"NoZoom", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"NoRotate")
                    ) {
                        helper.read_attrib(&mut no_rotate, b"NoRotate", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ReadOnly")
                    ) {
                        helper.read_attrib(&mut read_only, b"ReadOnly", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    creator: creator
                        .ok_or_else(|| ErrorKind::MissingAttribute("Creator".into()))?,
                    last_mod_date: last_mod_date
                        .ok_or_else(|| ErrorKind::MissingAttribute("LastModDate".into()))?,
                    visible: visible
                        .unwrap_or_else(super::PageAnnotAnnotXElementType::default_visible),
                    subtype: subtype,
                    print: print.unwrap_or_else(super::PageAnnotAnnotXElementType::default_print),
                    no_zoom: no_zoom
                        .unwrap_or_else(super::PageAnnotAnnotXElementType::default_no_zoom),
                    no_rotate: no_rotate
                        .unwrap_or_else(super::PageAnnotAnnotXElementType::default_no_rotate),
                    read_only: read_only
                        .unwrap_or_else(super::PageAnnotAnnotXElementType::default_read_only),
                    remark: None,
                    parameters: None,
                    appearance: None,
                    state__: Box::new(PageAnnotAnnotXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageAnnotAnnotXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use PageAnnotAnnotXElementTypeDeserializerState as S;
                match state {
                    S::Remark(Some(deserializer)) => {
                        self.store_remark(deserializer.finish(helper)?)?
                    }
                    S::Parameters(Some(deserializer)) => {
                        self.store_parameters(deserializer.finish(helper)?)?
                    }
                    S::Appearance(Some(deserializer)) => {
                        self.store_appearance(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_remark(&mut self, value: String) -> Result<(), Error> {
                if self.remark.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Remark",
                    )))?;
                }
                self.remark = Some(value);
                Ok(())
            }
            fn store_parameters(
                &mut self,
                value: super::PageAnnotAnnotParametersXElementType,
            ) -> Result<(), Error> {
                if self.parameters.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Parameters",
                    )))?;
                }
                self.parameters = Some(value);
                Ok(())
            }
            fn store_appearance(
                &mut self,
                value: super::PageAnnotAnnotAppearanceXElementType,
            ) -> Result<(), Error> {
                if self.appearance.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Appearance",
                    )))?;
                }
                self.appearance = Some(value);
                Ok(())
            }
            fn handle_remark<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Remark(None));
                    *self.state__ = S::Parameters(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_remark(data)?;
                        *self.state__ = S::Parameters(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Remark(Some(deserializer)));
                        *self.state__ = S::Parameters(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_parameters<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageAnnotAnnotParametersXElementType>,
                fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Parameters(None));
                    *self.state__ = S::Appearance(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_parameters(data)?;
                        *self.state__ = S::Appearance(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Parameters(Some(deserializer)));
                        *self.state__ = S::Appearance(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_appearance<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageAnnotAnnotAppearanceXElementType>,
                fallback: &mut Option<PageAnnotAnnotXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Appearance(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_appearance(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Appearance(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageAnnotAnnotXElementType>
            for PageAnnotAnnotXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotXElementType> {
                use PageAnnotAnnotXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Remark(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_remark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Parameters(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_parameters(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Appearance(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_appearance(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Remark(None);
                            event
                        }
                        (S::Remark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Remark",
                                false,
                            )?;
                            match self.handle_remark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Parameters(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Parameters",
                                false,
                            )?;
                            match self.handle_parameters(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Appearance(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Appearance",
                                true,
                            )?;
                            match self.handle_appearance(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageAnnotAnnotXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageAnnotAnnotXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageAnnotAnnotXElementType {
                    id: self.id,
                    type_: self.type_,
                    creator: self.creator,
                    last_mod_date: self.last_mod_date,
                    visible: self.visible,
                    subtype: self.subtype,
                    print: self.print,
                    no_zoom: self.no_zoom,
                    no_rotate: self.no_rotate,
                    read_only: self.read_only,
                    remark: self.remark,
                    parameters: self.parameters,
                    appearance: helper.finish_element("Appearance", self.appearance)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotParametersXElementTypeDeserializer {
            parameter: Vec<super::super::ofd::CtDocInfoCustomDatasCustomDataXElementType>,
            state__: Box<PageAnnotAnnotParametersXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageAnnotAnnotParametersXElementTypeDeserializerState {
            Init__ , Parameter (Option << super :: super :: ofd :: CtDocInfoCustomDatasCustomDataXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl PageAnnotAnnotParametersXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    parameter: Vec::new(),
                    state__: Box::new(
                        PageAnnotAnnotParametersXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageAnnotAnnotParametersXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use PageAnnotAnnotParametersXElementTypeDeserializerState as S;
                match state {
                    S::Parameter(Some(deserializer)) => {
                        self.store_parameter(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_parameter(
                &mut self,
                value: super::super::ofd::CtDocInfoCustomDatasCustomDataXElementType,
            ) -> Result<(), Error> {
                self.parameter.push(value);
                Ok(())
            }
            fn handle_parameter<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<
                    'de,
                    super::super::ofd::CtDocInfoCustomDatasCustomDataXElementType,
                >,
                fallback: &mut Option<PageAnnotAnnotParametersXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotParametersXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.parameter.len() < 1usize {
                        fallback.get_or_insert(S::Parameter(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Parameter(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_parameter(data)?;
                        *self.state__ = S::Parameter(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Parameter(Some(deserializer)));
                        *self.state__ = S::Parameter(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageAnnotAnnotParametersXElementType>
            for PageAnnotAnnotParametersXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotParametersXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotParametersXElementType> {
                use PageAnnotAnnotParametersXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Parameter(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_parameter(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Parameter(None);
                            event
                        }
                        (S::Parameter(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Parameter",
                                false,
                            )?;
                            match self.handle_parameter(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageAnnotAnnotParametersXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageAnnotAnnotParametersXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageAnnotAnnotParametersXElementType {
                    parameter: helper.finish_vec(1usize, None, self.parameter)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotAppearanceXElementTypeDeserializer {
            boundary: Option<String>,
            content: Vec<super::PageAnnotAnnotAppearanceXElementTypeContent>,
            state__: Box<PageAnnotAnnotAppearanceXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageAnnotAnnotAppearanceXElementTypeDeserializerState {
            Init__ , Next__ , Content__ (< super :: PageAnnotAnnotAppearanceXElementTypeContent as WithDeserializer > :: Deserializer) , Unknown__ , }
        impl PageAnnotAnnotAppearanceXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary,
                    content: Vec::new(),
                    state__: Box::new(
                        PageAnnotAnnotAppearanceXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageAnnotAnnotAppearanceXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let PageAnnotAnnotAppearanceXElementTypeDeserializerState::Content__(
                    deserializer,
                ) = state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::PageAnnotAnnotAppearanceXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>,
                fallback: &mut Option<PageAnnotAnnotAppearanceXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageAnnotAnnotAppearanceXElementType>
            for PageAnnotAnnotAppearanceXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementType> {
                use PageAnnotAnnotAppearanceXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: PageAnnotAnnotAppearanceXElementTypeContent as WithDeserializer > :: init (helper , event) ? ;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageAnnotAnnotAppearanceXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageAnnotAnnotAppearanceXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageAnnotAnnotAppearanceXElementType {
                    boundary: self.boundary,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotAppearanceXElementTypeContentDeserializer {
            state__: Box<PageAnnotAnnotAppearanceXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum PageAnnotAnnotAppearanceXElementTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: super :: page :: CtPageBlockTextObjectXElementType > , Option << super :: super :: page :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: super :: page :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: super :: page :: CtPageBlockPathObjectXElementType > , Option << super :: super :: page :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: super :: page :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: super :: page :: CtPageBlockImageObjectXElementType > , Option << super :: super :: page :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: super :: page :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: super :: page :: CtPageBlockCompositeObjectXElementType > , Option << super :: super :: page :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: super :: page :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: super :: page :: CtPageBlockPageBlockXElementType > , Option << super :: super :: page :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: super :: page :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: PageAnnotAnnotAppearanceXElementTypeContent) , Unknown__ , }
        impl PageAnnotAnnotAppearanceXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output = < super :: super :: page :: CtPageBlockTextObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output = < super :: super :: page :: CtPageBlockPathObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output = < super :: super :: page :: CtPageBlockImageObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: super :: page :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output = < super :: super :: page :: CtPageBlockPageBlockXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ =
                    PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: PageAnnotAnnotAppearanceXElementTypeContentDeserializerState,
            ) -> Result<super::PageAnnotAnnotAppearanceXElementTypeContent, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(
                            super::PageAnnotAnnotAppearanceXElementTypeContent::TextObject(
                                helper.finish_element("TextObject", values)?,
                            ),
                        )
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(
                            super::PageAnnotAnnotAppearanceXElementTypeContent::PathObject(
                                helper.finish_element("PathObject", values)?,
                            ),
                        )
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(
                            super::PageAnnotAnnotAppearanceXElementTypeContent::ImageObject(
                                helper.finish_element("ImageObject", values)?,
                            ),
                        )
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(
                            super::PageAnnotAnnotAppearanceXElementTypeContent::CompositeObject(
                                helper.finish_element("CompositeObject", values)?,
                            ),
                        )
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(
                            super::PageAnnotAnnotAppearanceXElementTypeContent::PageBlock(
                                helper.finish_element("PageBlock", values)?,
                            ),
                        )
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::super::page::CtPageBlockTextObjectXElementType>,
                value: super::super::page::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::super::page::CtPageBlockPathObjectXElementType>,
                value: super::super::page::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::super::page::CtPageBlockImageObjectXElementType>,
                value: super::super::page::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::super::page::CtPageBlockCompositeObjectXElementType>,
                value: super::super::page::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::super::page::CtPageBlockPageBlockXElementType>,
                value: super::super::page::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::super::page::CtPageBlockTextObjectXElementType>,
                fallback : Option << super :: super :: page :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtPageBlockTextObjectXElementType,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::super::page::CtPageBlockPathObjectXElementType>,
                fallback : Option << super :: super :: page :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtPageBlockPathObjectXElementType,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::super::page::CtPageBlockImageObjectXElementType>,
                fallback : Option << super :: super :: page :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtPageBlockImageObjectXElementType,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::super::page::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: super :: page :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtPageBlockCompositeObjectXElementType,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::super::page::CtPageBlockPageBlockXElementType>,
                fallback : Option << super :: super :: page :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtPageBlockPageBlockXElementType,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
            for PageAnnotAnnotAppearanceXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
            {
                let deserializer = Self {
                    state__: Box::new(
                        PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__,
                    ),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            PageAnnotAnnotAppearanceXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageAnnotAnnotAppearanceXElementTypeContent>
            {
                use PageAnnotAnnotAppearanceXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageAnnotAnnotAppearanceXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct PageAnnotXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageAnnotXElementType,
            pub(super) state: Box<PageAnnotXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageAnnotXElementTypeSerializerState<'ser> {
            Init__,
            Annot(
                IterSerializer<
                    'ser,
                    &'ser [super::PageAnnotAnnotXElementType],
                    super::PageAnnotAnnotXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageAnnotXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageAnnotXElementTypeSerializerState::Init__ => {
                            *self.state = PageAnnotXElementTypeSerializerState::Annot(
                                IterSerializer::new(&self.value.annot[..], Some("Annot"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageAnnotXElementTypeSerializerState::Annot(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = PageAnnotXElementTypeSerializerState::End__,
                            }
                        }
                        PageAnnotXElementTypeSerializerState::End__ => {
                            *self.state = PageAnnotXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageAnnotXElementTypeSerializerState::Done__ => return Ok(None),
                        PageAnnotXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageAnnotXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageAnnotXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageAnnotAnnotXElementType,
            pub(super) state: Box<PageAnnotAnnotXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageAnnotAnnotXElementTypeSerializerState<'ser> {
            Init__,
            Remark(IterSerializer<'ser, Option<&'ser String>, String>),
            Parameters(
                IterSerializer<
                    'ser,
                    Option<&'ser super::PageAnnotAnnotParametersXElementType>,
                    super::PageAnnotAnnotParametersXElementType,
                >,
            ),
            Appearance(
                <super::PageAnnotAnnotAppearanceXElementType as WithSerializer>::Serializer<'ser>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageAnnotAnnotXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageAnnotAnnotXElementTypeSerializerState::Init__ => {
                            *self.state = PageAnnotAnnotXElementTypeSerializerState::Remark(
                                IterSerializer::new(
                                    self.value.remark.as_ref(),
                                    Some("Remark"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib(&mut bytes, "Creator", &self.value.creator)?;
                            helper.write_attrib(
                                &mut bytes,
                                "LastModDate",
                                &self.value.last_mod_date,
                            )?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "Subtype", &self.value.subtype)?;
                            helper.write_attrib(&mut bytes, "Print", &self.value.print)?;
                            helper.write_attrib(&mut bytes, "NoZoom", &self.value.no_zoom)?;
                            helper.write_attrib(&mut bytes, "NoRotate", &self.value.no_rotate)?;
                            helper.write_attrib(&mut bytes, "ReadOnly", &self.value.read_only)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageAnnotAnnotXElementTypeSerializerState::Remark(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageAnnotAnnotXElementTypeSerializerState::Parameters(
                                            IterSerializer::new(
                                                self.value.parameters.as_ref(),
                                                Some("Parameters"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        PageAnnotAnnotXElementTypeSerializerState::Parameters(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageAnnotAnnotXElementTypeSerializerState::Appearance(
                                            WithSerializer::serializer(
                                                &self.value.appearance,
                                                Some("Appearance"),
                                                false,
                                            )?,
                                        )
                                }
                            }
                        }
                        PageAnnotAnnotXElementTypeSerializerState::Appearance(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = PageAnnotAnnotXElementTypeSerializerState::End__,
                        },
                        PageAnnotAnnotXElementTypeSerializerState::End__ => {
                            *self.state = PageAnnotAnnotXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageAnnotAnnotXElementTypeSerializerState::Done__ => return Ok(None),
                        PageAnnotAnnotXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageAnnotAnnotXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageAnnotAnnotXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageAnnotAnnotParametersXElementType,
            pub(super) state: Box<PageAnnotAnnotParametersXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageAnnotAnnotParametersXElementTypeSerializerState<'ser> {
            Init__,
            Parameter(
                IterSerializer<
                    'ser,
                    &'ser [super::super::ofd::CtDocInfoCustomDatasCustomDataXElementType],
                    super::super::ofd::CtDocInfoCustomDatasCustomDataXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageAnnotAnnotParametersXElementTypeSerializerState::Init__ => {
                            *self.state =
                                PageAnnotAnnotParametersXElementTypeSerializerState::Parameter(
                                    IterSerializer::new(
                                        &self.value.parameter[..],
                                        Some("Parameter"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageAnnotAnnotParametersXElementTypeSerializerState::Parameter(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageAnnotAnnotParametersXElementTypeSerializerState::End__
                                }
                            }
                        }
                        PageAnnotAnnotParametersXElementTypeSerializerState::End__ => {
                            *self.state =
                                PageAnnotAnnotParametersXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageAnnotAnnotParametersXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        PageAnnotAnnotParametersXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageAnnotAnnotParametersXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageAnnotAnnotParametersXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageAnnotAnnotAppearanceXElementType,
            pub(super) state: Box<PageAnnotAnnotAppearanceXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageAnnotAnnotAppearanceXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::PageAnnotAnnotAppearanceXElementTypeContent],
                    super::PageAnnotAnnotAppearanceXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageAnnotAnnotAppearanceXElementTypeSerializerState::Init__ => {
                            *self.state =
                                PageAnnotAnnotAppearanceXElementTypeSerializerState::Content__(
                                    IterSerializer::new(&self.value.content[..], None, false),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Boundary",
                                &self.value.boundary,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageAnnotAnnotAppearanceXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageAnnotAnnotAppearanceXElementTypeSerializerState::End__
                                }
                            }
                        }
                        PageAnnotAnnotAppearanceXElementTypeSerializerState::End__ => {
                            *self.state =
                                PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        PageAnnotAnnotAppearanceXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageAnnotAnnotAppearanceXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageAnnotAnnotAppearanceXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::PageAnnotAnnotAppearanceXElementTypeContent,
            pub(super) state: Box<PageAnnotAnnotAppearanceXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum PageAnnotAnnotAppearanceXElementTypeContentSerializerState<'ser> {
            Init__ , TextObject (< super :: super :: page :: CtPageBlockTextObjectXElementType as WithSerializer > :: Serializer < 'ser >) , PathObject (< super :: super :: page :: CtPageBlockPathObjectXElementType as WithSerializer > :: Serializer < 'ser >) , ImageObject (< super :: super :: page :: CtPageBlockImageObjectXElementType as WithSerializer > :: Serializer < 'ser >) , CompositeObject (< super :: super :: page :: CtPageBlockCompositeObjectXElementType as WithSerializer > :: Serializer < 'ser >) , PageBlock (< super :: super :: page :: CtPageBlockPageBlockXElementType as WithSerializer > :: Serializer < 'ser >) , Done__ , Phantom__ (& 'ser ()) , }
        impl<'ser> PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Init__ => { match self . value { super :: PageAnnotAnnotAppearanceXElementTypeContent :: TextObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: PathObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: ImageObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: CompositeObject (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: PageAnnotAnnotAppearanceXElementTypeContent :: PageBlock (x) => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: TextObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PathObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: ImageObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: CompositeObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: PageBlock (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ , } } PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Done__ => return Ok (None) , PageAnnotAnnotAppearanceXElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageAnnotAnnotAppearanceXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            PageAnnotAnnotAppearanceXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod attachments {
    use xsd_parser_types::quick_xml::{Error, WithDeserializer, WithSerializer};
    pub type Attachments = AttachmentsXElementType;
    #[derive(Debug)]
    pub struct AttachmentsXElementType {
        pub attachment: Vec<CtAttachmentXType>,
    }
    impl WithSerializer for AttachmentsXElementType {
        type Serializer<'x> = quick_xml_serialize::AttachmentsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::AttachmentsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::AttachmentsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("Attachments"),
                is_root,
            })
        }
    }
    impl WithDeserializer for AttachmentsXElementType {
        type Deserializer = quick_xml_deserialize::AttachmentsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtAttachmentXType {
        pub id: String,
        pub name: String,
        pub format: Option<String>,
        pub creation_date: Option<String>,
        pub mod_date: Option<String>,
        pub size: Option<f64>,
        pub visible: bool,
        pub usage: String,
        pub file_loc: String,
    }
    impl CtAttachmentXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_usage() -> String {
            String::from("none")
        }
    }
    impl WithSerializer for CtAttachmentXType {
        type Serializer<'x> = quick_xml_serialize::CtAttachmentXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtAttachmentXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtAttachmentXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Attachment"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtAttachmentXType {
        type Deserializer = quick_xml_deserialize::CtAttachmentXTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct AttachmentsXElementTypeDeserializer {
            attachment: Vec<super::CtAttachmentXType>,
            state__: Box<AttachmentsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum AttachmentsXElementTypeDeserializerState {
            Init__,
            Attachment(Option<<super::CtAttachmentXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl AttachmentsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    attachment: Vec::new(),
                    state__: Box::new(AttachmentsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: AttachmentsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use AttachmentsXElementTypeDeserializerState as S;
                match state {
                    S::Attachment(Some(deserializer)) => {
                        self.store_attachment(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_attachment(&mut self, value: super::CtAttachmentXType) -> Result<(), Error> {
                self.attachment.push(value);
                Ok(())
            }
            fn handle_attachment<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtAttachmentXType>,
                fallback: &mut Option<AttachmentsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use AttachmentsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Attachment(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_attachment(data)?;
                        *self.state__ = S::Attachment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Attachment(Some(deserializer)));
                        *self.state__ = S::Attachment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::AttachmentsXElementType>
            for AttachmentsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AttachmentsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::AttachmentsXElementType> {
                use AttachmentsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Attachment(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_attachment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Attachment(None);
                            event
                        }
                        (S::Attachment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Attachment",
                                false,
                            )?;
                            match self.handle_attachment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::AttachmentsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    AttachmentsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::AttachmentsXElementType {
                    attachment: self.attachment,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtAttachmentXTypeDeserializer {
            id: String,
            name: String,
            format: Option<String>,
            creation_date: Option<String>,
            mod_date: Option<String>,
            size: Option<f64>,
            visible: bool,
            usage: String,
            file_loc: Option<String>,
            state__: Box<CtAttachmentXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtAttachmentXTypeDeserializerState {
            Init__,
            FileLoc(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtAttachmentXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut name: Option<String> = None;
                let mut format: Option<String> = None;
                let mut creation_date: Option<String> = None;
                let mut mod_date: Option<String> = None;
                let mut size: Option<f64> = None;
                let mut visible: Option<bool> = None;
                let mut usage: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Format")
                    ) {
                        helper.read_attrib(&mut format, b"Format", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CreationDate")
                    ) {
                        helper.read_attrib(&mut creation_date, b"CreationDate", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ModDate")
                    ) {
                        helper.read_attrib(&mut mod_date, b"ModDate", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Size")
                    ) {
                        helper.read_attrib(&mut size, b"Size", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Usage")
                    ) {
                        helper.read_attrib(&mut usage, b"Usage", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    name: name.ok_or_else(|| ErrorKind::MissingAttribute("Name".into()))?,
                    format: format,
                    creation_date: creation_date,
                    mod_date: mod_date,
                    size: size,
                    visible: visible.unwrap_or_else(super::CtAttachmentXType::default_visible),
                    usage: usage.unwrap_or_else(super::CtAttachmentXType::default_usage),
                    file_loc: None,
                    state__: Box::new(CtAttachmentXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtAttachmentXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtAttachmentXTypeDeserializerState as S;
                match state {
                    S::FileLoc(Some(deserializer)) => {
                        self.store_file_loc(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
                if self.file_loc.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FileLoc",
                    )))?;
                }
                self.file_loc = Some(value);
                Ok(())
            }
            fn handle_file_loc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtAttachmentXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtAttachmentXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FileLoc(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_file_loc(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FileLoc(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtAttachmentXType> for CtAttachmentXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAttachmentXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAttachmentXType> {
                use CtAttachmentXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FileLoc(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FileLoc(None);
                            event
                        }
                        (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FileLoc",
                                false,
                            )?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtAttachmentXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtAttachmentXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtAttachmentXType {
                    id: self.id,
                    name: self.name,
                    format: self.format,
                    creation_date: self.creation_date,
                    mod_date: self.mod_date,
                    size: self.size,
                    visible: self.visible,
                    usage: self.usage,
                    file_loc: helper.finish_element("FileLoc", self.file_loc)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct AttachmentsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::AttachmentsXElementType,
            pub(super) state: Box<AttachmentsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum AttachmentsXElementTypeSerializerState<'ser> {
            Init__,
            Attachment(
                IterSerializer<'ser, &'ser [super::CtAttachmentXType], super::CtAttachmentXType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> AttachmentsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        AttachmentsXElementTypeSerializerState::Init__ => {
                            *self.state = AttachmentsXElementTypeSerializerState::Attachment(
                                IterSerializer::new(
                                    &self.value.attachment[..],
                                    Some("Attachment"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        AttachmentsXElementTypeSerializerState::Attachment(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = AttachmentsXElementTypeSerializerState::End__,
                            }
                        }
                        AttachmentsXElementTypeSerializerState::End__ => {
                            *self.state = AttachmentsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        AttachmentsXElementTypeSerializerState::Done__ => return Ok(None),
                        AttachmentsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for AttachmentsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = AttachmentsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtAttachmentXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtAttachmentXType,
            pub(super) state: Box<CtAttachmentXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtAttachmentXTypeSerializerState<'ser> {
            Init__,
            FileLoc(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtAttachmentXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtAttachmentXTypeSerializerState::Init__ => {
                            *self.state = CtAttachmentXTypeSerializerState::FileLoc(
                                WithSerializer::serializer(
                                    &self.value.file_loc,
                                    Some("FileLoc"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "CreationDate",
                                &self.value.creation_date,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "ModDate", &self.value.mod_date)?;
                            helper.write_attrib_opt(&mut bytes, "Size", &self.value.size)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib(&mut bytes, "Usage", &self.value.usage)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtAttachmentXTypeSerializerState::FileLoc(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtAttachmentXTypeSerializerState::End__,
                            }
                        }
                        CtAttachmentXTypeSerializerState::End__ => {
                            *self.state = CtAttachmentXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtAttachmentXTypeSerializerState::Done__ => return Ok(None),
                        CtAttachmentXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtAttachmentXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtAttachmentXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod custom_tags {
    use xsd_parser_types::quick_xml::{Error, WithDeserializer, WithSerializer};
    pub type CustomTags = CustomTagsXElementType;
    #[derive(Debug)]
    pub struct CustomTagsXElementType {
        pub custom_tag: Vec<CustomTagsCustomTagXElementType>,
    }
    impl WithSerializer for CustomTagsXElementType {
        type Serializer<'x> = quick_xml_serialize::CustomTagsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CustomTagsXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CustomTagsXElementTypeSerializerState::Init__),
                name: name.unwrap_or("CustomTags"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CustomTagsXElementType {
        type Deserializer = quick_xml_deserialize::CustomTagsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CustomTagsCustomTagXElementType {
        pub name_space: String,
        pub schema_loc: Option<String>,
        pub file_loc: String,
    }
    impl WithSerializer for CustomTagsCustomTagXElementType {
        type Serializer<'x> = quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CustomTagsCustomTagXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CustomTagsCustomTag"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CustomTagsCustomTagXElementType {
        type Deserializer = quick_xml_deserialize::CustomTagsCustomTagXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct CustomTagsXElementTypeDeserializer {
            custom_tag: Vec<super::CustomTagsCustomTagXElementType>,
            state__: Box<CustomTagsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CustomTagsXElementTypeDeserializerState {
            Init__,
            CustomTag(
                Option<<super::CustomTagsCustomTagXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CustomTagsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    custom_tag: Vec::new(),
                    state__: Box::new(CustomTagsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CustomTagsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CustomTagsXElementTypeDeserializerState as S;
                match state {
                    S::CustomTag(Some(deserializer)) => {
                        self.store_custom_tag(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_custom_tag(
                &mut self,
                value: super::CustomTagsCustomTagXElementType,
            ) -> Result<(), Error> {
                self.custom_tag.push(value);
                Ok(())
            }
            fn handle_custom_tag<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CustomTagsCustomTagXElementType>,
                fallback: &mut Option<CustomTagsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CustomTagsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CustomTag(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_custom_tag(data)?;
                        *self.state__ = S::CustomTag(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CustomTag(Some(deserializer)));
                        *self.state__ = S::CustomTag(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CustomTagsXElementType> for CustomTagsXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CustomTagsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CustomTagsXElementType> {
                use CustomTagsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CustomTag(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_custom_tag(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CustomTag(None);
                            event
                        }
                        (S::CustomTag(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CustomTag",
                                false,
                            )?;
                            match self.handle_custom_tag(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CustomTagsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CustomTagsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CustomTagsXElementType {
                    custom_tag: self.custom_tag,
                })
            }
        }
        #[derive(Debug)]
        pub struct CustomTagsCustomTagXElementTypeDeserializer {
            name_space: String,
            schema_loc: Option<String>,
            file_loc: Option<String>,
            state__: Box<CustomTagsCustomTagXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CustomTagsCustomTagXElementTypeDeserializerState {
            Init__,
            SchemaLoc(Option<<String as WithDeserializer>::Deserializer>),
            FileLoc(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CustomTagsCustomTagXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut name_space: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"NameSpace")
                    ) {
                        helper.read_attrib(&mut name_space, b"NameSpace", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    name_space: name_space
                        .ok_or_else(|| ErrorKind::MissingAttribute("NameSpace".into()))?,
                    schema_loc: None,
                    file_loc: None,
                    state__: Box::new(CustomTagsCustomTagXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CustomTagsCustomTagXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CustomTagsCustomTagXElementTypeDeserializerState as S;
                match state {
                    S::SchemaLoc(Some(deserializer)) => {
                        self.store_schema_loc(deserializer.finish(helper)?)?
                    }
                    S::FileLoc(Some(deserializer)) => {
                        self.store_file_loc(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_schema_loc(&mut self, value: String) -> Result<(), Error> {
                if self.schema_loc.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"SchemaLoc",
                    )))?;
                }
                self.schema_loc = Some(value);
                Ok(())
            }
            fn store_file_loc(&mut self, value: String) -> Result<(), Error> {
                if self.file_loc.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FileLoc",
                    )))?;
                }
                self.file_loc = Some(value);
                Ok(())
            }
            fn handle_schema_loc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CustomTagsCustomTagXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CustomTagsCustomTagXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::SchemaLoc(None));
                    *self.state__ = S::FileLoc(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_schema_loc(data)?;
                        *self.state__ = S::FileLoc(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::SchemaLoc(Some(deserializer)));
                        *self.state__ = S::FileLoc(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_file_loc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CustomTagsCustomTagXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CustomTagsCustomTagXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FileLoc(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_file_loc(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FileLoc(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CustomTagsCustomTagXElementType>
            for CustomTagsCustomTagXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CustomTagsCustomTagXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CustomTagsCustomTagXElementType> {
                use CustomTagsCustomTagXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::SchemaLoc(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_schema_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FileLoc(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::SchemaLoc(None);
                            event
                        }
                        (S::SchemaLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"SchemaLoc",
                                false,
                            )?;
                            match self.handle_schema_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FileLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FileLoc",
                                false,
                            )?;
                            match self.handle_file_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CustomTagsCustomTagXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CustomTagsCustomTagXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CustomTagsCustomTagXElementType {
                    name_space: self.name_space,
                    schema_loc: self.schema_loc,
                    file_loc: helper.finish_element("FileLoc", self.file_loc)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct CustomTagsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CustomTagsXElementType,
            pub(super) state: Box<CustomTagsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CustomTagsXElementTypeSerializerState<'ser> {
            Init__,
            CustomTag(
                IterSerializer<
                    'ser,
                    &'ser [super::CustomTagsCustomTagXElementType],
                    super::CustomTagsCustomTagXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CustomTagsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CustomTagsXElementTypeSerializerState::Init__ => {
                            *self.state = CustomTagsXElementTypeSerializerState::CustomTag(
                                IterSerializer::new(
                                    &self.value.custom_tag[..],
                                    Some("CustomTag"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CustomTagsXElementTypeSerializerState::CustomTag(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CustomTagsXElementTypeSerializerState::End__,
                            }
                        }
                        CustomTagsXElementTypeSerializerState::End__ => {
                            *self.state = CustomTagsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CustomTagsXElementTypeSerializerState::Done__ => return Ok(None),
                        CustomTagsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CustomTagsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CustomTagsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CustomTagsCustomTagXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CustomTagsCustomTagXElementType,
            pub(super) state: Box<CustomTagsCustomTagXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CustomTagsCustomTagXElementTypeSerializerState<'ser> {
            Init__,
            SchemaLoc(IterSerializer<'ser, Option<&'ser String>, String>),
            FileLoc(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CustomTagsCustomTagXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CustomTagsCustomTagXElementTypeSerializerState::Init__ => {
                            *self.state = CustomTagsCustomTagXElementTypeSerializerState::SchemaLoc(
                                IterSerializer::new(
                                    self.value.schema_loc.as_ref(),
                                    Some("SchemaLoc"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "NameSpace", &self.value.name_space)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CustomTagsCustomTagXElementTypeSerializerState::SchemaLoc(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CustomTagsCustomTagXElementTypeSerializerState::FileLoc(
                                            WithSerializer::serializer(
                                                &self.value.file_loc,
                                                Some("FileLoc"),
                                                false,
                                            )?,
                                        )
                                }
                            }
                        }
                        CustomTagsCustomTagXElementTypeSerializerState::FileLoc(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CustomTagsCustomTagXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CustomTagsCustomTagXElementTypeSerializerState::End__ => {
                            *self.state = CustomTagsCustomTagXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CustomTagsCustomTagXElementTypeSerializerState::Done__ => return Ok(None),
                        CustomTagsCustomTagXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CustomTagsCustomTagXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CustomTagsCustomTagXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod definition {
    use std::borrow::Cow;
    use xsd_parser_types::{
        quick_xml::{
            DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
            SerializeHelper, WithDeserializer, WithSerializer,
        },
        xml::AnyElement,
    };
    #[derive(Debug)]
    pub struct CtActionXType {
        pub event: CtActionEventXType,
        pub content: Vec<CtActionXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtActionXTypeContent {
        Region(CtRegionXType),
        Goto(CtActionGotoXElementType),
        Uri(CtActionUriXElementType),
        GotoA(CtActionGotoAxElementType),
        Sound(CtActionSoundXElementType),
        Movie(CtActionMovieXElementType),
    }
    impl WithSerializer for CtActionXType {
        type Serializer<'x> = quick_xml_serialize::CtActionXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtActionXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Action"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtActionXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtActionXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtActionXTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtActionXTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for CtActionXType {
        type Deserializer = quick_xml_deserialize::CtActionXTypeDeserializer;
    }
    impl WithDeserializer for CtActionXTypeContent {
        type Deserializer = quick_xml_deserialize::CtActionXTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtDestXType {
        pub type_: CtDestTypeXType,
        pub page_id: u32,
        pub left: Option<f64>,
        pub top: Option<f64>,
        pub right: Option<f64>,
        pub bottom: Option<f64>,
        pub zoom: Option<f64>,
    }
    impl WithSerializer for CtDestXType {
        type Serializer<'x> = quick_xml_serialize::CtDestXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtDestXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtDestXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Dest"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtDestXType {
        type Deserializer = quick_xml_deserialize::CtDestXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageAreaXType {
        pub physical_box: String,
        pub application_box: Option<String>,
        pub content_box: Option<String>,
        pub bleed_box: Option<String>,
    }
    impl WithSerializer for CtPageAreaXType {
        type Serializer<'x> = quick_xml_serialize::CtPageAreaXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtPageAreaXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtPageAreaXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_PageArea"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtPageAreaXType {
        type Deserializer = quick_xml_deserialize::CtPageAreaXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtRegionXType {
        pub area: Vec<CtRegionAreaXElementType>,
    }
    impl WithSerializer for CtRegionXType {
        type Serializer<'x> = quick_xml_serialize::CtRegionXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtRegionXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtRegionXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Region"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtRegionXType {
        type Deserializer = quick_xml_deserialize::CtRegionXTypeDeserializer;
    }
    pub type StArrayXType = String;
    pub type StBoxXType = String;
    pub type StIdXType = u32;
    pub type StLocXType = String;
    pub type StPosXType = String;
    pub type StRefIdXType = u32;
    #[derive(Debug)]
    pub enum CtActionEventXType {
        Do,
        Po,
        Click,
    }
    impl SerializeBytes for CtActionEventXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Do => Ok(Some(Cow::Borrowed("DO"))),
                Self::Po => Ok(Some(Cow::Borrowed("PO"))),
                Self::Click => Ok(Some(Cow::Borrowed("CLICK"))),
            }
        }
    }
    impl DeserializeBytes for CtActionEventXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"DO" => Ok(Self::Do),
                b"PO" => Ok(Self::Po),
                b"CLICK" => Ok(Self::Click),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtActionGotoXElementType {
        Dest(CtDestXType),
        Bookmark(CtActionGotoBookmarkXElementType),
    }
    impl WithSerializer for CtActionGotoXElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionGotoXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionGotoXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionGotoXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionGoto"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtActionGotoXElementType {
        type Deserializer = quick_xml_deserialize::CtActionGotoXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtActionUriXElementType {
        pub uri: String,
        pub base: Option<String>,
        pub target: Option<String>,
    }
    impl WithSerializer for CtActionUriXElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionUriXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionUriXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionUriXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionUri"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtActionUriXElementType {
        type Deserializer = quick_xml_deserialize::CtActionUriXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtActionGotoAxElementType {
        pub attach_id: String,
        pub new_window: bool,
    }
    impl CtActionGotoAxElementType {
        #[must_use]
        pub fn default_new_window() -> bool {
            true
        }
    }
    impl WithSerializer for CtActionGotoAxElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionGotoAxElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionGotoAxElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionGotoAxElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionGotoA"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtActionGotoAxElementType {
        type Deserializer = quick_xml_deserialize::CtActionGotoAxElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtActionSoundXElementType {
        pub resource_id: u32,
        pub volume: Option<i32>,
        pub repeat: Option<bool>,
        pub synchronous: Option<bool>,
    }
    impl WithSerializer for CtActionSoundXElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionSoundXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionSoundXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionSoundXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionSound"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtActionSoundXElementType {
        type Deserializer = quick_xml_deserialize::CtActionSoundXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtActionMovieXElementType {
        pub resource_id: u32,
        pub operator: CtActionMovieOperatorXType,
    }
    impl CtActionMovieXElementType {
        #[must_use]
        pub fn default_operator() -> CtActionMovieOperatorXType {
            CtActionMovieOperatorXType::Play
        }
    }
    impl WithSerializer for CtActionMovieXElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionMovieXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtActionMovieXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtActionMovieXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtActionMovie"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtActionMovieXElementType {
        type Deserializer = quick_xml_deserialize::CtActionMovieXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtDestTypeXType {
        Xyz,
        Fit,
        FitH,
        FitV,
        FitR,
    }
    impl SerializeBytes for CtDestTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Xyz => Ok(Some(Cow::Borrowed("XYZ"))),
                Self::Fit => Ok(Some(Cow::Borrowed("Fit"))),
                Self::FitH => Ok(Some(Cow::Borrowed("FitH"))),
                Self::FitV => Ok(Some(Cow::Borrowed("FitV"))),
                Self::FitR => Ok(Some(Cow::Borrowed("FitR"))),
            }
        }
    }
    impl DeserializeBytes for CtDestTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"XYZ" => Ok(Self::Xyz),
                b"Fit" => Ok(Self::Fit),
                b"FitH" => Ok(Self::FitH),
                b"FitV" => Ok(Self::FitV),
                b"FitR" => Ok(Self::FitR),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaXElementType {
        pub start: String,
        pub content: Vec<CtRegionAreaXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtRegionAreaXElementTypeContent {
        Move(CtRegionAreaLineXElementType),
        Line(CtRegionAreaLineXElementType),
        OuadraticBezier(CtRegionAreaOuadraticBezierXElementType),
        CubicBezier(CtRegionAreaCubicBezierXElementType),
        Arc(CtRegionAreaArcXElementType),
        Close(AnyElement),
    }
    impl WithSerializer for CtRegionAreaXElementType {
        type Serializer<'x> = quick_xml_serialize::CtRegionAreaXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtRegionAreaXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtRegionAreaXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtRegionArea"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtRegionAreaXElementTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtRegionAreaXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(
                quick_xml_serialize::CtRegionAreaXElementTypeContentSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtRegionAreaXElementTypeContentSerializerState::Init__,
                    ),
                },
            )
        }
    }
    impl WithDeserializer for CtRegionAreaXElementType {
        type Deserializer = quick_xml_deserialize::CtRegionAreaXElementTypeDeserializer;
    }
    impl WithDeserializer for CtRegionAreaXElementTypeContent {
        type Deserializer = quick_xml_deserialize::CtRegionAreaXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtActionGotoBookmarkXElementType {
        pub name: String,
    }
    impl WithSerializer for CtActionGotoBookmarkXElementType {
        type Serializer<'x> = quick_xml_serialize::CtActionGotoBookmarkXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtActionGotoBookmarkXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtActionGotoBookmarkXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtActionGotoBookmark") , is_root , })
        }
    }
    impl WithDeserializer for CtActionGotoBookmarkXElementType {
        type Deserializer = quick_xml_deserialize::CtActionGotoBookmarkXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtActionMovieOperatorXType {
        Play,
        Stop,
        Pause,
        Resume,
    }
    impl SerializeBytes for CtActionMovieOperatorXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Play => Ok(Some(Cow::Borrowed("Play"))),
                Self::Stop => Ok(Some(Cow::Borrowed("Stop"))),
                Self::Pause => Ok(Some(Cow::Borrowed("Pause"))),
                Self::Resume => Ok(Some(Cow::Borrowed("Resume"))),
            }
        }
    }
    impl DeserializeBytes for CtActionMovieOperatorXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Play" => Ok(Self::Play),
                b"Stop" => Ok(Self::Stop),
                b"Pause" => Ok(Self::Pause),
                b"Resume" => Ok(Self::Resume),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtRegionAreaLineXElementType {
        pub point_1: String,
    }
    impl WithSerializer for CtRegionAreaLineXElementType {
        type Serializer<'x> = quick_xml_serialize::CtRegionAreaLineXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtRegionAreaLineXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtRegionAreaLineXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtRegionAreaLine"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtRegionAreaLineXElementType {
        type Deserializer = quick_xml_deserialize::CtRegionAreaLineXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtRegionAreaOuadraticBezierXElementType {
        pub pointl: String,
        pub point_2: String,
    }
    impl WithSerializer for CtRegionAreaOuadraticBezierXElementType {
        type Serializer<'x> =
            quick_xml_serialize::CtRegionAreaOuadraticBezierXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtRegionAreaOuadraticBezierXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtRegionAreaOuadraticBezierXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtRegionAreaOuadraticBezier") , is_root , })
        }
    }
    impl WithDeserializer for CtRegionAreaOuadraticBezierXElementType {
        type Deserializer =
            quick_xml_deserialize::CtRegionAreaOuadraticBezierXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtRegionAreaCubicBezierXElementType {
        pub point_1: Option<String>,
        pub point_2: Option<String>,
        pub point_3: String,
    }
    impl WithSerializer for CtRegionAreaCubicBezierXElementType {
        type Serializer<'x> =
            quick_xml_serialize::CtRegionAreaCubicBezierXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtRegionAreaCubicBezierXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtRegionAreaCubicBezierXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtRegionAreaCubicBezier") , is_root , })
        }
    }
    impl WithDeserializer for CtRegionAreaCubicBezierXElementType {
        type Deserializer = quick_xml_deserialize::CtRegionAreaCubicBezierXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtRegionAreaArcXElementType {
        pub sweep_direction: bool,
        pub large_arc: bool,
        pub rotation_anglet: f64,
        pub ellipse_size: String,
        pub end_point: String,
    }
    impl WithSerializer for CtRegionAreaArcXElementType {
        type Serializer<'x> = quick_xml_serialize::CtRegionAreaArcXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtRegionAreaArcXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtRegionAreaArcXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtRegionAreaArc"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtRegionAreaArcXElementType {
        type Deserializer = quick_xml_deserialize::CtRegionAreaArcXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::{
            quick_xml::{
                BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact,
                DeserializerEvent, DeserializerOutput, DeserializerResult, ElementHandlerOutput,
                Error, ErrorKind, Event, RawByteStr, WithDeserializer,
            },
            xml::AnyElement,
        };
        #[derive(Debug)]
        pub struct CtActionXTypeDeserializer {
            event: super::CtActionEventXType,
            content: Vec<super::CtActionXTypeContent>,
            state__: Box<CtActionXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtActionXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtActionXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut event: Option<super::CtActionEventXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Event")
                    ) {
                        helper.read_attrib(&mut event, b"Event", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    event: event.ok_or_else(|| ErrorKind::MissingAttribute("Event".into()))?,
                    content: Vec::new(),
                    state__: Box::new(CtActionXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtActionXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::CtActionXTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtActionXTypeContent>,
                fallback: &mut Option<CtActionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        if self.content.len() < 1usize {
                            *fallback = Some(S::Content__(deserializer));
                            *self.state__ = S::Next__;
                            Ok(ElementHandlerOutput::from_event(event, allow_any))
                        } else {
                            *self.state__ = S::Content__(deserializer);
                            Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                        }
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtActionXType> for CtActionXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionXType> {
                use CtActionXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = <super::CtActionXTypeContent as WithDeserializer>::init(
                                helper, event,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionXType {
                    event: self.event,
                    content: helper.finish_vec(1usize, Some(2usize), self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtActionXTypeContentDeserializer {
            state__: Box<CtActionXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtActionXTypeContentDeserializerState {
            Init__,
            Region(
                Option<super::CtRegionXType>,
                Option<<super::CtRegionXType as WithDeserializer>::Deserializer>,
                Option<<super::CtRegionXType as WithDeserializer>::Deserializer>,
            ),
            Goto(
                Option<super::CtActionGotoXElementType>,
                Option<<super::CtActionGotoXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionGotoXElementType as WithDeserializer>::Deserializer>,
            ),
            Uri(
                Option<super::CtActionUriXElementType>,
                Option<<super::CtActionUriXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionUriXElementType as WithDeserializer>::Deserializer>,
            ),
            GotoA(
                Option<super::CtActionGotoAxElementType>,
                Option<<super::CtActionGotoAxElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionGotoAxElementType as WithDeserializer>::Deserializer>,
            ),
            Sound(
                Option<super::CtActionSoundXElementType>,
                Option<<super::CtActionSoundXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionSoundXElementType as WithDeserializer>::Deserializer>,
            ),
            Movie(
                Option<super::CtActionMovieXElementType>,
                Option<<super::CtActionMovieXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionMovieXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtActionXTypeContent),
            Unknown__,
        }
        impl CtActionXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Region")
                    ) {
                        let output =
                            <super::CtRegionXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_region(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Goto")
                    ) {
                        let output = <super::CtActionGotoXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_goto(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"URI")
                    ) {
                        let output = <super::CtActionUriXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_uri(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"GotoA")
                    ) {
                        let output = <super::CtActionGotoAxElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_goto_a(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Sound")
                    ) {
                        let output = <super::CtActionSoundXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_sound(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Movie")
                    ) {
                        let output = <super::CtActionMovieXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_movie(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtActionXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtActionXTypeContentDeserializerState,
            ) -> Result<super::CtActionXTypeContent, Error> {
                use CtActionXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Region(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_region(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::Region(
                            helper.finish_element("Region", values)?,
                        ))
                    }
                    S::Goto(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_goto(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::Goto(
                            helper.finish_element("Goto", values)?,
                        ))
                    }
                    S::Uri(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_uri(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::Uri(
                            helper.finish_element("URI", values)?,
                        ))
                    }
                    S::GotoA(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_goto_a(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::GotoA(
                            helper.finish_element("GotoA", values)?,
                        ))
                    }
                    S::Sound(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_sound(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::Sound(
                            helper.finish_element("Sound", values)?,
                        ))
                    }
                    S::Movie(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_movie(&mut values, value)?;
                        }
                        Ok(super::CtActionXTypeContent::Movie(
                            helper.finish_element("Movie", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_region(
                values: &mut Option<super::CtRegionXType>,
                value: super::CtRegionXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Region",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_goto(
                values: &mut Option<super::CtActionGotoXElementType>,
                value: super::CtActionGotoXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Goto")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_uri(
                values: &mut Option<super::CtActionUriXElementType>,
                value: super::CtActionUriXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"URI")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_goto_a(
                values: &mut Option<super::CtActionGotoAxElementType>,
                value: super::CtActionGotoAxElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"GotoA",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_sound(
                values: &mut Option<super::CtActionSoundXElementType>,
                value: super::CtActionSoundXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Sound",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_movie(
                values: &mut Option<super::CtActionMovieXElementType>,
                value: super::CtActionMovieXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Movie",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_region<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionXType>,
                fallback: Option<<super::CtRegionXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtRegionXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_region(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_region(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Region(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Region(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_goto<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionGotoXElementType>,
                fallback: Option<
                    <super::CtActionGotoXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionGotoXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_goto(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_goto(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Goto(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Goto(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_uri<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionUriXElementType>,
                fallback: Option<
                    <super::CtActionUriXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionUriXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_uri(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_uri(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Uri(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Uri(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_goto_a<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionGotoAxElementType>,
                fallback: Option<
                    <super::CtActionGotoAxElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionGotoAxElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_goto_a(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_goto_a(&mut values, data)?;
                        let data = Self::finish_state(helper, S::GotoA(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::GotoA(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_sound<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionSoundXElementType>,
                fallback: Option<
                    <super::CtActionSoundXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionSoundXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_sound(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_sound(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Sound(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Sound(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_movie<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionMovieXElementType>,
                fallback: Option<
                    <super::CtActionMovieXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionMovieXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_movie(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_movie(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Movie(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Movie(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtActionXTypeContent> for CtActionXTypeContentDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtActionXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state__, CtActionXTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionXTypeContent> {
                use CtActionXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Region(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_region(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Goto(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_goto(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Uri(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_uri(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::GotoA(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_goto_a(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Sound(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_sound(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Movie(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_movie(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Region(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Region",
                                true,
                            )?;
                            match self.handle_region(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Goto(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Goto",
                                false,
                            )?;
                            match self.handle_goto(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Uri(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"URI",
                                false,
                            )?;
                            match self.handle_uri(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::GotoA(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"GotoA",
                                false,
                            )?;
                            match self.handle_goto_a(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Sound(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Sound",
                                false,
                            )?;
                            match self.handle_sound(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Movie(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Movie",
                                false,
                            )?;
                            match self.handle_movie(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtDestXTypeDeserializer {
            type_: super::CtDestTypeXType,
            page_id: u32,
            left: Option<f64>,
            top: Option<f64>,
            right: Option<f64>,
            bottom: Option<f64>,
            zoom: Option<f64>,
            state__: Box<CtDestXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDestXTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtDestXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtDestTypeXType> = None;
                let mut page_id: Option<u32> = None;
                let mut left: Option<f64> = None;
                let mut top: Option<f64> = None;
                let mut right: Option<f64> = None;
                let mut bottom: Option<f64> = None;
                let mut zoom: Option<f64> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"PageID")
                    ) {
                        helper.read_attrib(&mut page_id, b"PageID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Left")
                    ) {
                        helper.read_attrib(&mut left, b"Left", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Top")
                    ) {
                        helper.read_attrib(&mut top, b"Top", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Right")
                    ) {
                        helper.read_attrib(&mut right, b"Right", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Bottom")
                    ) {
                        helper.read_attrib(&mut bottom, b"Bottom", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Zoom")
                    ) {
                        helper.read_attrib(&mut zoom, b"Zoom", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    page_id: page_id.ok_or_else(|| ErrorKind::MissingAttribute("PageID".into()))?,
                    left: left,
                    top: top,
                    right: right,
                    bottom: bottom,
                    zoom: zoom,
                    state__: Box::new(CtDestXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDestXTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtDestXType> for CtDestXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDestXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDestXType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDestXType, Error> {
                let state = replace(&mut *self.state__, CtDestXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtDestXType {
                    type_: self.type_,
                    page_id: self.page_id,
                    left: self.left,
                    top: self.top,
                    right: self.right,
                    bottom: self.bottom,
                    zoom: self.zoom,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageAreaXTypeDeserializer {
            physical_box: Option<String>,
            application_box: Option<String>,
            content_box: Option<String>,
            bleed_box: Option<String>,
            state__: Box<CtPageAreaXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageAreaXTypeDeserializerState {
            Init__,
            PhysicalBox(Option<<String as WithDeserializer>::Deserializer>),
            ApplicationBox(Option<<String as WithDeserializer>::Deserializer>),
            ContentBox(Option<<String as WithDeserializer>::Deserializer>),
            BleedBox(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtPageAreaXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    physical_box: None,
                    application_box: None,
                    content_box: None,
                    bleed_box: None,
                    state__: Box::new(CtPageAreaXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageAreaXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPageAreaXTypeDeserializerState as S;
                match state {
                    S::PhysicalBox(Some(deserializer)) => {
                        self.store_physical_box(deserializer.finish(helper)?)?
                    }
                    S::ApplicationBox(Some(deserializer)) => {
                        self.store_application_box(deserializer.finish(helper)?)?
                    }
                    S::ContentBox(Some(deserializer)) => {
                        self.store_content_box(deserializer.finish(helper)?)?
                    }
                    S::BleedBox(Some(deserializer)) => {
                        self.store_bleed_box(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_physical_box(&mut self, value: String) -> Result<(), Error> {
                if self.physical_box.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PhysicalBox",
                    )))?;
                }
                self.physical_box = Some(value);
                Ok(())
            }
            fn store_application_box(&mut self, value: String) -> Result<(), Error> {
                if self.application_box.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ApplicationBox",
                    )))?;
                }
                self.application_box = Some(value);
                Ok(())
            }
            fn store_content_box(&mut self, value: String) -> Result<(), Error> {
                if self.content_box.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ContentBox",
                    )))?;
                }
                self.content_box = Some(value);
                Ok(())
            }
            fn store_bleed_box(&mut self, value: String) -> Result<(), Error> {
                if self.bleed_box.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"BleedBox",
                    )))?;
                }
                self.bleed_box = Some(value);
                Ok(())
            }
            fn handle_physical_box<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageAreaXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::PhysicalBox(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_physical_box(data)?;
                        *self.state__ = S::ApplicationBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::PhysicalBox(Some(deserializer)));
                        *self.state__ = S::ApplicationBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_application_box<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageAreaXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::ApplicationBox(None));
                    *self.state__ = S::ContentBox(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_application_box(data)?;
                        *self.state__ = S::ContentBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::ApplicationBox(Some(deserializer)));
                        *self.state__ = S::ContentBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_content_box<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageAreaXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::ContentBox(None));
                    *self.state__ = S::BleedBox(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content_box(data)?;
                        *self.state__ = S::BleedBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::ContentBox(Some(deserializer)));
                        *self.state__ = S::BleedBox(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_bleed_box<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPageAreaXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageAreaXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::BleedBox(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_bleed_box(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::BleedBox(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageAreaXType> for CtPageAreaXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageAreaXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageAreaXType> {
                use CtPageAreaXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::PhysicalBox(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_physical_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ApplicationBox(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_application_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ContentBox(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BleedBox(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_bleed_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::PhysicalBox(None);
                            event
                        }
                        (S::PhysicalBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PhysicalBox",
                                false,
                            )?;
                            match self.handle_physical_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ApplicationBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ApplicationBox",
                                false,
                            )?;
                            match self.handle_application_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ContentBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ContentBox",
                                false,
                            )?;
                            match self.handle_content_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BleedBox(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"BleedBox",
                                false,
                            )?;
                            match self.handle_bleed_box(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageAreaXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageAreaXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageAreaXType {
                    physical_box: helper.finish_element("PhysicalBox", self.physical_box)?,
                    application_box: self.application_box,
                    content_box: self.content_box,
                    bleed_box: self.bleed_box,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionXTypeDeserializer {
            area: Vec<super::CtRegionAreaXElementType>,
            state__: Box<CtRegionXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionXTypeDeserializerState {
            Init__,
            Area(Option<<super::CtRegionAreaXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtRegionXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    area: Vec::new(),
                    state__: Box::new(CtRegionXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtRegionXTypeDeserializerState as S;
                match state {
                    S::Area(Some(deserializer)) => self.store_area(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_area(&mut self, value: super::CtRegionAreaXElementType) -> Result<(), Error> {
                self.area.push(value);
                Ok(())
            }
            fn handle_area<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtRegionAreaXElementType>,
                fallback: &mut Option<CtRegionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.area.len() < 1usize {
                        fallback.get_or_insert(S::Area(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Area(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_area(data)?;
                        *self.state__ = S::Area(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Area(Some(deserializer)));
                        *self.state__ = S::Area(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionXType> for CtRegionXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionXType> {
                use CtRegionXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Area(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Area(None);
                            event
                        }
                        (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Area",
                                true,
                            )?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionXType {
                    area: helper.finish_vec(1usize, None, self.area)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoXElementTypeDeserializer {
            state__: Box<CtActionGotoXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtActionGotoXElementTypeDeserializerState {
            Init__,
            Dest(
                Option<super::CtDestXType>,
                Option<<super::CtDestXType as WithDeserializer>::Deserializer>,
                Option<<super::CtDestXType as WithDeserializer>::Deserializer>,
            ),
            Bookmark(
                Option<super::CtActionGotoBookmarkXElementType>,
                Option<<super::CtActionGotoBookmarkXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtActionGotoBookmarkXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtActionGotoXElementType),
            Unknown__,
        }
        impl CtActionGotoXElementTypeDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Dest")
                    ) {
                        let output = <super::CtDestXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_dest(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Bookmark")
                    ) {
                        let output =
                            <super::CtActionGotoBookmarkXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_bookmark(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtActionGotoXElementTypeDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    state__: Box::new(CtActionGotoXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtActionGotoXElementTypeDeserializerState,
            ) -> Result<super::CtActionGotoXElementType, Error> {
                use CtActionGotoXElementTypeDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Dest(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_dest(&mut values, value)?;
                        }
                        Ok(super::CtActionGotoXElementType::Dest(
                            helper.finish_element("Dest", values)?,
                        ))
                    }
                    S::Bookmark(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_bookmark(&mut values, value)?;
                        }
                        Ok(super::CtActionGotoXElementType::Bookmark(
                            helper.finish_element("Bookmark", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_dest(
                values: &mut Option<super::CtDestXType>,
                value: super::CtDestXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Dest")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_bookmark(
                values: &mut Option<super::CtActionGotoBookmarkXElementType>,
                value: super::CtActionGotoBookmarkXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Bookmark",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_dest<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtDestXType>,
                fallback: Option<<super::CtDestXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtDestXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionGotoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_dest(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_dest(&mut values, data)?;
                        *self.state__ = S::Dest(values, None, None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Dest(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                    }
                }
            }
            fn handle_bookmark<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtActionGotoBookmarkXElementType>,
                fallback: Option<
                    <super::CtActionGotoBookmarkXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtActionGotoBookmarkXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtActionGotoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_bookmark(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_bookmark(&mut values, data)?;
                        *self.state__ = S::Bookmark(values, None, None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Bookmark(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtActionGotoXElementType>
            for CtActionGotoXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoXElementType> {
                use CtActionGotoXElementTypeDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Dest(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_dest(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Bookmark(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_bookmark(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Dest(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Dest",
                                false,
                            )?;
                            match self.handle_dest(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Bookmark(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Bookmark",
                                false,
                            )?;
                            match self.handle_bookmark(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionGotoXElementType, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtActionUriXElementTypeDeserializer {
            uri: String,
            base: Option<String>,
            target: Option<String>,
            state__: Box<CtActionUriXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionUriXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtActionUriXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut uri: Option<String> = None;
                let mut base: Option<String> = None;
                let mut target: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"URI")
                    ) {
                        helper.read_attrib(&mut uri, b"URI", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Base")
                    ) {
                        helper.read_attrib(&mut base, b"Base", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Target")
                    ) {
                        helper.read_attrib(&mut target, b"Target", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    uri: uri.ok_or_else(|| ErrorKind::MissingAttribute("URI".into()))?,
                    base: base,
                    target: target,
                    state__: Box::new(CtActionUriXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionUriXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtActionUriXElementType>
            for CtActionUriXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionUriXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionUriXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionUriXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionUriXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionUriXElementType {
                    uri: self.uri,
                    base: self.base,
                    target: self.target,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoAxElementTypeDeserializer {
            attach_id: String,
            new_window: bool,
            state__: Box<CtActionGotoAxElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionGotoAxElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtActionGotoAxElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut attach_id: Option<String> = None;
                let mut new_window: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"AttachID")
                    ) {
                        helper.read_attrib(&mut attach_id, b"AttachID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"NewWindow")
                    ) {
                        helper.read_attrib(&mut new_window, b"NewWindow", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    attach_id: attach_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("AttachID".into()))?,
                    new_window: new_window
                        .unwrap_or_else(super::CtActionGotoAxElementType::default_new_window),
                    state__: Box::new(CtActionGotoAxElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionGotoAxElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtActionGotoAxElementType>
            for CtActionGotoAxElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoAxElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoAxElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionGotoAxElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionGotoAxElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionGotoAxElementType {
                    attach_id: self.attach_id,
                    new_window: self.new_window,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtActionSoundXElementTypeDeserializer {
            resource_id: u32,
            volume: Option<i32>,
            repeat: Option<bool>,
            synchronous: Option<bool>,
            state__: Box<CtActionSoundXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionSoundXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtActionSoundXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut resource_id: Option<u32> = None;
                let mut volume: Option<i32> = None;
                let mut repeat: Option<bool> = None;
                let mut synchronous: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Volume")
                    ) {
                        helper.read_attrib(&mut volume, b"Volume", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Repeat")
                    ) {
                        helper.read_attrib(&mut repeat, b"Repeat", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Synchronous")
                    ) {
                        helper.read_attrib(&mut synchronous, b"Synchronous", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    volume: volume,
                    repeat: repeat,
                    synchronous: synchronous,
                    state__: Box::new(CtActionSoundXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionSoundXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtActionSoundXElementType>
            for CtActionSoundXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionSoundXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionSoundXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionSoundXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionSoundXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionSoundXElementType {
                    resource_id: self.resource_id,
                    volume: self.volume,
                    repeat: self.repeat,
                    synchronous: self.synchronous,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtActionMovieXElementTypeDeserializer {
            resource_id: u32,
            operator: super::CtActionMovieOperatorXType,
            state__: Box<CtActionMovieXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionMovieXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtActionMovieXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut resource_id: Option<u32> = None;
                let mut operator: Option<super::CtActionMovieOperatorXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Operator")
                    ) {
                        helper.read_attrib(&mut operator, b"Operator", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    operator: operator
                        .unwrap_or_else(super::CtActionMovieXElementType::default_operator),
                    state__: Box::new(CtActionMovieXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionMovieXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtActionMovieXElementType>
            for CtActionMovieXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionMovieXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionMovieXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionMovieXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionMovieXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionMovieXElementType {
                    resource_id: self.resource_id,
                    operator: self.operator,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaXElementTypeDeserializer {
            start: String,
            content: Vec<super::CtRegionAreaXElementTypeContent>,
            state__: Box<CtRegionAreaXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionAreaXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtRegionAreaXElementTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtRegionAreaXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut start: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Start")
                    ) {
                        helper.read_attrib(&mut start, b"Start", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    start: start.ok_or_else(|| ErrorKind::MissingAttribute("Start".into()))?,
                    content: Vec::new(),
                    state__: Box::new(CtRegionAreaXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionAreaXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtRegionAreaXElementTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtRegionAreaXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtRegionAreaXElementTypeContent>,
                fallback: &mut Option<CtRegionAreaXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaXElementType>
            for CtRegionAreaXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaXElementType> {
                use CtRegionAreaXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::CtRegionAreaXElementTypeContent as WithDeserializer>::init(
                                    helper, event,
                                )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionAreaXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionAreaXElementType {
                    start: self.start,
                    content: helper.finish_vec(1usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaXElementTypeContentDeserializer {
            state__: Box<CtRegionAreaXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtRegionAreaXElementTypeContentDeserializerState {
            Init__ , Move (Option < super :: CtRegionAreaLineXElementType > , Option << super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer > ,) , Line (Option < super :: CtRegionAreaLineXElementType > , Option << super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtRegionAreaLineXElementType as WithDeserializer > :: Deserializer > ,) , OuadraticBezier (Option < super :: CtRegionAreaOuadraticBezierXElementType > , Option << super :: CtRegionAreaOuadraticBezierXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtRegionAreaOuadraticBezierXElementType as WithDeserializer > :: Deserializer > ,) , CubicBezier (Option < super :: CtRegionAreaCubicBezierXElementType > , Option << super :: CtRegionAreaCubicBezierXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtRegionAreaCubicBezierXElementType as WithDeserializer > :: Deserializer > ,) , Arc (Option < super :: CtRegionAreaArcXElementType > , Option << super :: CtRegionAreaArcXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtRegionAreaArcXElementType as WithDeserializer > :: Deserializer > ,) , Close (Option < AnyElement > , Option << AnyElement as WithDeserializer > :: Deserializer > , Option << AnyElement as WithDeserializer > :: Deserializer > ,) , Done__ (super :: CtRegionAreaXElementTypeContent) , Unknown__ , }
        impl CtRegionAreaXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Move")
                    ) {
                        let output =
                            <super::CtRegionAreaLineXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_move_(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Line")
                    ) {
                        let output =
                            <super::CtRegionAreaLineXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_line(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"OuadraticBezier")
                    ) {
                        let output = < super :: CtRegionAreaOuadraticBezierXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_ouadratic_bezier(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CubicBezier")
                    ) {
                        let output =
                            <super::CtRegionAreaCubicBezierXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_cubic_bezier(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Arc")
                    ) {
                        let output =
                            <super::CtRegionAreaArcXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_arc(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Close")
                    ) {
                        let output = <AnyElement as WithDeserializer>::init(helper, event)?;
                        return self.handle_close(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtRegionAreaXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtRegionAreaXElementTypeContentDeserializerState,
            ) -> Result<super::CtRegionAreaXElementTypeContent, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Move(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_move_(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::Move(
                            helper.finish_element("Move", values)?,
                        ))
                    }
                    S::Line(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_line(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::Line(
                            helper.finish_element("Line", values)?,
                        ))
                    }
                    S::OuadraticBezier(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_ouadratic_bezier(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::OuadraticBezier(
                            helper.finish_element("OuadraticBezier", values)?,
                        ))
                    }
                    S::CubicBezier(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_cubic_bezier(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::CubicBezier(
                            helper.finish_element("CubicBezier", values)?,
                        ))
                    }
                    S::Arc(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_arc(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::Arc(
                            helper.finish_element("Arc", values)?,
                        ))
                    }
                    S::Close(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_close(&mut values, value)?;
                        }
                        Ok(super::CtRegionAreaXElementTypeContent::Close(
                            helper.finish_element("Close", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_move_(
                values: &mut Option<super::CtRegionAreaLineXElementType>,
                value: super::CtRegionAreaLineXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Move")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_line(
                values: &mut Option<super::CtRegionAreaLineXElementType>,
                value: super::CtRegionAreaLineXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Line")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_ouadratic_bezier(
                values: &mut Option<super::CtRegionAreaOuadraticBezierXElementType>,
                value: super::CtRegionAreaOuadraticBezierXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"OuadraticBezier",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_cubic_bezier(
                values: &mut Option<super::CtRegionAreaCubicBezierXElementType>,
                value: super::CtRegionAreaCubicBezierXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CubicBezier",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_arc(
                values: &mut Option<super::CtRegionAreaArcXElementType>,
                value: super::CtRegionAreaArcXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Arc")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_close(
                values: &mut Option<AnyElement>,
                value: AnyElement,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Close",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_move_<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionAreaLineXElementType>,
                fallback: Option<
                    <super::CtRegionAreaLineXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtRegionAreaLineXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_move_(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_move_(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Move(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Move(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_line<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionAreaLineXElementType>,
                fallback: Option<
                    <super::CtRegionAreaLineXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtRegionAreaLineXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_line(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_line(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Line(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Line(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_ouadratic_bezier<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionAreaOuadraticBezierXElementType>,
                fallback : Option << super :: CtRegionAreaOuadraticBezierXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtRegionAreaOuadraticBezierXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_ouadratic_bezier(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_ouadratic_bezier(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::OuadraticBezier(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::OuadraticBezier(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_cubic_bezier<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionAreaCubicBezierXElementType>,
                fallback: Option<
                    <super::CtRegionAreaCubicBezierXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtRegionAreaCubicBezierXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_cubic_bezier(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_cubic_bezier(&mut values, data)?;
                        let data = Self::finish_state(helper, S::CubicBezier(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CubicBezier(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_arc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRegionAreaArcXElementType>,
                fallback: Option<
                    <super::CtRegionAreaArcXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtRegionAreaArcXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_arc(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_arc(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Arc(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Arc(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_close<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<AnyElement>,
                fallback: Option<<AnyElement as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, AnyElement>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_close(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_close(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Close(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Close(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaXElementTypeContent>
            for CtRegionAreaXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaXElementTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtRegionAreaXElementTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtRegionAreaXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaXElementTypeContent> {
                use CtRegionAreaXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Move(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_move_(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Line(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_line(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::OuadraticBezier(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_ouadratic_bezier(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CubicBezier(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cubic_bezier(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Arc(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_arc(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Close(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_close(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Move(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Move",
                                false,
                            )?;
                            match self.handle_move_(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Line(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Line",
                                false,
                            )?;
                            match self.handle_line(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::OuadraticBezier(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"OuadraticBezier",
                                false,
                            )?;
                            match self.handle_ouadratic_bezier(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CubicBezier(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CubicBezier",
                                false,
                            )?;
                            match self.handle_cubic_bezier(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Arc(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Arc",
                                false,
                            )?;
                            match self.handle_arc(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Close(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Close",
                                true,
                            )?;
                            match self.handle_close(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoBookmarkXElementTypeDeserializer {
            name: String,
            state__: Box<CtActionGotoBookmarkXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtActionGotoBookmarkXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtActionGotoBookmarkXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut name: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| ErrorKind::MissingAttribute("Name".into()))?,
                    state__: Box::new(CtActionGotoBookmarkXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtActionGotoBookmarkXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtActionGotoBookmarkXElementType>
            for CtActionGotoBookmarkXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoBookmarkXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtActionGotoBookmarkXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtActionGotoBookmarkXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtActionGotoBookmarkXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtActionGotoBookmarkXElementType { name: self.name })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaLineXElementTypeDeserializer {
            point_1: String,
            state__: Box<CtRegionAreaLineXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionAreaLineXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtRegionAreaLineXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut point_1: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Point1")
                    ) {
                        helper.read_attrib(&mut point_1, b"Point1", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    point_1: point_1.ok_or_else(|| ErrorKind::MissingAttribute("Point1".into()))?,
                    state__: Box::new(CtRegionAreaLineXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionAreaLineXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaLineXElementType>
            for CtRegionAreaLineXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaLineXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaLineXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaLineXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionAreaLineXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionAreaLineXElementType {
                    point_1: self.point_1,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaOuadraticBezierXElementTypeDeserializer {
            pointl: String,
            point_2: String,
            state__: Box<CtRegionAreaOuadraticBezierXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionAreaOuadraticBezierXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtRegionAreaOuadraticBezierXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut pointl: Option<String> = None;
                let mut point_2: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Pointl")
                    ) {
                        helper.read_attrib(&mut pointl, b"Pointl", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Point2")
                    ) {
                        helper.read_attrib(&mut point_2, b"Point2", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    pointl: pointl.ok_or_else(|| ErrorKind::MissingAttribute("Pointl".into()))?,
                    point_2: point_2.ok_or_else(|| ErrorKind::MissingAttribute("Point2".into()))?,
                    state__: Box::new(
                        CtRegionAreaOuadraticBezierXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionAreaOuadraticBezierXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaOuadraticBezierXElementType>
            for CtRegionAreaOuadraticBezierXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaOuadraticBezierXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaOuadraticBezierXElementType>
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaOuadraticBezierXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionAreaOuadraticBezierXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionAreaOuadraticBezierXElementType {
                    pointl: self.pointl,
                    point_2: self.point_2,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaCubicBezierXElementTypeDeserializer {
            point_1: Option<String>,
            point_2: Option<String>,
            point_3: String,
            state__: Box<CtRegionAreaCubicBezierXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionAreaCubicBezierXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtRegionAreaCubicBezierXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut point_1: Option<String> = None;
                let mut point_2: Option<String> = None;
                let mut point_3: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Point1")
                    ) {
                        helper.read_attrib(&mut point_1, b"Point1", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Point2")
                    ) {
                        helper.read_attrib(&mut point_2, b"Point2", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Point3")
                    ) {
                        helper.read_attrib(&mut point_3, b"Point3", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    point_1: point_1,
                    point_2: point_2,
                    point_3: point_3.ok_or_else(|| ErrorKind::MissingAttribute("Point3".into()))?,
                    state__: Box::new(CtRegionAreaCubicBezierXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionAreaCubicBezierXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaCubicBezierXElementType>
            for CtRegionAreaCubicBezierXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaCubicBezierXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaCubicBezierXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaCubicBezierXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionAreaCubicBezierXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionAreaCubicBezierXElementType {
                    point_1: self.point_1,
                    point_2: self.point_2,
                    point_3: self.point_3,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaArcXElementTypeDeserializer {
            sweep_direction: bool,
            large_arc: bool,
            rotation_anglet: f64,
            ellipse_size: String,
            end_point: String,
            state__: Box<CtRegionAreaArcXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRegionAreaArcXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtRegionAreaArcXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut sweep_direction: Option<bool> = None;
                let mut large_arc: Option<bool> = None;
                let mut rotation_anglet: Option<f64> = None;
                let mut ellipse_size: Option<String> = None;
                let mut end_point: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"SweepDirection")
                    ) {
                        helper.read_attrib(
                            &mut sweep_direction,
                            b"SweepDirection",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LargeArc")
                    ) {
                        helper.read_attrib(&mut large_arc, b"LargeArc", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"RotationAnglet")
                    ) {
                        helper.read_attrib(
                            &mut rotation_anglet,
                            b"RotationAnglet",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EllipseSize")
                    ) {
                        helper.read_attrib(&mut ellipse_size, b"EllipseSize", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EndPoint")
                    ) {
                        helper.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    sweep_direction: sweep_direction
                        .ok_or_else(|| ErrorKind::MissingAttribute("SweepDirection".into()))?,
                    large_arc: large_arc
                        .ok_or_else(|| ErrorKind::MissingAttribute("LargeArc".into()))?,
                    rotation_anglet: rotation_anglet
                        .ok_or_else(|| ErrorKind::MissingAttribute("RotationAnglet".into()))?,
                    ellipse_size: ellipse_size
                        .ok_or_else(|| ErrorKind::MissingAttribute("EllipseSize".into()))?,
                    end_point: end_point
                        .ok_or_else(|| ErrorKind::MissingAttribute("EndPoint".into()))?,
                    state__: Box::new(CtRegionAreaArcXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRegionAreaArcXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtRegionAreaArcXElementType>
            for CtRegionAreaArcXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaArcXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRegionAreaArcXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRegionAreaArcXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRegionAreaArcXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRegionAreaArcXElementType {
                    sweep_direction: self.sweep_direction,
                    large_arc: self.large_arc,
                    rotation_anglet: self.rotation_anglet,
                    ellipse_size: self.ellipse_size,
                    end_point: self.end_point,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::{
            quick_xml::{
                BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
                WithSerializer,
            },
            xml::AnyElement,
        };
        #[derive(Debug)]
        pub struct CtActionXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionXType,
            pub(super) state: Box<CtActionXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtActionXTypeContent],
                    super::CtActionXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionXTypeSerializerState::Init__ => {
                            *self.state = CtActionXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Event", &self.value.event)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtActionXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeSerializerState::End__,
                            }
                        }
                        CtActionXTypeSerializerState::End__ => {
                            *self.state = CtActionXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtActionXTypeSerializerState::Done__ => return Ok(None),
                        CtActionXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtActionXTypeContent,
            pub(super) state: Box<CtActionXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtActionXTypeContentSerializerState<'ser> {
            Init__,
            Region(<super::CtRegionXType as WithSerializer>::Serializer<'ser>),
            Goto(<super::CtActionGotoXElementType as WithSerializer>::Serializer<'ser>),
            Uri(<super::CtActionUriXElementType as WithSerializer>::Serializer<'ser>),
            GotoA(<super::CtActionGotoAxElementType as WithSerializer>::Serializer<'ser>),
            Sound(<super::CtActionSoundXElementType as WithSerializer>::Serializer<'ser>),
            Movie(<super::CtActionMovieXElementType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionXTypeContentSerializerState::Init__ => match self.value {
                            super::CtActionXTypeContent::Region(x) => {
                                *self.state = CtActionXTypeContentSerializerState::Region(
                                    WithSerializer::serializer(x, Some("Region"), false)?,
                                )
                            }
                            super::CtActionXTypeContent::Goto(x) => {
                                *self.state = CtActionXTypeContentSerializerState::Goto(
                                    WithSerializer::serializer(x, Some("Goto"), false)?,
                                )
                            }
                            super::CtActionXTypeContent::Uri(x) => {
                                *self.state = CtActionXTypeContentSerializerState::Uri(
                                    WithSerializer::serializer(x, Some("URI"), false)?,
                                )
                            }
                            super::CtActionXTypeContent::GotoA(x) => {
                                *self.state = CtActionXTypeContentSerializerState::GotoA(
                                    WithSerializer::serializer(x, Some("GotoA"), false)?,
                                )
                            }
                            super::CtActionXTypeContent::Sound(x) => {
                                *self.state = CtActionXTypeContentSerializerState::Sound(
                                    WithSerializer::serializer(x, Some("Sound"), false)?,
                                )
                            }
                            super::CtActionXTypeContent::Movie(x) => {
                                *self.state = CtActionXTypeContentSerializerState::Movie(
                                    WithSerializer::serializer(x, Some("Movie"), false)?,
                                )
                            }
                        },
                        CtActionXTypeContentSerializerState::Region(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::Goto(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::Uri(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::GotoA(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::Sound(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::Movie(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtActionXTypeContentSerializerState::Done__,
                            }
                        }
                        CtActionXTypeContentSerializerState::Done__ => return Ok(None),
                        CtActionXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtDestXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDestXType,
            pub(super) state: Box<CtDestXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDestXTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDestXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtDestXTypeSerializerState::Init__ => {
                            *self.state = CtDestXTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib(&mut bytes, "PageID", &self.value.page_id)?;
                            helper.write_attrib_opt(&mut bytes, "Left", &self.value.left)?;
                            helper.write_attrib_opt(&mut bytes, "Top", &self.value.top)?;
                            helper.write_attrib_opt(&mut bytes, "Right", &self.value.right)?;
                            helper.write_attrib_opt(&mut bytes, "Bottom", &self.value.bottom)?;
                            helper.write_attrib_opt(&mut bytes, "Zoom", &self.value.zoom)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtDestXTypeSerializerState::Done__ => return Ok(None),
                        CtDestXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDestXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtDestXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageAreaXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageAreaXType,
            pub(super) state: Box<CtPageAreaXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageAreaXTypeSerializerState<'ser> {
            Init__,
            PhysicalBox(<String as WithSerializer>::Serializer<'ser>),
            ApplicationBox(IterSerializer<'ser, Option<&'ser String>, String>),
            ContentBox(IterSerializer<'ser, Option<&'ser String>, String>),
            BleedBox(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageAreaXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageAreaXTypeSerializerState::Init__ => {
                            *self.state = CtPageAreaXTypeSerializerState::PhysicalBox(
                                WithSerializer::serializer(
                                    &self.value.physical_box,
                                    Some("PhysicalBox"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageAreaXTypeSerializerState::PhysicalBox(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageAreaXTypeSerializerState::ApplicationBox(
                                        IterSerializer::new(
                                            self.value.application_box.as_ref(),
                                            Some("ApplicationBox"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPageAreaXTypeSerializerState::ApplicationBox(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageAreaXTypeSerializerState::ContentBox(
                                        IterSerializer::new(
                                            self.value.content_box.as_ref(),
                                            Some("ContentBox"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPageAreaXTypeSerializerState::ContentBox(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageAreaXTypeSerializerState::BleedBox(
                                        IterSerializer::new(
                                            self.value.bleed_box.as_ref(),
                                            Some("BleedBox"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPageAreaXTypeSerializerState::BleedBox(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtPageAreaXTypeSerializerState::End__,
                            }
                        }
                        CtPageAreaXTypeSerializerState::End__ => {
                            *self.state = CtPageAreaXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageAreaXTypeSerializerState::Done__ => return Ok(None),
                        CtPageAreaXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageAreaXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageAreaXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionXType,
            pub(super) state: Box<CtRegionXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionXTypeSerializerState<'ser> {
            Init__,
            Area(
                IterSerializer<
                    'ser,
                    &'ser [super::CtRegionAreaXElementType],
                    super::CtRegionAreaXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionXTypeSerializerState::Init__ => {
                            *self.state = CtRegionXTypeSerializerState::Area(IterSerializer::new(
                                &self.value.area[..],
                                Some("Area"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtRegionXTypeSerializerState::Area(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtRegionXTypeSerializerState::End__,
                            }
                        }
                        CtRegionXTypeSerializerState::End__ => {
                            *self.state = CtRegionXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtRegionXTypeSerializerState::Done__ => return Ok(None),
                        CtRegionXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionGotoXElementType,
            pub(super) state: Box<CtActionGotoXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionGotoXElementTypeSerializerState<'ser> {
            Init__,
            Dest(<super::CtDestXType as WithSerializer>::Serializer<'ser>),
            Bookmark(<super::CtActionGotoBookmarkXElementType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionGotoXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionGotoXElementTypeSerializerState::Init__ => {
                            match self.value {
                                super::CtActionGotoXElementType::Dest(x) => {
                                    *self.state = CtActionGotoXElementTypeSerializerState::Dest(
                                        WithSerializer::serializer(x, Some("Dest"), self.is_root)?,
                                    )
                                }
                                super::CtActionGotoXElementType::Bookmark(x) => {
                                    *self.state = CtActionGotoXElementTypeSerializerState::Bookmark(
                                        WithSerializer::serializer(
                                            x,
                                            Some("Bookmark"),
                                            self.is_root,
                                        )?,
                                    )
                                }
                            }
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtActionGotoXElementTypeSerializerState::Dest(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtActionGotoXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtActionGotoXElementTypeSerializerState::Bookmark(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtActionGotoXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtActionGotoXElementTypeSerializerState::End__ => {
                            *self.state = CtActionGotoXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtActionGotoXElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionGotoXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionGotoXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionGotoXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionUriXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionUriXElementType,
            pub(super) state: Box<CtActionUriXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionUriXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionUriXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionUriXElementTypeSerializerState::Init__ => {
                            *self.state = CtActionUriXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "URI", &self.value.uri)?;
                            helper.write_attrib_opt(&mut bytes, "Base", &self.value.base)?;
                            helper.write_attrib_opt(&mut bytes, "Target", &self.value.target)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtActionUriXElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionUriXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionUriXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionUriXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoAxElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionGotoAxElementType,
            pub(super) state: Box<CtActionGotoAxElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionGotoAxElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionGotoAxElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionGotoAxElementTypeSerializerState::Init__ => {
                            *self.state = CtActionGotoAxElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "AttachID", &self.value.attach_id)?;
                            helper.write_attrib(&mut bytes, "NewWindow", &self.value.new_window)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtActionGotoAxElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionGotoAxElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionGotoAxElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionGotoAxElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionSoundXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionSoundXElementType,
            pub(super) state: Box<CtActionSoundXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionSoundXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionSoundXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionSoundXElementTypeSerializerState::Init__ => {
                            *self.state = CtActionSoundXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Volume", &self.value.volume)?;
                            helper.write_attrib_opt(&mut bytes, "Repeat", &self.value.repeat)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Synchronous",
                                &self.value.synchronous,
                            )?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtActionSoundXElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionSoundXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionSoundXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionSoundXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionMovieXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionMovieXElementType,
            pub(super) state: Box<CtActionMovieXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionMovieXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionMovieXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionMovieXElementTypeSerializerState::Init__ => {
                            *self.state = CtActionMovieXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            helper.write_attrib(&mut bytes, "Operator", &self.value.operator)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtActionMovieXElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionMovieXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionMovieXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionMovieXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaXElementType,
            pub(super) state: Box<CtRegionAreaXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtRegionAreaXElementTypeContent],
                    super::CtRegionAreaXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaXElementTypeSerializerState::Init__ => {
                            *self.state = CtRegionAreaXElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Start", &self.value.start)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtRegionAreaXElementTypeSerializerState::Content__(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtRegionAreaXElementTypeSerializerState::End__,
                        },
                        CtRegionAreaXElementTypeSerializerState::End__ => {
                            *self.state = CtRegionAreaXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtRegionAreaXElementTypeSerializerState::Done__ => return Ok(None),
                        CtRegionAreaXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionAreaXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaXElementTypeContent,
            pub(super) state: Box<CtRegionAreaXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaXElementTypeContentSerializerState<'ser> {
            Init__,
            Move(<super::CtRegionAreaLineXElementType as WithSerializer>::Serializer<'ser>),
            Line(<super::CtRegionAreaLineXElementType as WithSerializer>::Serializer<'ser>),
            OuadraticBezier(
                <super::CtRegionAreaOuadraticBezierXElementType as WithSerializer>::Serializer<
                    'ser,
                >,
            ),
            CubicBezier(
                <super::CtRegionAreaCubicBezierXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Arc(<super::CtRegionAreaArcXElementType as WithSerializer>::Serializer<'ser>),
            Close(<AnyElement as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaXElementTypeContentSerializerState::Init__ => match self.value {
                            super::CtRegionAreaXElementTypeContent::Move(x) => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Move(
                                    WithSerializer::serializer(x, Some("Move"), false)?,
                                )
                            }
                            super::CtRegionAreaXElementTypeContent::Line(x) => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Line(
                                    WithSerializer::serializer(x, Some("Line"), false)?,
                                )
                            }
                            super::CtRegionAreaXElementTypeContent::OuadraticBezier(x) => {
                                *self.state =
                                    CtRegionAreaXElementTypeContentSerializerState::OuadraticBezier(
                                        WithSerializer::serializer(
                                            x,
                                            Some("OuadraticBezier"),
                                            false,
                                        )?,
                                    )
                            }
                            super::CtRegionAreaXElementTypeContent::CubicBezier(x) => {
                                *self.state =
                                    CtRegionAreaXElementTypeContentSerializerState::CubicBezier(
                                        WithSerializer::serializer(x, Some("CubicBezier"), false)?,
                                    )
                            }
                            super::CtRegionAreaXElementTypeContent::Arc(x) => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Arc(
                                    WithSerializer::serializer(x, Some("Arc"), false)?,
                                )
                            }
                            super::CtRegionAreaXElementTypeContent::Close(x) => {
                                *self.state = CtRegionAreaXElementTypeContentSerializerState::Close(
                                    WithSerializer::serializer(x, Some("Close"), false)?,
                                )
                            }
                        },
                        CtRegionAreaXElementTypeContentSerializerState::Move(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::Line(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::OuadraticBezier(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::CubicBezier(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::Arc(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::Close(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtRegionAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtRegionAreaXElementTypeContentSerializerState::Done__ => return Ok(None),
                        CtRegionAreaXElementTypeContentSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionAreaXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtActionGotoBookmarkXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtActionGotoBookmarkXElementType,
            pub(super) state: Box<CtActionGotoBookmarkXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtActionGotoBookmarkXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtActionGotoBookmarkXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtActionGotoBookmarkXElementTypeSerializerState::Init__ => {
                            *self.state = CtActionGotoBookmarkXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Name", &self.value.name)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtActionGotoBookmarkXElementTypeSerializerState::Done__ => return Ok(None),
                        CtActionGotoBookmarkXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtActionGotoBookmarkXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtActionGotoBookmarkXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaLineXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaLineXElementType,
            pub(super) state: Box<CtRegionAreaLineXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaLineXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaLineXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaLineXElementTypeSerializerState::Init__ => {
                            *self.state = CtRegionAreaLineXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Point1", &self.value.point_1)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtRegionAreaLineXElementTypeSerializerState::Done__ => return Ok(None),
                        CtRegionAreaLineXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaLineXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionAreaLineXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaOuadraticBezierXElementType,
            pub(super) state: Box<CtRegionAreaOuadraticBezierXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaOuadraticBezierXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaOuadraticBezierXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Pointl", &self.value.pointl)?;
                            helper.write_attrib(&mut bytes, "Point2", &self.value.point_2)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtRegionAreaOuadraticBezierXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaOuadraticBezierXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            CtRegionAreaOuadraticBezierXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaCubicBezierXElementType,
            pub(super) state: Box<CtRegionAreaCubicBezierXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaCubicBezierXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaCubicBezierXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtRegionAreaCubicBezierXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(&mut bytes, "Point1", &self.value.point_1)?;
                            helper.write_attrib_opt(&mut bytes, "Point2", &self.value.point_2)?;
                            helper.write_attrib(&mut bytes, "Point3", &self.value.point_3)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtRegionAreaCubicBezierXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtRegionAreaCubicBezierXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaCubicBezierXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionAreaCubicBezierXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRegionAreaArcXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRegionAreaArcXElementType,
            pub(super) state: Box<CtRegionAreaArcXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRegionAreaArcXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRegionAreaArcXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRegionAreaArcXElementTypeSerializerState::Init__ => {
                            *self.state = CtRegionAreaArcXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "SweepDirection",
                                &self.value.sweep_direction,
                            )?;
                            helper.write_attrib(&mut bytes, "LargeArc", &self.value.large_arc)?;
                            helper.write_attrib(
                                &mut bytes,
                                "RotationAnglet",
                                &self.value.rotation_anglet,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "EllipseSize",
                                &self.value.ellipse_size,
                            )?;
                            helper.write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtRegionAreaArcXElementTypeSerializerState::Done__ => return Ok(None),
                        CtRegionAreaArcXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRegionAreaArcXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRegionAreaArcXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod document {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    #[derive(Debug)]
    pub struct CtBookmarkXType {
        pub name: String,
        pub dest: super::definition::CtDestXType,
    }
    impl WithSerializer for CtBookmarkXType {
        type Serializer<'x> = quick_xml_serialize::CtBookmarkXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtBookmarkXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtBookmarkXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Bookmark"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtBookmarkXType {
        type Deserializer = quick_xml_deserialize::CtBookmarkXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtOutlineElemXType {
        pub title: String,
        pub count: Option<i32>,
        pub expanded: bool,
        pub actions: Option<super::page::CtGraphicUnitActionsXElementType>,
        pub outline_elem: Vec<CtOutlineElemXType>,
    }
    impl CtOutlineElemXType {
        #[must_use]
        pub fn default_expanded() -> bool {
            true
        }
    }
    impl WithSerializer for CtOutlineElemXType {
        type Serializer<'x> = quick_xml_serialize::CtOutlineElemXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtOutlineElemXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtOutlineElemXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_OutlineElem"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtOutlineElemXType {
        type Deserializer = quick_xml_deserialize::CtOutlineElemXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPermissionXType {
        pub edit: Option<bool>,
        pub annot: Option<bool>,
        pub export: Option<bool>,
        pub signature: Option<bool>,
        pub watermark: Option<bool>,
        pub print_screen: Option<bool>,
        pub print: Option<CtPermissionPrintXElementType>,
        pub valid_period: Option<CtPermissionValidPeriodXElementType>,
    }
    impl WithSerializer for CtPermissionXType {
        type Serializer<'x> = quick_xml_serialize::CtPermissionXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtPermissionXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtPermissionXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Permission"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtPermissionXType {
        type Deserializer = quick_xml_deserialize::CtPermissionXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtVPreferencesXType {
        pub content: Vec<CtVPreferencesXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtVPreferencesXTypeContent {
        PageMode(CtVPreferencesPageModeXElementType),
        PageLayout(CtVPreferencesPageLayoutXElementType),
        TabDisplay(CtVPreferencesTabDisplayXElementType),
        HideToolbar(bool),
        HideMenubar(bool),
        HideWindowUi(bool),
        ZoomMode(CtVPreferencesZoomModeXElementType),
        Zoom(f64),
    }
    impl WithSerializer for CtVPreferencesXType {
        type Serializer<'x> = quick_xml_serialize::CtVPreferencesXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtVPreferencesXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtVPreferencesXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_VPreferences"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtVPreferencesXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtVPreferencesXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtVPreferencesXTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtVPreferencesXTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for CtVPreferencesXType {
        type Deserializer = quick_xml_deserialize::CtVPreferencesXTypeDeserializer;
    }
    impl WithDeserializer for CtVPreferencesXTypeContent {
        type Deserializer = quick_xml_deserialize::CtVPreferencesXTypeContentDeserializer;
    }
    pub type Document = DocumentXElementType;
    #[derive(Debug)]
    pub struct DocumentXElementType {
        pub common_data: DocumentCommonDataXElementType,
        pub pages: DocumentPagesXElementType,
        pub outlines: Option<DocumentOutlinesXElementType>,
        pub permissions: Option<CtPermissionXType>,
        pub actions: Option<super::page::CtGraphicUnitActionsXElementType>,
        pub v_preferences: Option<CtVPreferencesXType>,
        pub bookmarks: Option<DocumentBookmarksXElementType>,
        pub annotations: Option<String>,
        pub custom_tags: Option<String>,
        pub attachments: Option<String>,
        pub extensions: Option<String>,
    }
    impl WithSerializer for DocumentXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::DocumentXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::DocumentXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Document"),
                is_root,
            })
        }
    }
    impl WithDeserializer for DocumentXElementType {
        type Deserializer = quick_xml_deserialize::DocumentXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPermissionPrintXElementType {
        pub printable: bool,
        pub copies: i32,
    }
    impl CtPermissionPrintXElementType {
        #[must_use]
        pub fn default_copies() -> i32 {
            -1i32
        }
    }
    impl WithSerializer for CtPermissionPrintXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPermissionPrintXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtPermissionPrintXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtPermissionPrintXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtPermissionPrint"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtPermissionPrintXElementType {
        type Deserializer = quick_xml_deserialize::CtPermissionPrintXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPermissionValidPeriodXElementType {
        pub start_date: Option<String>,
        pub end_date: Option<String>,
    }
    impl WithSerializer for CtPermissionValidPeriodXElementType {
        type Serializer<'x> =
            quick_xml_serialize::CtPermissionValidPeriodXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPermissionValidPeriodXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPermissionValidPeriodXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPermissionValidPeriod") , is_root , })
        }
    }
    impl WithDeserializer for CtPermissionValidPeriodXElementType {
        type Deserializer = quick_xml_deserialize::CtPermissionValidPeriodXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtVPreferencesPageModeXElementType {
        None,
        FullScreen,
        UseOutlines,
        UseThumbs,
        UseCustomTags,
        UseLayers,
        UseAttatchs,
        UseBookmarks,
    }
    impl SerializeBytes for CtVPreferencesPageModeXElementType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::None => Ok(Some(Cow::Borrowed("None"))),
                Self::FullScreen => Ok(Some(Cow::Borrowed("FullScreen"))),
                Self::UseOutlines => Ok(Some(Cow::Borrowed("UseOutlines"))),
                Self::UseThumbs => Ok(Some(Cow::Borrowed("UseThumbs"))),
                Self::UseCustomTags => Ok(Some(Cow::Borrowed("UseCustomTags"))),
                Self::UseLayers => Ok(Some(Cow::Borrowed("UseLayers"))),
                Self::UseAttatchs => Ok(Some(Cow::Borrowed("UseAttatchs"))),
                Self::UseBookmarks => Ok(Some(Cow::Borrowed("UseBookmarks"))),
            }
        }
    }
    impl DeserializeBytes for CtVPreferencesPageModeXElementType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"None" => Ok(Self::None),
                b"FullScreen" => Ok(Self::FullScreen),
                b"UseOutlines" => Ok(Self::UseOutlines),
                b"UseThumbs" => Ok(Self::UseThumbs),
                b"UseCustomTags" => Ok(Self::UseCustomTags),
                b"UseLayers" => Ok(Self::UseLayers),
                b"UseAttatchs" => Ok(Self::UseAttatchs),
                b"UseBookmarks" => Ok(Self::UseBookmarks),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtVPreferencesPageLayoutXElementType {
        OnePage,
        OneColumn,
        TwoPageL,
        TwoColumnL,
        TwoPageR,
        TwoColumnR,
    }
    impl SerializeBytes for CtVPreferencesPageLayoutXElementType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::OnePage => Ok(Some(Cow::Borrowed("OnePage"))),
                Self::OneColumn => Ok(Some(Cow::Borrowed("OneColumn"))),
                Self::TwoPageL => Ok(Some(Cow::Borrowed("TwoPageL"))),
                Self::TwoColumnL => Ok(Some(Cow::Borrowed("TwoColumnL"))),
                Self::TwoPageR => Ok(Some(Cow::Borrowed("TwoPageR"))),
                Self::TwoColumnR => Ok(Some(Cow::Borrowed("TwoColumnR"))),
            }
        }
    }
    impl DeserializeBytes for CtVPreferencesPageLayoutXElementType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"OnePage" => Ok(Self::OnePage),
                b"OneColumn" => Ok(Self::OneColumn),
                b"TwoPageL" => Ok(Self::TwoPageL),
                b"TwoColumnL" => Ok(Self::TwoColumnL),
                b"TwoPageR" => Ok(Self::TwoPageR),
                b"TwoColumnR" => Ok(Self::TwoColumnR),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtVPreferencesTabDisplayXElementType {
        DocTitle,
        FileName,
    }
    impl SerializeBytes for CtVPreferencesTabDisplayXElementType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::DocTitle => Ok(Some(Cow::Borrowed("DocTitle"))),
                Self::FileName => Ok(Some(Cow::Borrowed("FileName"))),
            }
        }
    }
    impl DeserializeBytes for CtVPreferencesTabDisplayXElementType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"DocTitle" => Ok(Self::DocTitle),
                b"FileName" => Ok(Self::FileName),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtVPreferencesZoomModeXElementType {
        Default,
        FitHeight,
        FitWidth,
        FitRect,
    }
    impl SerializeBytes for CtVPreferencesZoomModeXElementType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Default => Ok(Some(Cow::Borrowed("Default"))),
                Self::FitHeight => Ok(Some(Cow::Borrowed("FitHeight"))),
                Self::FitWidth => Ok(Some(Cow::Borrowed("FitWidth"))),
                Self::FitRect => Ok(Some(Cow::Borrowed("FitRect"))),
            }
        }
    }
    impl DeserializeBytes for CtVPreferencesZoomModeXElementType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Default" => Ok(Self::Default),
                b"FitHeight" => Ok(Self::FitHeight),
                b"FitWidth" => Ok(Self::FitWidth),
                b"FitRect" => Ok(Self::FitRect),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataXElementType {
        pub max_unit_id: u32,
        pub page_area: super::definition::CtPageAreaXType,
        pub public_res: Vec<String>,
        pub document_res: Vec<String>,
        pub template_page: Vec<DocumentCommonDataTemplatePageXElementType>,
        pub default_cs: Option<u32>,
    }
    impl WithSerializer for DocumentCommonDataXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentCommonDataXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::DocumentCommonDataXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::DocumentCommonDataXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("DocumentCommonData"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for DocumentCommonDataXElementType {
        type Deserializer = quick_xml_deserialize::DocumentCommonDataXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocumentPagesXElementType {
        pub page: Vec<DocumentPagesPageXElementType>,
    }
    impl WithSerializer for DocumentPagesXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentPagesXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::DocumentPagesXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::DocumentPagesXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("DocumentPages"),
                is_root,
            })
        }
    }
    impl WithDeserializer for DocumentPagesXElementType {
        type Deserializer = quick_xml_deserialize::DocumentPagesXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocumentOutlinesXElementType {
        pub outline_elem: Vec<CtOutlineElemXType>,
    }
    impl WithSerializer for DocumentOutlinesXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentOutlinesXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::DocumentOutlinesXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::DocumentOutlinesXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("DocumentOutlines"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for DocumentOutlinesXElementType {
        type Deserializer = quick_xml_deserialize::DocumentOutlinesXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocumentBookmarksXElementType {
        pub bookmark: Vec<CtBookmarkXType>,
    }
    impl WithSerializer for DocumentBookmarksXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentBookmarksXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::DocumentBookmarksXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::DocumentBookmarksXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("DocumentBookmarks"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for DocumentBookmarksXElementType {
        type Deserializer = quick_xml_deserialize::DocumentBookmarksXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocumentCommonDataTemplatePageXElementType {
        pub id: String,
        pub name: Option<String>,
        pub z_order: Option<DocumentCommonDataTemplatePageZOrderXType>,
        pub base_loc: String,
    }
    impl WithSerializer for DocumentCommonDataTemplatePageXElementType {
        type Serializer<'x> =
            quick_xml_serialize::DocumentCommonDataTemplatePageXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: DocumentCommonDataTemplatePageXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: DocumentCommonDataTemplatePageXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("DocumentCommonDataTemplatePage") , is_root , })
        }
    }
    impl WithDeserializer for DocumentCommonDataTemplatePageXElementType {
        type Deserializer =
            quick_xml_deserialize::DocumentCommonDataTemplatePageXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocumentPagesPageXElementType {
        pub id: u32,
        pub base_loc: String,
    }
    impl WithSerializer for DocumentPagesPageXElementType {
        type Serializer<'x> = quick_xml_serialize::DocumentPagesPageXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::DocumentPagesPageXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::DocumentPagesPageXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("DocumentPagesPage"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for DocumentPagesPageXElementType {
        type Deserializer = quick_xml_deserialize::DocumentPagesPageXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum DocumentCommonDataTemplatePageZOrderXType {
        Background,
        Foreground,
    }
    impl SerializeBytes for DocumentCommonDataTemplatePageZOrderXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Background => Ok(Some(Cow::Borrowed("Background"))),
                Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
            }
        }
    }
    impl DeserializeBytes for DocumentCommonDataTemplatePageZOrderXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Background" => Ok(Self::Background),
                b"Foreground" => Ok(Self::Foreground),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct CtBookmarkXTypeDeserializer {
            name: String,
            dest: Option<super::super::definition::CtDestXType>,
            state__: Box<CtBookmarkXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtBookmarkXTypeDeserializerState {
            Init__,
            Dest(Option<<super::super::definition::CtDestXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtBookmarkXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut name: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| ErrorKind::MissingAttribute("Name".into()))?,
                    dest: None,
                    state__: Box::new(CtBookmarkXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtBookmarkXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtBookmarkXTypeDeserializerState as S;
                match state {
                    S::Dest(Some(deserializer)) => self.store_dest(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_dest(
                &mut self,
                value: super::super::definition::CtDestXType,
            ) -> Result<(), Error> {
                if self.dest.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Dest")))?;
                }
                self.dest = Some(value);
                Ok(())
            }
            fn handle_dest<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::definition::CtDestXType>,
                fallback: &mut Option<CtBookmarkXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtBookmarkXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Dest(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_dest(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Dest(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtBookmarkXType> for CtBookmarkXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtBookmarkXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtBookmarkXType> {
                use CtBookmarkXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Dest(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_dest(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Dest(None);
                            event
                        }
                        (S::Dest(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Dest",
                                false,
                            )?;
                            match self.handle_dest(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtBookmarkXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtBookmarkXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtBookmarkXType {
                    name: self.name,
                    dest: helper.finish_element("Dest", self.dest)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtOutlineElemXTypeDeserializer {
            title: String,
            count: Option<i32>,
            expanded: bool,
            actions: Option<super::super::page::CtGraphicUnitActionsXElementType>,
            outline_elem: Vec<super::CtOutlineElemXType>,
            state__: Box<CtOutlineElemXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtOutlineElemXTypeDeserializerState {
            Init__ , Actions (Option << super :: super :: page :: CtGraphicUnitActionsXElementType as WithDeserializer > :: Deserializer >) , OutlineElem (Option << super :: CtOutlineElemXType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl CtOutlineElemXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut title: Option<String> = None;
                let mut count: Option<i32> = None;
                let mut expanded: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Title")
                    ) {
                        helper.read_attrib(&mut title, b"Title", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Count")
                    ) {
                        helper.read_attrib(&mut count, b"Count", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Expanded")
                    ) {
                        helper.read_attrib(&mut expanded, b"Expanded", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    title: title.ok_or_else(|| ErrorKind::MissingAttribute("Title".into()))?,
                    count: count,
                    expanded: expanded.unwrap_or_else(super::CtOutlineElemXType::default_expanded),
                    actions: None,
                    outline_elem: Vec::new(),
                    state__: Box::new(CtOutlineElemXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtOutlineElemXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtOutlineElemXTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::OutlineElem(Some(deserializer)) => {
                        self.store_outline_elem(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::super::page::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_outline_elem(
                &mut self,
                value: super::CtOutlineElemXType,
            ) -> Result<(), Error> {
                self.outline_elem.push(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtGraphicUnitActionsXElementType,
                >,
                fallback: &mut Option<CtOutlineElemXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtOutlineElemXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::OutlineElem(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_outline_elem<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtOutlineElemXType>,
                fallback: &mut Option<CtOutlineElemXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtOutlineElemXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::OutlineElem(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_outline_elem(data)?;
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::OutlineElem(Some(deserializer)));
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtOutlineElemXType> for CtOutlineElemXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtOutlineElemXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtOutlineElemXType> {
                use CtOutlineElemXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::OutlineElem(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_outline_elem(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::OutlineElem(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"OutlineElem",
                                true,
                            )?;
                            match self.handle_outline_elem(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtOutlineElemXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtOutlineElemXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtOutlineElemXType {
                    title: self.title,
                    count: self.count,
                    expanded: self.expanded,
                    actions: self.actions,
                    outline_elem: self.outline_elem,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionXTypeDeserializer {
            edit: Option<bool>,
            annot: Option<bool>,
            export: Option<bool>,
            signature: Option<bool>,
            watermark: Option<bool>,
            print_screen: Option<bool>,
            print: Option<super::CtPermissionPrintXElementType>,
            valid_period: Option<super::CtPermissionValidPeriodXElementType>,
            state__: Box<CtPermissionXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPermissionXTypeDeserializerState {
            Init__,
            Edit(Option<<bool as WithDeserializer>::Deserializer>),
            Annot(Option<<bool as WithDeserializer>::Deserializer>),
            Export(Option<<bool as WithDeserializer>::Deserializer>),
            Signature(Option<<bool as WithDeserializer>::Deserializer>),
            Watermark(Option<<bool as WithDeserializer>::Deserializer>),
            PrintScreen(Option<<bool as WithDeserializer>::Deserializer>),
            Print(Option<<super::CtPermissionPrintXElementType as WithDeserializer>::Deserializer>),
            ValidPeriod(
                Option<
                    <super::CtPermissionValidPeriodXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl CtPermissionXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    edit: None,
                    annot: None,
                    export: None,
                    signature: None,
                    watermark: None,
                    print_screen: None,
                    print: None,
                    valid_period: None,
                    state__: Box::new(CtPermissionXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPermissionXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPermissionXTypeDeserializerState as S;
                match state {
                    S::Edit(Some(deserializer)) => self.store_edit(deserializer.finish(helper)?)?,
                    S::Annot(Some(deserializer)) => {
                        self.store_annot(deserializer.finish(helper)?)?
                    }
                    S::Export(Some(deserializer)) => {
                        self.store_export(deserializer.finish(helper)?)?
                    }
                    S::Signature(Some(deserializer)) => {
                        self.store_signature(deserializer.finish(helper)?)?
                    }
                    S::Watermark(Some(deserializer)) => {
                        self.store_watermark(deserializer.finish(helper)?)?
                    }
                    S::PrintScreen(Some(deserializer)) => {
                        self.store_print_screen(deserializer.finish(helper)?)?
                    }
                    S::Print(Some(deserializer)) => {
                        self.store_print(deserializer.finish(helper)?)?
                    }
                    S::ValidPeriod(Some(deserializer)) => {
                        self.store_valid_period(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_edit(&mut self, value: bool) -> Result<(), Error> {
                if self.edit.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Edit")))?;
                }
                self.edit = Some(value);
                Ok(())
            }
            fn store_annot(&mut self, value: bool) -> Result<(), Error> {
                if self.annot.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Annot",
                    )))?;
                }
                self.annot = Some(value);
                Ok(())
            }
            fn store_export(&mut self, value: bool) -> Result<(), Error> {
                if self.export.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Export",
                    )))?;
                }
                self.export = Some(value);
                Ok(())
            }
            fn store_signature(&mut self, value: bool) -> Result<(), Error> {
                if self.signature.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Signature",
                    )))?;
                }
                self.signature = Some(value);
                Ok(())
            }
            fn store_watermark(&mut self, value: bool) -> Result<(), Error> {
                if self.watermark.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Watermark",
                    )))?;
                }
                self.watermark = Some(value);
                Ok(())
            }
            fn store_print_screen(&mut self, value: bool) -> Result<(), Error> {
                if self.print_screen.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PrintScreen",
                    )))?;
                }
                self.print_screen = Some(value);
                Ok(())
            }
            fn store_print(
                &mut self,
                value: super::CtPermissionPrintXElementType,
            ) -> Result<(), Error> {
                if self.print.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Print",
                    )))?;
                }
                self.print = Some(value);
                Ok(())
            }
            fn store_valid_period(
                &mut self,
                value: super::CtPermissionValidPeriodXElementType,
            ) -> Result<(), Error> {
                if self.valid_period.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ValidPeriod",
                    )))?;
                }
                self.valid_period = Some(value);
                Ok(())
            }
            fn handle_edit<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Edit(None));
                    *self.state__ = S::Annot(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_edit(data)?;
                        *self.state__ = S::Annot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Edit(Some(deserializer)));
                        *self.state__ = S::Annot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_annot<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Annot(None));
                    *self.state__ = S::Export(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_annot(data)?;
                        *self.state__ = S::Export(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Annot(Some(deserializer)));
                        *self.state__ = S::Export(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_export<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Export(None));
                    *self.state__ = S::Signature(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_export(data)?;
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Export(Some(deserializer)));
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_signature<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Signature(None));
                    *self.state__ = S::Watermark(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_signature(data)?;
                        *self.state__ = S::Watermark(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Signature(Some(deserializer)));
                        *self.state__ = S::Watermark(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_watermark<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Watermark(None));
                    *self.state__ = S::PrintScreen(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_watermark(data)?;
                        *self.state__ = S::PrintScreen(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Watermark(Some(deserializer)));
                        *self.state__ = S::PrintScreen(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_print_screen<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, bool>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::PrintScreen(None));
                    *self.state__ = S::Print(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_print_screen(data)?;
                        *self.state__ = S::Print(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::PrintScreen(Some(deserializer)));
                        *self.state__ = S::Print(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_print<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPermissionPrintXElementType>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Print(None));
                    *self.state__ = S::ValidPeriod(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_print(data)?;
                        *self.state__ = S::ValidPeriod(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Print(Some(deserializer)));
                        *self.state__ = S::ValidPeriod(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_valid_period<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPermissionValidPeriodXElementType>,
                fallback: &mut Option<CtPermissionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPermissionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::ValidPeriod(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_valid_period(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::ValidPeriod(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPermissionXType> for CtPermissionXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionXType> {
                use CtPermissionXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Edit(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_edit(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Annot(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Export(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_export(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signature(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_signature(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Watermark(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_watermark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PrintScreen(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_print_screen(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Print(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_print(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ValidPeriod(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_valid_period(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Edit(None);
                            event
                        }
                        (S::Edit(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Edit",
                                false,
                            )?;
                            match self.handle_edit(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Annot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Annot",
                                false,
                            )?;
                            match self.handle_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Export(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Export",
                                false,
                            )?;
                            match self.handle_export(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Signature",
                                false,
                            )?;
                            match self.handle_signature(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Watermark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Watermark",
                                false,
                            )?;
                            match self.handle_watermark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PrintScreen(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PrintScreen",
                                false,
                            )?;
                            match self.handle_print_screen(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Print(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Print",
                                false,
                            )?;
                            match self.handle_print(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ValidPeriod(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ValidPeriod",
                                false,
                            )?;
                            match self.handle_valid_period(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPermissionXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPermissionXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPermissionXType {
                    edit: self.edit,
                    annot: self.annot,
                    export: self.export,
                    signature: self.signature,
                    watermark: self.watermark,
                    print_screen: self.print_screen,
                    print: self.print,
                    valid_period: self.valid_period,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtVPreferencesXTypeDeserializer {
            content: Vec<super::CtVPreferencesXTypeContent>,
            state__: Box<CtVPreferencesXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtVPreferencesXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtVPreferencesXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtVPreferencesXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    content: Vec::new(),
                    state__: Box::new(CtVPreferencesXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtVPreferencesXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtVPreferencesXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtVPreferencesXTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtVPreferencesXTypeContent>,
                fallback: &mut Option<CtVPreferencesXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        if self.content.len() < 6usize {
                            *fallback = Some(S::Content__(deserializer));
                            *self.state__ = S::Next__;
                            Ok(ElementHandlerOutput::from_event(event, allow_any))
                        } else {
                            *self.state__ = S::Content__(deserializer);
                            Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                        }
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtVPreferencesXType> for CtVPreferencesXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVPreferencesXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVPreferencesXType> {
                use CtVPreferencesXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::CtVPreferencesXTypeContent as WithDeserializer>::init(
                                    helper, event,
                                )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtVPreferencesXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtVPreferencesXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtVPreferencesXType {
                    content: helper.finish_vec(0usize, Some(7usize), self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtVPreferencesXTypeContentDeserializer {
            state__: Box<CtVPreferencesXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtVPreferencesXTypeContentDeserializerState {
            Init__,
            PageMode(
                Option<super::CtVPreferencesPageModeXElementType>,
                Option<
                    <super::CtVPreferencesPageModeXElementType as WithDeserializer>::Deserializer,
                >,
                Option<
                    <super::CtVPreferencesPageModeXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            PageLayout(
                Option<super::CtVPreferencesPageLayoutXElementType>,
                Option<
                    <super::CtVPreferencesPageLayoutXElementType as WithDeserializer>::Deserializer,
                >,
                Option<
                    <super::CtVPreferencesPageLayoutXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            TabDisplay(
                Option<super::CtVPreferencesTabDisplayXElementType>,
                Option<
                    <super::CtVPreferencesTabDisplayXElementType as WithDeserializer>::Deserializer,
                >,
                Option<
                    <super::CtVPreferencesTabDisplayXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            HideToolbar(
                Option<bool>,
                Option<<bool as WithDeserializer>::Deserializer>,
                Option<<bool as WithDeserializer>::Deserializer>,
            ),
            HideMenubar(
                Option<bool>,
                Option<<bool as WithDeserializer>::Deserializer>,
                Option<<bool as WithDeserializer>::Deserializer>,
            ),
            HideWindowUi(
                Option<bool>,
                Option<<bool as WithDeserializer>::Deserializer>,
                Option<<bool as WithDeserializer>::Deserializer>,
            ),
            ZoomMode(
                Option<super::CtVPreferencesZoomModeXElementType>,
                Option<
                    <super::CtVPreferencesZoomModeXElementType as WithDeserializer>::Deserializer,
                >,
                Option<
                    <super::CtVPreferencesZoomModeXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Zoom(
                Option<f64>,
                Option<<f64 as WithDeserializer>::Deserializer>,
                Option<<f64 as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtVPreferencesXTypeContent),
            Unknown__,
        }
        impl CtVPreferencesXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageMode")
                    ) {
                        let output =
                            <super::CtVPreferencesPageModeXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_mode(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageLayout")
                    ) {
                        let output = < super :: CtVPreferencesPageLayoutXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_page_layout(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TabDisplay")
                    ) {
                        let output = < super :: CtVPreferencesTabDisplayXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_tab_display(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"HideToolbar")
                    ) {
                        let output = <bool as WithDeserializer>::init(helper, event)?;
                        return self.handle_hide_toolbar(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"HideMenubar")
                    ) {
                        let output = <bool as WithDeserializer>::init(helper, event)?;
                        return self.handle_hide_menubar(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"HideWindowUI")
                    ) {
                        let output = <bool as WithDeserializer>::init(helper, event)?;
                        return self.handle_hide_window_ui(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ZoomMode")
                    ) {
                        let output =
                            <super::CtVPreferencesZoomModeXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_zoom_mode(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Zoom")
                    ) {
                        let output = <f64 as WithDeserializer>::init(helper, event)?;
                        return self.handle_zoom(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtVPreferencesXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtVPreferencesXTypeContentDeserializerState,
            ) -> Result<super::CtVPreferencesXTypeContent, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::PageMode(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_mode(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::PageMode(
                            helper.finish_element("PageMode", values)?,
                        ))
                    }
                    S::PageLayout(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_layout(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::PageLayout(
                            helper.finish_element("PageLayout", values)?,
                        ))
                    }
                    S::TabDisplay(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_tab_display(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::TabDisplay(
                            helper.finish_element("TabDisplay", values)?,
                        ))
                    }
                    S::HideToolbar(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_hide_toolbar(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::HideToolbar(
                            helper.finish_element("HideToolbar", values)?,
                        ))
                    }
                    S::HideMenubar(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_hide_menubar(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::HideMenubar(
                            helper.finish_element("HideMenubar", values)?,
                        ))
                    }
                    S::HideWindowUi(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_hide_window_ui(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::HideWindowUi(
                            helper.finish_element("HideWindowUI", values)?,
                        ))
                    }
                    S::ZoomMode(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_zoom_mode(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::ZoomMode(
                            helper.finish_element("ZoomMode", values)?,
                        ))
                    }
                    S::Zoom(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_zoom(&mut values, value)?;
                        }
                        Ok(super::CtVPreferencesXTypeContent::Zoom(
                            helper.finish_element("Zoom", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_page_mode(
                values: &mut Option<super::CtVPreferencesPageModeXElementType>,
                value: super::CtVPreferencesPageModeXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageMode",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_layout(
                values: &mut Option<super::CtVPreferencesPageLayoutXElementType>,
                value: super::CtVPreferencesPageLayoutXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageLayout",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_tab_display(
                values: &mut Option<super::CtVPreferencesTabDisplayXElementType>,
                value: super::CtVPreferencesTabDisplayXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TabDisplay",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_hide_toolbar(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"HideToolbar",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_hide_menubar(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"HideMenubar",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_hide_window_ui(values: &mut Option<bool>, value: bool) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"HideWindowUI",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_zoom_mode(
                values: &mut Option<super::CtVPreferencesZoomModeXElementType>,
                value: super::CtVPreferencesZoomModeXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ZoomMode",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_zoom(values: &mut Option<f64>, value: f64) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Zoom")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_page_mode<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtVPreferencesPageModeXElementType>,
                fallback: Option<
                    <super::CtVPreferencesPageModeXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtVPreferencesPageModeXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_mode(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_mode(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageMode(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageMode(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_layout<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtVPreferencesPageLayoutXElementType>,
                fallback: Option<
                    <super::CtVPreferencesPageLayoutXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtVPreferencesPageLayoutXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_layout(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_layout(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageLayout(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageLayout(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_tab_display<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtVPreferencesTabDisplayXElementType>,
                fallback: Option<
                    <super::CtVPreferencesTabDisplayXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtVPreferencesTabDisplayXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_tab_display(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_tab_display(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TabDisplay(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TabDisplay(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_hide_toolbar<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<bool>,
                fallback: Option<<bool as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, bool>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_hide_toolbar(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_hide_toolbar(&mut values, data)?;
                        let data = Self::finish_state(helper, S::HideToolbar(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::HideToolbar(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_hide_menubar<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<bool>,
                fallback: Option<<bool as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, bool>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_hide_menubar(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_hide_menubar(&mut values, data)?;
                        let data = Self::finish_state(helper, S::HideMenubar(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::HideMenubar(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_hide_window_ui<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<bool>,
                fallback: Option<<bool as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, bool>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_hide_window_ui(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_hide_window_ui(&mut values, data)?;
                        let data = Self::finish_state(helper, S::HideWindowUi(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::HideWindowUi(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_zoom_mode<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtVPreferencesZoomModeXElementType>,
                fallback: Option<
                    <super::CtVPreferencesZoomModeXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtVPreferencesZoomModeXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_zoom_mode(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_zoom_mode(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ZoomMode(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ZoomMode(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_zoom<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<f64>,
                fallback: Option<<f64 as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, f64>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_zoom(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_zoom(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Zoom(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Zoom(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtVPreferencesXTypeContent>
            for CtVPreferencesXTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVPreferencesXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtVPreferencesXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtVPreferencesXTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVPreferencesXTypeContent> {
                use CtVPreferencesXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::PageMode(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_mode(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageLayout(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_layout(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TabDisplay(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_tab_display(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::HideToolbar(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_hide_toolbar(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::HideMenubar(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_hide_menubar(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::HideWindowUi(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_hide_window_ui(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ZoomMode(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_zoom_mode(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Zoom(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_zoom(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::PageMode(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageMode",
                                false,
                            )?;
                            match self.handle_page_mode(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageLayout(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageLayout",
                                false,
                            )?;
                            match self.handle_page_layout(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::TabDisplay(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TabDisplay",
                                false,
                            )?;
                            match self.handle_tab_display(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::HideToolbar(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"HideToolbar",
                                false,
                            )?;
                            match self.handle_hide_toolbar(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::HideMenubar(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"HideMenubar",
                                false,
                            )?;
                            match self.handle_hide_menubar(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::HideWindowUi(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"HideWindowUI",
                                false,
                            )?;
                            match self.handle_hide_window_ui(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ZoomMode(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ZoomMode",
                                false,
                            )?;
                            match self.handle_zoom_mode(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Zoom(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Zoom",
                                false,
                            )?;
                            match self.handle_zoom(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtVPreferencesXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct DocumentXElementTypeDeserializer {
            common_data: Option<super::DocumentCommonDataXElementType>,
            pages: Option<super::DocumentPagesXElementType>,
            outlines: Option<super::DocumentOutlinesXElementType>,
            permissions: Option<super::CtPermissionXType>,
            actions: Option<super::super::page::CtGraphicUnitActionsXElementType>,
            v_preferences: Option<super::CtVPreferencesXType>,
            bookmarks: Option<super::DocumentBookmarksXElementType>,
            annotations: Option<String>,
            custom_tags: Option<String>,
            attachments: Option<String>,
            extensions: Option<String>,
            state__: Box<DocumentXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentXElementTypeDeserializerState {
            Init__ , CommonData (Option << super :: DocumentCommonDataXElementType as WithDeserializer > :: Deserializer >) , Pages (Option << super :: DocumentPagesXElementType as WithDeserializer > :: Deserializer >) , Outlines (Option << super :: DocumentOutlinesXElementType as WithDeserializer > :: Deserializer >) , Permissions (Option << super :: CtPermissionXType as WithDeserializer > :: Deserializer >) , Actions (Option << super :: super :: page :: CtGraphicUnitActionsXElementType as WithDeserializer > :: Deserializer >) , VPreferences (Option << super :: CtVPreferencesXType as WithDeserializer > :: Deserializer >) , Bookmarks (Option << super :: DocumentBookmarksXElementType as WithDeserializer > :: Deserializer >) , Annotations (Option << String as WithDeserializer > :: Deserializer >) , CustomTags (Option << String as WithDeserializer > :: Deserializer >) , Attachments (Option << String as WithDeserializer > :: Deserializer >) , Extensions (Option << String as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl DocumentXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    common_data: None,
                    pages: None,
                    outlines: None,
                    permissions: None,
                    actions: None,
                    v_preferences: None,
                    bookmarks: None,
                    annotations: None,
                    custom_tags: None,
                    attachments: None,
                    extensions: None,
                    state__: Box::new(DocumentXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocumentXElementTypeDeserializerState as S;
                match state {
                    S::CommonData(Some(deserializer)) => {
                        self.store_common_data(deserializer.finish(helper)?)?
                    }
                    S::Pages(Some(deserializer)) => {
                        self.store_pages(deserializer.finish(helper)?)?
                    }
                    S::Outlines(Some(deserializer)) => {
                        self.store_outlines(deserializer.finish(helper)?)?
                    }
                    S::Permissions(Some(deserializer)) => {
                        self.store_permissions(deserializer.finish(helper)?)?
                    }
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::VPreferences(Some(deserializer)) => {
                        self.store_v_preferences(deserializer.finish(helper)?)?
                    }
                    S::Bookmarks(Some(deserializer)) => {
                        self.store_bookmarks(deserializer.finish(helper)?)?
                    }
                    S::Annotations(Some(deserializer)) => {
                        self.store_annotations(deserializer.finish(helper)?)?
                    }
                    S::CustomTags(Some(deserializer)) => {
                        self.store_custom_tags(deserializer.finish(helper)?)?
                    }
                    S::Attachments(Some(deserializer)) => {
                        self.store_attachments(deserializer.finish(helper)?)?
                    }
                    S::Extensions(Some(deserializer)) => {
                        self.store_extensions(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_common_data(
                &mut self,
                value: super::DocumentCommonDataXElementType,
            ) -> Result<(), Error> {
                if self.common_data.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CommonData",
                    )))?;
                }
                self.common_data = Some(value);
                Ok(())
            }
            fn store_pages(
                &mut self,
                value: super::DocumentPagesXElementType,
            ) -> Result<(), Error> {
                if self.pages.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Pages",
                    )))?;
                }
                self.pages = Some(value);
                Ok(())
            }
            fn store_outlines(
                &mut self,
                value: super::DocumentOutlinesXElementType,
            ) -> Result<(), Error> {
                if self.outlines.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Outlines",
                    )))?;
                }
                self.outlines = Some(value);
                Ok(())
            }
            fn store_permissions(&mut self, value: super::CtPermissionXType) -> Result<(), Error> {
                if self.permissions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Permissions",
                    )))?;
                }
                self.permissions = Some(value);
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::super::page::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_v_preferences(
                &mut self,
                value: super::CtVPreferencesXType,
            ) -> Result<(), Error> {
                if self.v_preferences.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"VPreferences",
                    )))?;
                }
                self.v_preferences = Some(value);
                Ok(())
            }
            fn store_bookmarks(
                &mut self,
                value: super::DocumentBookmarksXElementType,
            ) -> Result<(), Error> {
                if self.bookmarks.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Bookmarks",
                    )))?;
                }
                self.bookmarks = Some(value);
                Ok(())
            }
            fn store_annotations(&mut self, value: String) -> Result<(), Error> {
                if self.annotations.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Annotations",
                    )))?;
                }
                self.annotations = Some(value);
                Ok(())
            }
            fn store_custom_tags(&mut self, value: String) -> Result<(), Error> {
                if self.custom_tags.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CustomTags",
                    )))?;
                }
                self.custom_tags = Some(value);
                Ok(())
            }
            fn store_attachments(&mut self, value: String) -> Result<(), Error> {
                if self.attachments.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Attachments",
                    )))?;
                }
                self.attachments = Some(value);
                Ok(())
            }
            fn store_extensions(&mut self, value: String) -> Result<(), Error> {
                if self.extensions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Extensions",
                    )))?;
                }
                self.extensions = Some(value);
                Ok(())
            }
            fn handle_common_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentCommonDataXElementType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CommonData(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_common_data(data)?;
                        *self.state__ = S::Pages(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CommonData(Some(deserializer)));
                        *self.state__ = S::Pages(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_pages<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentPagesXElementType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Pages(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_pages(data)?;
                        *self.state__ = S::Outlines(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Pages(Some(deserializer)));
                        *self.state__ = S::Outlines(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_outlines<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentOutlinesXElementType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Outlines(None));
                    *self.state__ = S::Permissions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_outlines(data)?;
                        *self.state__ = S::Permissions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Outlines(Some(deserializer)));
                        *self.state__ = S::Permissions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_permissions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPermissionXType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Permissions(None));
                    *self.state__ = S::Actions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_permissions(data)?;
                        *self.state__ = S::Actions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Permissions(Some(deserializer)));
                        *self.state__ = S::Actions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<
                    'de,
                    super::super::page::CtGraphicUnitActionsXElementType,
                >,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::VPreferences(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::VPreferences(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::VPreferences(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_v_preferences<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtVPreferencesXType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::VPreferences(None));
                    *self.state__ = S::Bookmarks(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_v_preferences(data)?;
                        *self.state__ = S::Bookmarks(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::VPreferences(Some(deserializer)));
                        *self.state__ = S::Bookmarks(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_bookmarks<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentBookmarksXElementType>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Bookmarks(None));
                    *self.state__ = S::Annotations(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_bookmarks(data)?;
                        *self.state__ = S::Annotations(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Bookmarks(Some(deserializer)));
                        *self.state__ = S::Annotations(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_annotations<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Annotations(None));
                    *self.state__ = S::CustomTags(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_annotations(data)?;
                        *self.state__ = S::CustomTags(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Annotations(Some(deserializer)));
                        *self.state__ = S::CustomTags(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_custom_tags<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CustomTags(None));
                    *self.state__ = S::Attachments(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_custom_tags(data)?;
                        *self.state__ = S::Attachments(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CustomTags(Some(deserializer)));
                        *self.state__ = S::Attachments(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_attachments<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Attachments(None));
                    *self.state__ = S::Extensions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_attachments(data)?;
                        *self.state__ = S::Extensions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Attachments(Some(deserializer)));
                        *self.state__ = S::Extensions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_extensions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Extensions(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_extensions(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Extensions(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocumentXElementType> for DocumentXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentXElementType> {
                use DocumentXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CommonData(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_common_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Pages(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_pages(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Outlines(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_outlines(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Permissions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_permissions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::VPreferences(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_v_preferences(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Bookmarks(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_bookmarks(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Annotations(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_annotations(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CustomTags(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_custom_tags(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Attachments(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_attachments(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Extensions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_extensions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CommonData(None);
                            event
                        }
                        (S::CommonData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CommonData",
                                false,
                            )?;
                            match self.handle_common_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Pages(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Pages",
                                false,
                            )?;
                            match self.handle_pages(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Outlines(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Outlines",
                                true,
                            )?;
                            match self.handle_outlines(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Permissions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Permissions",
                                false,
                            )?;
                            match self.handle_permissions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::VPreferences(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"VPreferences",
                                false,
                            )?;
                            match self.handle_v_preferences(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Bookmarks(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Bookmarks",
                                false,
                            )?;
                            match self.handle_bookmarks(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Annotations(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Annotations",
                                false,
                            )?;
                            match self.handle_annotations(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CustomTags(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CustomTags",
                                false,
                            )?;
                            match self.handle_custom_tags(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Attachments(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Attachments",
                                false,
                            )?;
                            match self.handle_attachments(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Extensions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Extensions",
                                false,
                            )?;
                            match self.handle_extensions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentXElementType {
                    common_data: helper.finish_element("CommonData", self.common_data)?,
                    pages: helper.finish_element("Pages", self.pages)?,
                    outlines: self.outlines,
                    permissions: self.permissions,
                    actions: self.actions,
                    v_preferences: self.v_preferences,
                    bookmarks: self.bookmarks,
                    annotations: self.annotations,
                    custom_tags: self.custom_tags,
                    attachments: self.attachments,
                    extensions: self.extensions,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionPrintXElementTypeDeserializer {
            printable: bool,
            copies: i32,
            state__: Box<CtPermissionPrintXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPermissionPrintXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtPermissionPrintXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut printable: Option<bool> = None;
                let mut copies: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Printable")
                    ) {
                        helper.read_attrib(&mut printable, b"Printable", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Copies")
                    ) {
                        helper.read_attrib(&mut copies, b"Copies", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    printable: printable
                        .ok_or_else(|| ErrorKind::MissingAttribute("Printable".into()))?,
                    copies: copies
                        .unwrap_or_else(super::CtPermissionPrintXElementType::default_copies),
                    state__: Box::new(CtPermissionPrintXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPermissionPrintXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtPermissionPrintXElementType>
            for CtPermissionPrintXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionPrintXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionPrintXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPermissionPrintXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPermissionPrintXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPermissionPrintXElementType {
                    printable: self.printable,
                    copies: self.copies,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionValidPeriodXElementTypeDeserializer {
            start_date: Option<String>,
            end_date: Option<String>,
            state__: Box<CtPermissionValidPeriodXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPermissionValidPeriodXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl CtPermissionValidPeriodXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut start_date: Option<String> = None;
                let mut end_date: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"StartDate")
                    ) {
                        helper.read_attrib(&mut start_date, b"StartDate", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EndDate")
                    ) {
                        helper.read_attrib(&mut end_date, b"EndDate", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    start_date: start_date,
                    end_date: end_date,
                    state__: Box::new(CtPermissionValidPeriodXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPermissionValidPeriodXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::CtPermissionValidPeriodXElementType>
            for CtPermissionValidPeriodXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionValidPeriodXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPermissionValidPeriodXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPermissionValidPeriodXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPermissionValidPeriodXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPermissionValidPeriodXElementType {
                    start_date: self.start_date,
                    end_date: self.end_date,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentCommonDataXElementTypeDeserializer {
            max_unit_id: Option<u32>,
            page_area: Option<super::super::definition::CtPageAreaXType>,
            public_res: Vec<String>,
            document_res: Vec<String>,
            template_page: Vec<super::DocumentCommonDataTemplatePageXElementType>,
            default_cs: Option<u32>,
            state__: Box<DocumentCommonDataXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentCommonDataXElementTypeDeserializerState {
            Init__ , MaxUnitId (Option << u32 as WithDeserializer > :: Deserializer >) , PageArea (Option << super :: super :: definition :: CtPageAreaXType as WithDeserializer > :: Deserializer >) , PublicRes (Option << String as WithDeserializer > :: Deserializer >) , DocumentRes (Option << String as WithDeserializer > :: Deserializer >) , TemplatePage (Option << super :: DocumentCommonDataTemplatePageXElementType as WithDeserializer > :: Deserializer >) , DefaultCs (Option << u32 as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl DocumentCommonDataXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    max_unit_id: None,
                    page_area: None,
                    public_res: Vec::new(),
                    document_res: Vec::new(),
                    template_page: Vec::new(),
                    default_cs: None,
                    state__: Box::new(DocumentCommonDataXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentCommonDataXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                match state {
                    S::MaxUnitId(Some(deserializer)) => {
                        self.store_max_unit_id(deserializer.finish(helper)?)?
                    }
                    S::PageArea(Some(deserializer)) => {
                        self.store_page_area(deserializer.finish(helper)?)?
                    }
                    S::PublicRes(Some(deserializer)) => {
                        self.store_public_res(deserializer.finish(helper)?)?
                    }
                    S::DocumentRes(Some(deserializer)) => {
                        self.store_document_res(deserializer.finish(helper)?)?
                    }
                    S::TemplatePage(Some(deserializer)) => {
                        self.store_template_page(deserializer.finish(helper)?)?
                    }
                    S::DefaultCs(Some(deserializer)) => {
                        self.store_default_cs(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_max_unit_id(&mut self, value: u32) -> Result<(), Error> {
                if self.max_unit_id.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"MaxUnitID",
                    )))?;
                }
                self.max_unit_id = Some(value);
                Ok(())
            }
            fn store_page_area(
                &mut self,
                value: super::super::definition::CtPageAreaXType,
            ) -> Result<(), Error> {
                if self.page_area.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageArea",
                    )))?;
                }
                self.page_area = Some(value);
                Ok(())
            }
            fn store_public_res(&mut self, value: String) -> Result<(), Error> {
                self.public_res.push(value);
                Ok(())
            }
            fn store_document_res(&mut self, value: String) -> Result<(), Error> {
                self.document_res.push(value);
                Ok(())
            }
            fn store_template_page(
                &mut self,
                value: super::DocumentCommonDataTemplatePageXElementType,
            ) -> Result<(), Error> {
                self.template_page.push(value);
                Ok(())
            }
            fn store_default_cs(&mut self, value: u32) -> Result<(), Error> {
                if self.default_cs.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DefaultCs",
                    )))?;
                }
                self.default_cs = Some(value);
                Ok(())
            }
            fn handle_max_unit_id<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::MaxUnitId(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_max_unit_id(data)?;
                        *self.state__ = S::PageArea(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::MaxUnitId(Some(deserializer)));
                        *self.state__ = S::PageArea(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_page_area<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::definition::CtPageAreaXType>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::PageArea(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_page_area(data)?;
                        *self.state__ = S::PublicRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::PageArea(Some(deserializer)));
                        *self.state__ = S::PublicRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_public_res<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::PublicRes(None));
                    *self.state__ = S::DocumentRes(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_public_res(data)?;
                        *self.state__ = S::PublicRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::PublicRes(Some(deserializer)));
                        *self.state__ = S::PublicRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_document_res<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocumentRes(None));
                    *self.state__ = S::TemplatePage(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_document_res(data)?;
                        *self.state__ = S::DocumentRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocumentRes(Some(deserializer)));
                        *self.state__ = S::DocumentRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_template_page<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentCommonDataTemplatePageXElementType>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::TemplatePage(None));
                    *self.state__ = S::DefaultCs(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_template_page(data)?;
                        *self.state__ = S::TemplatePage(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::TemplatePage(Some(deserializer)));
                        *self.state__ = S::TemplatePage(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_default_cs<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<DocumentCommonDataXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DefaultCs(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_default_cs(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DefaultCs(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocumentCommonDataXElementType>
            for DocumentCommonDataXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentCommonDataXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentCommonDataXElementType> {
                use DocumentCommonDataXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::MaxUnitId(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_max_unit_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PageArea(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PublicRes(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_public_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocumentRes(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_document_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::TemplatePage(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_template_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DefaultCs(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_default_cs(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::MaxUnitId(None);
                            event
                        }
                        (S::MaxUnitId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MaxUnitID",
                                false,
                            )?;
                            match self.handle_max_unit_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PageArea(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageArea",
                                false,
                            )?;
                            match self.handle_page_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PublicRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PublicRes",
                                false,
                            )?;
                            match self.handle_public_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocumentRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocumentRes",
                                false,
                            )?;
                            match self.handle_document_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::TemplatePage(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TemplatePage",
                                false,
                            )?;
                            match self.handle_template_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DefaultCs(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DefaultCs",
                                false,
                            )?;
                            match self.handle_default_cs(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentCommonDataXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentCommonDataXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentCommonDataXElementType {
                    max_unit_id: helper.finish_element("MaxUnitID", self.max_unit_id)?,
                    page_area: helper.finish_element("PageArea", self.page_area)?,
                    public_res: self.public_res,
                    document_res: self.document_res,
                    template_page: self.template_page,
                    default_cs: self.default_cs,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentPagesXElementTypeDeserializer {
            page: Vec<super::DocumentPagesPageXElementType>,
            state__: Box<DocumentPagesXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentPagesXElementTypeDeserializerState {
            Init__,
            Page(Option<<super::DocumentPagesPageXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl DocumentPagesXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    page: Vec::new(),
                    state__: Box::new(DocumentPagesXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentPagesXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocumentPagesXElementTypeDeserializerState as S;
                match state {
                    S::Page(Some(deserializer)) => self.store_page(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_page(
                &mut self,
                value: super::DocumentPagesPageXElementType,
            ) -> Result<(), Error> {
                self.page.push(value);
                Ok(())
            }
            fn handle_page<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocumentPagesPageXElementType>,
                fallback: &mut Option<DocumentPagesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentPagesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.page.len() < 1usize {
                        fallback.get_or_insert(S::Page(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Page(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_page(data)?;
                        *self.state__ = S::Page(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Page(Some(deserializer)));
                        *self.state__ = S::Page(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocumentPagesXElementType>
            for DocumentPagesXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentPagesXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentPagesXElementType> {
                use DocumentPagesXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Page(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Page(None);
                            event
                        }
                        (S::Page(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Page",
                                false,
                            )?;
                            match self.handle_page(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentPagesXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentPagesXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentPagesXElementType {
                    page: helper.finish_vec(1usize, None, self.page)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentOutlinesXElementTypeDeserializer {
            outline_elem: Vec<super::CtOutlineElemXType>,
            state__: Box<DocumentOutlinesXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentOutlinesXElementTypeDeserializerState {
            Init__,
            OutlineElem(Option<<super::CtOutlineElemXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl DocumentOutlinesXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    outline_elem: Vec::new(),
                    state__: Box::new(DocumentOutlinesXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentOutlinesXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocumentOutlinesXElementTypeDeserializerState as S;
                match state {
                    S::OutlineElem(Some(deserializer)) => {
                        self.store_outline_elem(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_outline_elem(
                &mut self,
                value: super::CtOutlineElemXType,
            ) -> Result<(), Error> {
                self.outline_elem.push(value);
                Ok(())
            }
            fn handle_outline_elem<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtOutlineElemXType>,
                fallback: &mut Option<DocumentOutlinesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentOutlinesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.outline_elem.len() < 1usize {
                        fallback.get_or_insert(S::OutlineElem(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::OutlineElem(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_outline_elem(data)?;
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::OutlineElem(Some(deserializer)));
                        *self.state__ = S::OutlineElem(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocumentOutlinesXElementType>
            for DocumentOutlinesXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentOutlinesXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentOutlinesXElementType> {
                use DocumentOutlinesXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::OutlineElem(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_outline_elem(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::OutlineElem(None);
                            event
                        }
                        (S::OutlineElem(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"OutlineElem",
                                true,
                            )?;
                            match self.handle_outline_elem(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentOutlinesXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentOutlinesXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentOutlinesXElementType {
                    outline_elem: helper.finish_vec(1usize, None, self.outline_elem)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentBookmarksXElementTypeDeserializer {
            bookmark: Vec<super::CtBookmarkXType>,
            state__: Box<DocumentBookmarksXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentBookmarksXElementTypeDeserializerState {
            Init__,
            Bookmark(Option<<super::CtBookmarkXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl DocumentBookmarksXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    bookmark: Vec::new(),
                    state__: Box::new(DocumentBookmarksXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentBookmarksXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocumentBookmarksXElementTypeDeserializerState as S;
                match state {
                    S::Bookmark(Some(deserializer)) => {
                        self.store_bookmark(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_bookmark(&mut self, value: super::CtBookmarkXType) -> Result<(), Error> {
                self.bookmark.push(value);
                Ok(())
            }
            fn handle_bookmark<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtBookmarkXType>,
                fallback: &mut Option<DocumentBookmarksXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocumentBookmarksXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.bookmark.len() < 1usize {
                        fallback.get_or_insert(S::Bookmark(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Bookmark(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_bookmark(data)?;
                        *self.state__ = S::Bookmark(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Bookmark(Some(deserializer)));
                        *self.state__ = S::Bookmark(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocumentBookmarksXElementType>
            for DocumentBookmarksXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentBookmarksXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentBookmarksXElementType> {
                use DocumentBookmarksXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Bookmark(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_bookmark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Bookmark(None);
                            event
                        }
                        (S::Bookmark(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Bookmark",
                                false,
                            )?;
                            match self.handle_bookmark(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentBookmarksXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentBookmarksXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentBookmarksXElementType {
                    bookmark: helper.finish_vec(1usize, None, self.bookmark)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentCommonDataTemplatePageXElementTypeDeserializer {
            id: String,
            name: Option<String>,
            z_order: Option<super::DocumentCommonDataTemplatePageZOrderXType>,
            base_loc: String,
            state__: Box<DocumentCommonDataTemplatePageXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentCommonDataTemplatePageXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl DocumentCommonDataTemplatePageXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut name: Option<String> = None;
                let mut z_order: Option<super::DocumentCommonDataTemplatePageZOrderXType> = None;
                let mut base_loc: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ZOrder")
                    ) {
                        helper.read_attrib(&mut z_order, b"ZOrder", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BaseLoc")
                    ) {
                        helper.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    name: name,
                    z_order: z_order,
                    base_loc: base_loc
                        .ok_or_else(|| ErrorKind::MissingAttribute("BaseLoc".into()))?,
                    state__: Box::new(
                        DocumentCommonDataTemplatePageXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentCommonDataTemplatePageXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::DocumentCommonDataTemplatePageXElementType>
            for DocumentCommonDataTemplatePageXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentCommonDataTemplatePageXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentCommonDataTemplatePageXElementType>
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentCommonDataTemplatePageXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentCommonDataTemplatePageXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentCommonDataTemplatePageXElementType {
                    id: self.id,
                    name: self.name,
                    z_order: self.z_order,
                    base_loc: self.base_loc,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocumentPagesPageXElementTypeDeserializer {
            id: u32,
            base_loc: String,
            state__: Box<DocumentPagesPageXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocumentPagesPageXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl DocumentPagesPageXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<u32> = None;
                let mut base_loc: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BaseLoc")
                    ) {
                        helper.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    base_loc: base_loc
                        .ok_or_else(|| ErrorKind::MissingAttribute("BaseLoc".into()))?,
                    state__: Box::new(DocumentPagesPageXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocumentPagesPageXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::DocumentPagesPageXElementType>
            for DocumentPagesPageXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentPagesPageXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocumentPagesPageXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocumentPagesPageXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocumentPagesPageXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocumentPagesPageXElementType {
                    id: self.id,
                    base_loc: self.base_loc,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct CtBookmarkXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtBookmarkXType,
            pub(super) state: Box<CtBookmarkXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtBookmarkXTypeSerializerState<'ser> {
            Init__,
            Dest(<super::super::definition::CtDestXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtBookmarkXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtBookmarkXTypeSerializerState::Init__ => {
                            *self.state = CtBookmarkXTypeSerializerState::Dest(
                                WithSerializer::serializer(&self.value.dest, Some("Dest"), false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Name", &self.value.name)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtBookmarkXTypeSerializerState::Dest(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtBookmarkXTypeSerializerState::End__,
                            }
                        }
                        CtBookmarkXTypeSerializerState::End__ => {
                            *self.state = CtBookmarkXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtBookmarkXTypeSerializerState::Done__ => return Ok(None),
                        CtBookmarkXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtBookmarkXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtBookmarkXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtOutlineElemXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtOutlineElemXType,
            pub(super) state: Box<CtOutlineElemXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtOutlineElemXTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtGraphicUnitActionsXElementType>,
                    super::super::page::CtGraphicUnitActionsXElementType,
                >,
            ),
            OutlineElem(
                IterSerializer<'ser, &'ser [super::CtOutlineElemXType], super::CtOutlineElemXType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtOutlineElemXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtOutlineElemXTypeSerializerState::Init__ => {
                            *self.state =
                                CtOutlineElemXTypeSerializerState::Actions(IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Title", &self.value.title)?;
                            helper.write_attrib_opt(&mut bytes, "Count", &self.value.count)?;
                            helper.write_attrib(&mut bytes, "Expanded", &self.value.expanded)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtOutlineElemXTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtOutlineElemXTypeSerializerState::OutlineElem(
                                        IterSerializer::new(
                                            &self.value.outline_elem[..],
                                            Some("OutlineElem"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtOutlineElemXTypeSerializerState::OutlineElem(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtOutlineElemXTypeSerializerState::End__,
                            }
                        }
                        CtOutlineElemXTypeSerializerState::End__ => {
                            *self.state = CtOutlineElemXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtOutlineElemXTypeSerializerState::Done__ => return Ok(None),
                        CtOutlineElemXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtOutlineElemXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtOutlineElemXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPermissionXType,
            pub(super) state: Box<CtPermissionXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPermissionXTypeSerializerState<'ser> {
            Init__,
            Edit(IterSerializer<'ser, Option<&'ser bool>, bool>),
            Annot(IterSerializer<'ser, Option<&'ser bool>, bool>),
            Export(IterSerializer<'ser, Option<&'ser bool>, bool>),
            Signature(IterSerializer<'ser, Option<&'ser bool>, bool>),
            Watermark(IterSerializer<'ser, Option<&'ser bool>, bool>),
            PrintScreen(IterSerializer<'ser, Option<&'ser bool>, bool>),
            Print(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtPermissionPrintXElementType>,
                    super::CtPermissionPrintXElementType,
                >,
            ),
            ValidPeriod(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtPermissionValidPeriodXElementType>,
                    super::CtPermissionValidPeriodXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPermissionXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPermissionXTypeSerializerState::Init__ => {
                            *self.state = CtPermissionXTypeSerializerState::Edit(
                                IterSerializer::new(self.value.edit.as_ref(), Some("Edit"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPermissionXTypeSerializerState::Edit(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::Annot(
                                        IterSerializer::new(
                                            self.value.annot.as_ref(),
                                            Some("Annot"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::Annot(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::Export(
                                        IterSerializer::new(
                                            self.value.export.as_ref(),
                                            Some("Export"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::Export(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::Signature(
                                        IterSerializer::new(
                                            self.value.signature.as_ref(),
                                            Some("Signature"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::Signature(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::Watermark(
                                        IterSerializer::new(
                                            self.value.watermark.as_ref(),
                                            Some("Watermark"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::Watermark(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::PrintScreen(
                                        IterSerializer::new(
                                            self.value.print_screen.as_ref(),
                                            Some("PrintScreen"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::PrintScreen(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::Print(
                                        IterSerializer::new(
                                            self.value.print.as_ref(),
                                            Some("Print"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::Print(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPermissionXTypeSerializerState::ValidPeriod(
                                        IterSerializer::new(
                                            self.value.valid_period.as_ref(),
                                            Some("ValidPeriod"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtPermissionXTypeSerializerState::ValidPeriod(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtPermissionXTypeSerializerState::End__,
                            }
                        }
                        CtPermissionXTypeSerializerState::End__ => {
                            *self.state = CtPermissionXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPermissionXTypeSerializerState::Done__ => return Ok(None),
                        CtPermissionXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPermissionXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPermissionXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtVPreferencesXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtVPreferencesXType,
            pub(super) state: Box<CtVPreferencesXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtVPreferencesXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtVPreferencesXTypeContent],
                    super::CtVPreferencesXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtVPreferencesXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtVPreferencesXTypeSerializerState::Init__ => {
                            *self.state = CtVPreferencesXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtVPreferencesXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtVPreferencesXTypeSerializerState::End__,
                            }
                        }
                        CtVPreferencesXTypeSerializerState::End__ => {
                            *self.state = CtVPreferencesXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtVPreferencesXTypeSerializerState::Done__ => return Ok(None),
                        CtVPreferencesXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtVPreferencesXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtVPreferencesXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtVPreferencesXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtVPreferencesXTypeContent,
            pub(super) state: Box<CtVPreferencesXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtVPreferencesXTypeContentSerializerState<'ser> {
            Init__,
            PageMode(
                <super::CtVPreferencesPageModeXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageLayout(
                <super::CtVPreferencesPageLayoutXElementType as WithSerializer>::Serializer<'ser>,
            ),
            TabDisplay(
                <super::CtVPreferencesTabDisplayXElementType as WithSerializer>::Serializer<'ser>,
            ),
            HideToolbar(<bool as WithSerializer>::Serializer<'ser>),
            HideMenubar(<bool as WithSerializer>::Serializer<'ser>),
            HideWindowUi(<bool as WithSerializer>::Serializer<'ser>),
            ZoomMode(
                <super::CtVPreferencesZoomModeXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Zoom(<f64 as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtVPreferencesXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtVPreferencesXTypeContentSerializerState::Init__ => match self.value {
                            super::CtVPreferencesXTypeContent::PageMode(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::PageMode(
                                    WithSerializer::serializer(x, Some("PageMode"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::PageLayout(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::PageLayout(
                                    WithSerializer::serializer(x, Some("PageLayout"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::TabDisplay(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::TabDisplay(
                                    WithSerializer::serializer(x, Some("TabDisplay"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::HideToolbar(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::HideToolbar(
                                    WithSerializer::serializer(x, Some("HideToolbar"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::HideMenubar(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::HideMenubar(
                                    WithSerializer::serializer(x, Some("HideMenubar"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::HideWindowUi(x) => {
                                *self.state =
                                    CtVPreferencesXTypeContentSerializerState::HideWindowUi(
                                        WithSerializer::serializer(x, Some("HideWindowUI"), false)?,
                                    )
                            }
                            super::CtVPreferencesXTypeContent::ZoomMode(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::ZoomMode(
                                    WithSerializer::serializer(x, Some("ZoomMode"), false)?,
                                )
                            }
                            super::CtVPreferencesXTypeContent::Zoom(x) => {
                                *self.state = CtVPreferencesXTypeContentSerializerState::Zoom(
                                    WithSerializer::serializer(x, Some("Zoom"), false)?,
                                )
                            }
                        },
                        CtVPreferencesXTypeContentSerializerState::PageMode(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::PageLayout(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::TabDisplay(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::HideToolbar(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::HideMenubar(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::HideWindowUi(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::ZoomMode(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::Zoom(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVPreferencesXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtVPreferencesXTypeContentSerializerState::Done__ => return Ok(None),
                        CtVPreferencesXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtVPreferencesXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtVPreferencesXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentXElementType,
            pub(super) state: Box<DocumentXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentXElementTypeSerializerState<'ser> {
            Init__,
            CommonData(<super::DocumentCommonDataXElementType as WithSerializer>::Serializer<'ser>),
            Pages(<super::DocumentPagesXElementType as WithSerializer>::Serializer<'ser>),
            Outlines(
                IterSerializer<
                    'ser,
                    Option<&'ser super::DocumentOutlinesXElementType>,
                    super::DocumentOutlinesXElementType,
                >,
            ),
            Permissions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtPermissionXType>,
                    super::CtPermissionXType,
                >,
            ),
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtGraphicUnitActionsXElementType>,
                    super::super::page::CtGraphicUnitActionsXElementType,
                >,
            ),
            VPreferences(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtVPreferencesXType>,
                    super::CtVPreferencesXType,
                >,
            ),
            Bookmarks(
                IterSerializer<
                    'ser,
                    Option<&'ser super::DocumentBookmarksXElementType>,
                    super::DocumentBookmarksXElementType,
                >,
            ),
            Annotations(IterSerializer<'ser, Option<&'ser String>, String>),
            CustomTags(IterSerializer<'ser, Option<&'ser String>, String>),
            Attachments(IterSerializer<'ser, Option<&'ser String>, String>),
            Extensions(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentXElementTypeSerializerState::CommonData(
                                WithSerializer::serializer(
                                    &self.value.common_data,
                                    Some("CommonData"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocumentXElementTypeSerializerState::CommonData(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Pages(
                                        WithSerializer::serializer(
                                            &self.value.pages,
                                            Some("Pages"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Pages(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Outlines(
                                        IterSerializer::new(
                                            self.value.outlines.as_ref(),
                                            Some("Outlines"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Outlines(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Permissions(
                                        IterSerializer::new(
                                            self.value.permissions.as_ref(),
                                            Some("Permissions"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Permissions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Actions(
                                        IterSerializer::new(
                                            self.value.actions.as_ref(),
                                            Some("Actions"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::VPreferences(
                                        IterSerializer::new(
                                            self.value.v_preferences.as_ref(),
                                            Some("VPreferences"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::VPreferences(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Bookmarks(
                                        IterSerializer::new(
                                            self.value.bookmarks.as_ref(),
                                            Some("Bookmarks"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Bookmarks(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Annotations(
                                        IterSerializer::new(
                                            self.value.annotations.as_ref(),
                                            Some("Annotations"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Annotations(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::CustomTags(
                                        IterSerializer::new(
                                            self.value.custom_tags.as_ref(),
                                            Some("CustomTags"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::CustomTags(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Attachments(
                                        IterSerializer::new(
                                            self.value.attachments.as_ref(),
                                            Some("Attachments"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Attachments(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentXElementTypeSerializerState::Extensions(
                                        IterSerializer::new(
                                            self.value.extensions.as_ref(),
                                            Some("Extensions"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        DocumentXElementTypeSerializerState::Extensions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = DocumentXElementTypeSerializerState::End__,
                            }
                        }
                        DocumentXElementTypeSerializerState::End__ => {
                            *self.state = DocumentXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocumentXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionPrintXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPermissionPrintXElementType,
            pub(super) state: Box<CtPermissionPrintXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPermissionPrintXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPermissionPrintXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPermissionPrintXElementTypeSerializerState::Init__ => {
                            *self.state = CtPermissionPrintXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Printable", &self.value.printable)?;
                            helper.write_attrib(&mut bytes, "Copies", &self.value.copies)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtPermissionPrintXElementTypeSerializerState::Done__ => return Ok(None),
                        CtPermissionPrintXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPermissionPrintXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPermissionPrintXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPermissionValidPeriodXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPermissionValidPeriodXElementType,
            pub(super) state: Box<CtPermissionValidPeriodXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPermissionValidPeriodXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPermissionValidPeriodXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPermissionValidPeriodXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPermissionValidPeriodXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "StartDate",
                                &self.value.start_date,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "EndDate", &self.value.end_date)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        CtPermissionValidPeriodXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtPermissionValidPeriodXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPermissionValidPeriodXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPermissionValidPeriodXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentCommonDataXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentCommonDataXElementType,
            pub(super) state: Box<DocumentCommonDataXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentCommonDataXElementTypeSerializerState<'ser> {
            Init__,
            MaxUnitId(<u32 as WithSerializer>::Serializer<'ser>),
            PageArea(
                <super::super::definition::CtPageAreaXType as WithSerializer>::Serializer<'ser>,
            ),
            PublicRes(IterSerializer<'ser, &'ser [String], String>),
            DocumentRes(IterSerializer<'ser, &'ser [String], String>),
            TemplatePage(
                IterSerializer<
                    'ser,
                    &'ser [super::DocumentCommonDataTemplatePageXElementType],
                    super::DocumentCommonDataTemplatePageXElementType,
                >,
            ),
            DefaultCs(IterSerializer<'ser, Option<&'ser u32>, u32>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentCommonDataXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentCommonDataXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentCommonDataXElementTypeSerializerState::MaxUnitId(
                                WithSerializer::serializer(
                                    &self.value.max_unit_id,
                                    Some("MaxUnitID"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocumentCommonDataXElementTypeSerializerState::MaxUnitId(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::PageArea(
                                            WithSerializer::serializer(
                                                &self.value.page_area,
                                                Some("PageArea"),
                                                false,
                                            )?,
                                        )
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::PageArea(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::PublicRes(
                                            IterSerializer::new(
                                                &self.value.public_res[..],
                                                Some("PublicRes"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::PublicRes(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::DocumentRes(
                                            IterSerializer::new(
                                                &self.value.document_res[..],
                                                Some("DocumentRes"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::DocumentRes(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::TemplatePage(
                                            IterSerializer::new(
                                                &self.value.template_page[..],
                                                Some("TemplatePage"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::TemplatePage(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::DefaultCs(
                                            IterSerializer::new(
                                                self.value.default_cs.as_ref(),
                                                Some("DefaultCs"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::DefaultCs(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentCommonDataXElementTypeSerializerState::End__
                                }
                            }
                        }
                        DocumentCommonDataXElementTypeSerializerState::End__ => {
                            *self.state = DocumentCommonDataXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocumentCommonDataXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentCommonDataXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentCommonDataXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentCommonDataXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentPagesXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentPagesXElementType,
            pub(super) state: Box<DocumentPagesXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentPagesXElementTypeSerializerState<'ser> {
            Init__,
            Page(
                IterSerializer<
                    'ser,
                    &'ser [super::DocumentPagesPageXElementType],
                    super::DocumentPagesPageXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentPagesXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentPagesXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentPagesXElementTypeSerializerState::Page(
                                IterSerializer::new(&self.value.page[..], Some("Page"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocumentPagesXElementTypeSerializerState::Page(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = DocumentPagesXElementTypeSerializerState::End__,
                        },
                        DocumentPagesXElementTypeSerializerState::End__ => {
                            *self.state = DocumentPagesXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocumentPagesXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentPagesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentPagesXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentPagesXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentOutlinesXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentOutlinesXElementType,
            pub(super) state: Box<DocumentOutlinesXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentOutlinesXElementTypeSerializerState<'ser> {
            Init__,
            OutlineElem(
                IterSerializer<'ser, &'ser [super::CtOutlineElemXType], super::CtOutlineElemXType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentOutlinesXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentOutlinesXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentOutlinesXElementTypeSerializerState::OutlineElem(
                                IterSerializer::new(
                                    &self.value.outline_elem[..],
                                    Some("OutlineElem"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocumentOutlinesXElementTypeSerializerState::OutlineElem(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocumentOutlinesXElementTypeSerializerState::End__
                                }
                            }
                        }
                        DocumentOutlinesXElementTypeSerializerState::End__ => {
                            *self.state = DocumentOutlinesXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocumentOutlinesXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentOutlinesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentOutlinesXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentOutlinesXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentBookmarksXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentBookmarksXElementType,
            pub(super) state: Box<DocumentBookmarksXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentBookmarksXElementTypeSerializerState<'ser> {
            Init__,
            Bookmark(IterSerializer<'ser, &'ser [super::CtBookmarkXType], super::CtBookmarkXType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentBookmarksXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentBookmarksXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentBookmarksXElementTypeSerializerState::Bookmark(
                                IterSerializer::new(
                                    &self.value.bookmark[..],
                                    Some("Bookmark"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocumentBookmarksXElementTypeSerializerState::Bookmark(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocumentBookmarksXElementTypeSerializerState::End__
                                }
                            }
                        }
                        DocumentBookmarksXElementTypeSerializerState::End__ => {
                            *self.state = DocumentBookmarksXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocumentBookmarksXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentBookmarksXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentBookmarksXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentBookmarksXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentCommonDataTemplatePageXElementType,
            pub(super) state: Box<DocumentCommonDataTemplatePageXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentCommonDataTemplatePageXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentCommonDataTemplatePageXElementTypeSerializerState::Init__ => {
                            *self.state =
                                DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib_opt(&mut bytes, "ZOrder", &self.value.z_order)?;
                            helper.write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        DocumentCommonDataTemplatePageXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentCommonDataTemplatePageXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            DocumentCommonDataTemplatePageXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocumentPagesPageXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocumentPagesPageXElementType,
            pub(super) state: Box<DocumentPagesPageXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocumentPagesPageXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocumentPagesPageXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocumentPagesPageXElementTypeSerializerState::Init__ => {
                            *self.state = DocumentPagesPageXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        DocumentPagesPageXElementTypeSerializerState::Done__ => return Ok(None),
                        DocumentPagesPageXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocumentPagesPageXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocumentPagesPageXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod extensions {
    use xsd_parser_types::{
        quick_xml::{Error, WithDeserializer, WithSerializer},
        xml::AnyElement,
    };
    #[derive(Debug)]
    pub struct CtExtensionXType {
        pub app_name: String,
        pub company: Option<String>,
        pub app_version: Option<String>,
        pub date: Option<String>,
        pub ref_id: u32,
        pub content: Vec<CtExtensionXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtExtensionXTypeContent {
        Property(CtExtensionPropertyXElementType),
        Data(AnyElement),
        ExtendData(String),
    }
    impl WithSerializer for CtExtensionXType {
        type Serializer<'x> = quick_xml_serialize::CtExtensionXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtExtensionXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtExtensionXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Extension"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtExtensionXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtExtensionXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtExtensionXTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtExtensionXTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for CtExtensionXType {
        type Deserializer = quick_xml_deserialize::CtExtensionXTypeDeserializer;
    }
    impl WithDeserializer for CtExtensionXTypeContent {
        type Deserializer = quick_xml_deserialize::CtExtensionXTypeContentDeserializer;
    }
    pub type Extensions = ExtensionsXElementType;
    #[derive(Debug)]
    pub struct ExtensionsXElementType {
        pub extension: Vec<CtExtensionXType>,
    }
    impl WithSerializer for ExtensionsXElementType {
        type Serializer<'x> = quick_xml_serialize::ExtensionsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ExtensionsXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ExtensionsXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Extensions"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ExtensionsXElementType {
        type Deserializer = quick_xml_deserialize::ExtensionsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtExtensionPropertyXElementType {
        pub name: String,
        pub type_: Option<String>,
        pub content: String,
    }
    impl WithSerializer for CtExtensionPropertyXElementType {
        type Serializer<'x> = quick_xml_serialize::CtExtensionPropertyXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtExtensionPropertyXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtExtensionPropertyXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtExtensionProperty"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtExtensionPropertyXElementType {
        type Deserializer = quick_xml_deserialize::CtExtensionPropertyXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::{
            quick_xml::{
                BytesStart, ContentDeserializer, DeserializeHelper, Deserializer,
                DeserializerArtifact, DeserializerEvent, DeserializerOutput, DeserializerResult,
                ElementHandlerOutput, Error, ErrorKind, Event, RawByteStr, WithDeserializer,
            },
            xml::AnyElement,
        };
        #[derive(Debug)]
        pub struct CtExtensionXTypeDeserializer {
            app_name: String,
            company: Option<String>,
            app_version: Option<String>,
            date: Option<String>,
            ref_id: u32,
            content: Vec<super::CtExtensionXTypeContent>,
            state__: Box<CtExtensionXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtExtensionXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtExtensionXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtExtensionXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut app_name: Option<String> = None;
                let mut company: Option<String> = None;
                let mut app_version: Option<String> = None;
                let mut date: Option<String> = None;
                let mut ref_id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"AppName")
                    ) {
                        helper.read_attrib(&mut app_name, b"AppName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Company")
                    ) {
                        helper.read_attrib(&mut company, b"Company", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"AppVersion")
                    ) {
                        helper.read_attrib(&mut app_version, b"AppVersion", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Date")
                    ) {
                        helper.read_attrib(&mut date, b"Date", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"RefId")
                    ) {
                        helper.read_attrib(&mut ref_id, b"RefId", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    app_name: app_name
                        .ok_or_else(|| ErrorKind::MissingAttribute("AppName".into()))?,
                    company: company,
                    app_version: app_version,
                    date: date,
                    ref_id: ref_id.ok_or_else(|| ErrorKind::MissingAttribute("RefId".into()))?,
                    content: Vec::new(),
                    state__: Box::new(CtExtensionXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtExtensionXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtExtensionXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtExtensionXTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtExtensionXTypeContent>,
                fallback: &mut Option<CtExtensionXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtExtensionXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtExtensionXType> for CtExtensionXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionXType> {
                use CtExtensionXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::CtExtensionXTypeContent as WithDeserializer>::init(
                                    helper, event,
                                )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtExtensionXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtExtensionXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtExtensionXType {
                    app_name: self.app_name,
                    company: self.company,
                    app_version: self.app_version,
                    date: self.date,
                    ref_id: self.ref_id,
                    content: helper.finish_vec(1usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtExtensionXTypeContentDeserializer {
            state__: Box<CtExtensionXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtExtensionXTypeContentDeserializerState {
            Init__,
            Property(
                Option<super::CtExtensionPropertyXElementType>,
                Option<<super::CtExtensionPropertyXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtExtensionPropertyXElementType as WithDeserializer>::Deserializer>,
            ),
            Data(
                Option<AnyElement>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
                Option<<AnyElement as WithDeserializer>::Deserializer>,
            ),
            ExtendData(
                Option<String>,
                Option<<String as WithDeserializer>::Deserializer>,
                Option<<String as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtExtensionXTypeContent),
            Unknown__,
        }
        impl CtExtensionXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Property")
                    ) {
                        let output =
                            <super::CtExtensionPropertyXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_property(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Data")
                    ) {
                        let output = <AnyElement as WithDeserializer>::init(helper, event)?;
                        return self.handle_data(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ExtendData")
                    ) {
                        let output = <String as WithDeserializer>::init(helper, event)?;
                        return self.handle_extend_data(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtExtensionXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtExtensionXTypeContentDeserializerState,
            ) -> Result<super::CtExtensionXTypeContent, Error> {
                use CtExtensionXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Property(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_property(&mut values, value)?;
                        }
                        Ok(super::CtExtensionXTypeContent::Property(
                            helper.finish_element("Property", values)?,
                        ))
                    }
                    S::Data(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_data(&mut values, value)?;
                        }
                        Ok(super::CtExtensionXTypeContent::Data(
                            helper.finish_element("Data", values)?,
                        ))
                    }
                    S::ExtendData(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_extend_data(&mut values, value)?;
                        }
                        Ok(super::CtExtensionXTypeContent::ExtendData(
                            helper.finish_element("ExtendData", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_property(
                values: &mut Option<super::CtExtensionPropertyXElementType>,
                value: super::CtExtensionPropertyXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Property",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_data(values: &mut Option<AnyElement>, value: AnyElement) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Data")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_extend_data(values: &mut Option<String>, value: String) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ExtendData",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_property<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtExtensionPropertyXElementType>,
                fallback: Option<
                    <super::CtExtensionPropertyXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtExtensionPropertyXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtExtensionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_property(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_property(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Property(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Property(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<AnyElement>,
                fallback: Option<<AnyElement as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, AnyElement>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtExtensionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_data(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_data(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Data(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Data(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_extend_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<String>,
                fallback: Option<<String as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, String>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtExtensionXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_extend_data(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_extend_data(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ExtendData(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ExtendData(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtExtensionXTypeContent>
            for CtExtensionXTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtExtensionXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtExtensionXTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionXTypeContent> {
                use CtExtensionXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Property(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_property(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Data(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_data(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ExtendData(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_extend_data(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Property(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Property",
                                false,
                            )?;
                            match self.handle_property(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Data(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Data",
                                true,
                            )?;
                            match self.handle_data(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ExtendData(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ExtendData",
                                false,
                            )?;
                            match self.handle_extend_data(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtExtensionXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct ExtensionsXElementTypeDeserializer {
            extension: Vec<super::CtExtensionXType>,
            state__: Box<ExtensionsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ExtensionsXElementTypeDeserializerState {
            Init__,
            Extension(Option<<super::CtExtensionXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ExtensionsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    extension: Vec::new(),
                    state__: Box::new(ExtensionsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ExtensionsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ExtensionsXElementTypeDeserializerState as S;
                match state {
                    S::Extension(Some(deserializer)) => {
                        self.store_extension(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_extension(&mut self, value: super::CtExtensionXType) -> Result<(), Error> {
                self.extension.push(value);
                Ok(())
            }
            fn handle_extension<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtExtensionXType>,
                fallback: &mut Option<ExtensionsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ExtensionsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.extension.len() < 1usize {
                        fallback.get_or_insert(S::Extension(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Extension(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_extension(data)?;
                        *self.state__ = S::Extension(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Extension(Some(deserializer)));
                        *self.state__ = S::Extension(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ExtensionsXElementType> for ExtensionsXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ExtensionsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ExtensionsXElementType> {
                use ExtensionsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Extension(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_extension(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Extension(None);
                            event
                        }
                        (S::Extension(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Extension",
                                true,
                            )?;
                            match self.handle_extension(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ExtensionsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ExtensionsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ExtensionsXElementType {
                    extension: helper.finish_vec(1usize, None, self.extension)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtExtensionPropertyXElementTypeDeserializer {
            name: String,
            type_: Option<String>,
            content: Option<String>,
            state__: Box<CtExtensionPropertyXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtExtensionPropertyXElementTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtExtensionPropertyXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut name: Option<String> = None;
                let mut type_: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| ErrorKind::MissingAttribute("Name".into()))?,
                    type_: type_,
                    content: None,
                    state__: Box::new(CtExtensionPropertyXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtExtensionPropertyXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtExtensionPropertyXElementTypeDeserializerState::Content__(deserializer) =
                    state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType> {
                use CtExtensionPropertyXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(helper)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtExtensionPropertyXElementType>
            for CtExtensionPropertyXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType> {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(helper, x)?.next(helper, event)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtExtensionPropertyXElementType> {
                use CtExtensionPropertyXElementTypeDeserializerState as S;
                match replace(&mut *self.state__, S::Unknown__) {
                    S::Unknown__ => unreachable!(),
                    S::Init__ => {
                        let output = ContentDeserializer::init(helper, event)?;
                        self.handle_content(helper, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(helper, event)?;
                        self.handle_content(helper, output)
                    }
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtExtensionPropertyXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtExtensionPropertyXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtExtensionPropertyXElementType {
                    name: self.name,
                    type_: self.type_,
                    content: helper.finish_content(self.content)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::{
            quick_xml::{
                BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
                WithSerializer,
            },
            xml::AnyElement,
        };
        #[derive(Debug)]
        pub struct CtExtensionXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtExtensionXType,
            pub(super) state: Box<CtExtensionXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtExtensionXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtExtensionXTypeContent],
                    super::CtExtensionXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtExtensionXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtExtensionXTypeSerializerState::Init__ => {
                            *self.state = CtExtensionXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "AppName", &self.value.app_name)?;
                            helper.write_attrib_opt(&mut bytes, "Company", &self.value.company)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "AppVersion",
                                &self.value.app_version,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Date", &self.value.date)?;
                            helper.write_attrib(&mut bytes, "RefId", &self.value.ref_id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtExtensionXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtExtensionXTypeSerializerState::End__,
                            }
                        }
                        CtExtensionXTypeSerializerState::End__ => {
                            *self.state = CtExtensionXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtExtensionXTypeSerializerState::Done__ => return Ok(None),
                        CtExtensionXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtExtensionXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtExtensionXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtExtensionXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtExtensionXTypeContent,
            pub(super) state: Box<CtExtensionXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtExtensionXTypeContentSerializerState<'ser> {
            Init__,
            Property(<super::CtExtensionPropertyXElementType as WithSerializer>::Serializer<'ser>),
            Data(<AnyElement as WithSerializer>::Serializer<'ser>),
            ExtendData(<String as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtExtensionXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtExtensionXTypeContentSerializerState::Init__ => match self.value {
                            super::CtExtensionXTypeContent::Property(x) => {
                                *self.state = CtExtensionXTypeContentSerializerState::Property(
                                    WithSerializer::serializer(x, Some("Property"), false)?,
                                )
                            }
                            super::CtExtensionXTypeContent::Data(x) => {
                                *self.state = CtExtensionXTypeContentSerializerState::Data(
                                    WithSerializer::serializer(x, Some("Data"), false)?,
                                )
                            }
                            super::CtExtensionXTypeContent::ExtendData(x) => {
                                *self.state = CtExtensionXTypeContentSerializerState::ExtendData(
                                    WithSerializer::serializer(x, Some("ExtendData"), false)?,
                                )
                            }
                        },
                        CtExtensionXTypeContentSerializerState::Property(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtExtensionXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtExtensionXTypeContentSerializerState::Data(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtExtensionXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtExtensionXTypeContentSerializerState::ExtendData(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtExtensionXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtExtensionXTypeContentSerializerState::Done__ => return Ok(None),
                        CtExtensionXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtExtensionXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtExtensionXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ExtensionsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ExtensionsXElementType,
            pub(super) state: Box<ExtensionsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ExtensionsXElementTypeSerializerState<'ser> {
            Init__,
            Extension(
                IterSerializer<'ser, &'ser [super::CtExtensionXType], super::CtExtensionXType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ExtensionsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ExtensionsXElementTypeSerializerState::Init__ => {
                            *self.state = ExtensionsXElementTypeSerializerState::Extension(
                                IterSerializer::new(
                                    &self.value.extension[..],
                                    Some("Extension"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ExtensionsXElementTypeSerializerState::Extension(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ExtensionsXElementTypeSerializerState::End__,
                            }
                        }
                        ExtensionsXElementTypeSerializerState::End__ => {
                            *self.state = ExtensionsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ExtensionsXElementTypeSerializerState::Done__ => return Ok(None),
                        ExtensionsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ExtensionsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ExtensionsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtExtensionPropertyXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtExtensionPropertyXElementType,
            pub(super) state: Box<CtExtensionPropertyXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtExtensionPropertyXElementTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtExtensionPropertyXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtExtensionPropertyXElementTypeSerializerState::Init__ => {
                            *self.state = CtExtensionPropertyXElementTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib_opt(&mut bytes, "Type", &self.value.type_)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtExtensionPropertyXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtExtensionPropertyXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtExtensionPropertyXElementTypeSerializerState::End__ => {
                            *self.state = CtExtensionPropertyXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtExtensionPropertyXElementTypeSerializerState::Done__ => return Ok(None),
                        CtExtensionPropertyXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtExtensionPropertyXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtExtensionPropertyXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod ofd {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    #[derive(Debug)]
    pub struct CtDocInfoXType {
        pub doc_id: String,
        pub title: Option<String>,
        pub author: Option<String>,
        pub subject: Option<String>,
        pub abstract_: Option<String>,
        pub creation_date: Option<String>,
        pub mod_date: Option<String>,
        pub doc_usage: Option<String>,
        pub cover: Option<String>,
        pub keywords: Option<CtDocInfoKeywordsXElementType>,
        pub creator: Option<String>,
        pub creator_version: Option<String>,
        pub custom_datas: Option<CtDocInfoCustomDatasXElementType>,
    }
    impl WithSerializer for CtDocInfoXType {
        type Serializer<'x> = quick_xml_serialize::CtDocInfoXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtDocInfoXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtDocInfoXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_DocInfo"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtDocInfoXType {
        type Deserializer = quick_xml_deserialize::CtDocInfoXTypeDeserializer;
    }
    pub type Ofd = OfdXElementType;
    #[derive(Debug)]
    pub struct OfdXElementType {
        pub version: String,
        pub doc_type: OfdDocTypeXType,
        pub doc_body: Vec<OfdDocBodyXElementType>,
    }
    impl WithSerializer for OfdXElementType {
        type Serializer<'x> = quick_xml_serialize::OfdXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::OfdXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::OfdXElementTypeSerializerState::Init__),
                name: name.unwrap_or("OFD"),
                is_root,
            })
        }
    }
    impl WithDeserializer for OfdXElementType {
        type Deserializer = quick_xml_deserialize::OfdXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtDocInfoKeywordsXElementType {
        pub keyword: Vec<String>,
    }
    impl WithSerializer for CtDocInfoKeywordsXElementType {
        type Serializer<'x> = quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtDocInfoKeywordsXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtDocInfoKeywords"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtDocInfoKeywordsXElementType {
        type Deserializer = quick_xml_deserialize::CtDocInfoKeywordsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasXElementType {
        pub custom_data: Vec<CtDocInfoCustomDatasCustomDataXElementType>,
    }
    impl WithSerializer for CtDocInfoCustomDatasXElementType {
        type Serializer<'x> = quick_xml_serialize::CtDocInfoCustomDatasXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtDocInfoCustomDatasXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtDocInfoCustomDatasXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtDocInfoCustomDatas") , is_root , })
        }
    }
    impl WithDeserializer for CtDocInfoCustomDatasXElementType {
        type Deserializer = quick_xml_deserialize::CtDocInfoCustomDatasXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum OfdDocTypeXType {
        Ofd,
    }
    impl SerializeBytes for OfdDocTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Ofd => Ok(Some(Cow::Borrowed("OFD"))),
            }
        }
    }
    impl DeserializeBytes for OfdDocTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"OFD" => Ok(Self::Ofd),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct OfdDocBodyXElementType {
        pub doc_info: CtDocInfoXType,
        pub doc_root: String,
        pub versions: Option<OfdDocBodyVersionsXElementType>,
        pub signatures: Option<String>,
    }
    impl WithSerializer for OfdDocBodyXElementType {
        type Serializer<'x> = quick_xml_serialize::OfdDocBodyXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::OfdDocBodyXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::OfdDocBodyXElementTypeSerializerState::Init__),
                name: name.unwrap_or("OfdDocBody"),
                is_root,
            })
        }
    }
    impl WithDeserializer for OfdDocBodyXElementType {
        type Deserializer = quick_xml_deserialize::OfdDocBodyXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtDocInfoCustomDatasCustomDataXElementType {
        pub name: String,
        pub content: String,
    }
    impl WithSerializer for CtDocInfoCustomDatasCustomDataXElementType {
        type Serializer<'x> =
            quick_xml_serialize::CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtDocInfoCustomDatasCustomDataXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtDocInfoCustomDatasCustomData") , is_root , })
        }
    }
    impl WithDeserializer for CtDocInfoCustomDatasCustomDataXElementType {
        type Deserializer =
            quick_xml_deserialize::CtDocInfoCustomDatasCustomDataXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsXElementType {
        pub version: Vec<OfdDocBodyVersionsVersionXElementType>,
    }
    impl WithSerializer for OfdDocBodyVersionsXElementType {
        type Serializer<'x> = quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::OfdDocBodyVersionsXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("OfdDocBodyVersions"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for OfdDocBodyVersionsXElementType {
        type Deserializer = quick_xml_deserialize::OfdDocBodyVersionsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct OfdDocBodyVersionsVersionXElementType {
        pub id: String,
        pub index: i32,
        pub current: bool,
        pub base_loc: String,
    }
    impl OfdDocBodyVersionsVersionXElementType {
        #[must_use]
        pub fn default_current() -> bool {
            false
        }
    }
    impl WithSerializer for OfdDocBodyVersionsVersionXElementType {
        type Serializer<'x> =
            quick_xml_serialize::OfdDocBodyVersionsVersionXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: OfdDocBodyVersionsVersionXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: OfdDocBodyVersionsVersionXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("OfdDocBodyVersionsVersion") , is_root , })
        }
    }
    impl WithDeserializer for OfdDocBodyVersionsVersionXElementType {
        type Deserializer =
            quick_xml_deserialize::OfdDocBodyVersionsVersionXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, ContentDeserializer, DeserializeHelper, Deserializer, DeserializerArtifact,
            DeserializerEvent, DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error,
            ErrorKind, Event, RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct CtDocInfoXTypeDeserializer {
            doc_id: Option<String>,
            title: Option<String>,
            author: Option<String>,
            subject: Option<String>,
            abstract_: Option<String>,
            creation_date: Option<String>,
            mod_date: Option<String>,
            doc_usage: Option<String>,
            cover: Option<String>,
            keywords: Option<super::CtDocInfoKeywordsXElementType>,
            creator: Option<String>,
            creator_version: Option<String>,
            custom_datas: Option<super::CtDocInfoCustomDatasXElementType>,
            state__: Box<CtDocInfoXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDocInfoXTypeDeserializerState {
            Init__,
            DocId(Option<<String as WithDeserializer>::Deserializer>),
            Title(Option<<String as WithDeserializer>::Deserializer>),
            Author(Option<<String as WithDeserializer>::Deserializer>),
            Subject(Option<<String as WithDeserializer>::Deserializer>),
            Abstract(Option<<String as WithDeserializer>::Deserializer>),
            CreationDate(Option<<String as WithDeserializer>::Deserializer>),
            ModDate(Option<<String as WithDeserializer>::Deserializer>),
            DocUsage(Option<<String as WithDeserializer>::Deserializer>),
            Cover(Option<<String as WithDeserializer>::Deserializer>),
            Keywords(
                Option<<super::CtDocInfoKeywordsXElementType as WithDeserializer>::Deserializer>,
            ),
            Creator(Option<<String as WithDeserializer>::Deserializer>),
            CreatorVersion(Option<<String as WithDeserializer>::Deserializer>),
            CustomDatas(
                Option<<super::CtDocInfoCustomDatasXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtDocInfoXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    doc_id: None,
                    title: None,
                    author: None,
                    subject: None,
                    abstract_: None,
                    creation_date: None,
                    mod_date: None,
                    doc_usage: None,
                    cover: None,
                    keywords: None,
                    creator: None,
                    creator_version: None,
                    custom_datas: None,
                    state__: Box::new(CtDocInfoXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDocInfoXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtDocInfoXTypeDeserializerState as S;
                match state {
                    S::DocId(Some(deserializer)) => {
                        self.store_doc_id(deserializer.finish(helper)?)?
                    }
                    S::Title(Some(deserializer)) => {
                        self.store_title(deserializer.finish(helper)?)?
                    }
                    S::Author(Some(deserializer)) => {
                        self.store_author(deserializer.finish(helper)?)?
                    }
                    S::Subject(Some(deserializer)) => {
                        self.store_subject(deserializer.finish(helper)?)?
                    }
                    S::Abstract(Some(deserializer)) => {
                        self.store_abstract_(deserializer.finish(helper)?)?
                    }
                    S::CreationDate(Some(deserializer)) => {
                        self.store_creation_date(deserializer.finish(helper)?)?
                    }
                    S::ModDate(Some(deserializer)) => {
                        self.store_mod_date(deserializer.finish(helper)?)?
                    }
                    S::DocUsage(Some(deserializer)) => {
                        self.store_doc_usage(deserializer.finish(helper)?)?
                    }
                    S::Cover(Some(deserializer)) => {
                        self.store_cover(deserializer.finish(helper)?)?
                    }
                    S::Keywords(Some(deserializer)) => {
                        self.store_keywords(deserializer.finish(helper)?)?
                    }
                    S::Creator(Some(deserializer)) => {
                        self.store_creator(deserializer.finish(helper)?)?
                    }
                    S::CreatorVersion(Some(deserializer)) => {
                        self.store_creator_version(deserializer.finish(helper)?)?
                    }
                    S::CustomDatas(Some(deserializer)) => {
                        self.store_custom_datas(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_doc_id(&mut self, value: String) -> Result<(), Error> {
                if self.doc_id.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DocID",
                    )))?;
                }
                self.doc_id = Some(value);
                Ok(())
            }
            fn store_title(&mut self, value: String) -> Result<(), Error> {
                if self.title.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Title",
                    )))?;
                }
                self.title = Some(value);
                Ok(())
            }
            fn store_author(&mut self, value: String) -> Result<(), Error> {
                if self.author.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Author",
                    )))?;
                }
                self.author = Some(value);
                Ok(())
            }
            fn store_subject(&mut self, value: String) -> Result<(), Error> {
                if self.subject.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Subject",
                    )))?;
                }
                self.subject = Some(value);
                Ok(())
            }
            fn store_abstract_(&mut self, value: String) -> Result<(), Error> {
                if self.abstract_.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Abstract",
                    )))?;
                }
                self.abstract_ = Some(value);
                Ok(())
            }
            fn store_creation_date(&mut self, value: String) -> Result<(), Error> {
                if self.creation_date.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CreationDate",
                    )))?;
                }
                self.creation_date = Some(value);
                Ok(())
            }
            fn store_mod_date(&mut self, value: String) -> Result<(), Error> {
                if self.mod_date.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ModDate",
                    )))?;
                }
                self.mod_date = Some(value);
                Ok(())
            }
            fn store_doc_usage(&mut self, value: String) -> Result<(), Error> {
                if self.doc_usage.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DocUsage",
                    )))?;
                }
                self.doc_usage = Some(value);
                Ok(())
            }
            fn store_cover(&mut self, value: String) -> Result<(), Error> {
                if self.cover.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Cover",
                    )))?;
                }
                self.cover = Some(value);
                Ok(())
            }
            fn store_keywords(
                &mut self,
                value: super::CtDocInfoKeywordsXElementType,
            ) -> Result<(), Error> {
                if self.keywords.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Keywords",
                    )))?;
                }
                self.keywords = Some(value);
                Ok(())
            }
            fn store_creator(&mut self, value: String) -> Result<(), Error> {
                if self.creator.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Creator",
                    )))?;
                }
                self.creator = Some(value);
                Ok(())
            }
            fn store_creator_version(&mut self, value: String) -> Result<(), Error> {
                if self.creator_version.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CreatorVersion",
                    )))?;
                }
                self.creator_version = Some(value);
                Ok(())
            }
            fn store_custom_datas(
                &mut self,
                value: super::CtDocInfoCustomDatasXElementType,
            ) -> Result<(), Error> {
                if self.custom_datas.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CustomDatas",
                    )))?;
                }
                self.custom_datas = Some(value);
                Ok(())
            }
            fn handle_doc_id<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocId(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_id(data)?;
                        *self.state__ = S::Title(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocId(Some(deserializer)));
                        *self.state__ = S::Title(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_title<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Title(None));
                    *self.state__ = S::Author(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_title(data)?;
                        *self.state__ = S::Author(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Title(Some(deserializer)));
                        *self.state__ = S::Author(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_author<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Author(None));
                    *self.state__ = S::Subject(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_author(data)?;
                        *self.state__ = S::Subject(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Author(Some(deserializer)));
                        *self.state__ = S::Subject(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_subject<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Subject(None));
                    *self.state__ = S::Abstract(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_subject(data)?;
                        *self.state__ = S::Abstract(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Subject(Some(deserializer)));
                        *self.state__ = S::Abstract(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_abstract_<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Abstract(None));
                    *self.state__ = S::CreationDate(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_abstract_(data)?;
                        *self.state__ = S::CreationDate(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Abstract(Some(deserializer)));
                        *self.state__ = S::CreationDate(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_creation_date<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CreationDate(None));
                    *self.state__ = S::ModDate(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_creation_date(data)?;
                        *self.state__ = S::ModDate(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CreationDate(Some(deserializer)));
                        *self.state__ = S::ModDate(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_mod_date<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::ModDate(None));
                    *self.state__ = S::DocUsage(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_mod_date(data)?;
                        *self.state__ = S::DocUsage(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::ModDate(Some(deserializer)));
                        *self.state__ = S::DocUsage(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_doc_usage<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocUsage(None));
                    *self.state__ = S::Cover(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_usage(data)?;
                        *self.state__ = S::Cover(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocUsage(Some(deserializer)));
                        *self.state__ = S::Cover(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_cover<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Cover(None));
                    *self.state__ = S::Keywords(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_cover(data)?;
                        *self.state__ = S::Keywords(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Cover(Some(deserializer)));
                        *self.state__ = S::Keywords(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_keywords<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtDocInfoKeywordsXElementType>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Keywords(None));
                    *self.state__ = S::Creator(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_keywords(data)?;
                        *self.state__ = S::Creator(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Keywords(Some(deserializer)));
                        *self.state__ = S::Creator(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_creator<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Creator(None));
                    *self.state__ = S::CreatorVersion(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_creator(data)?;
                        *self.state__ = S::CreatorVersion(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Creator(Some(deserializer)));
                        *self.state__ = S::CreatorVersion(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_creator_version<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CreatorVersion(None));
                    *self.state__ = S::CustomDatas(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_creator_version(data)?;
                        *self.state__ = S::CustomDatas(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CreatorVersion(Some(deserializer)));
                        *self.state__ = S::CustomDatas(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_custom_datas<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtDocInfoCustomDatasXElementType>,
                fallback: &mut Option<CtDocInfoXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CustomDatas(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_custom_datas(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CustomDatas(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtDocInfoXType> for CtDocInfoXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoXType> {
                use CtDocInfoXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::DocId(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Title(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_title(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Author(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_author(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Subject(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_subject(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Abstract(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_abstract_(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CreationDate(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_creation_date(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ModDate(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_mod_date(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocUsage(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_usage(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Cover(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cover(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Keywords(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_keywords(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Creator(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_creator(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CreatorVersion(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_creator_version(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CustomDatas(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_custom_datas(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::DocId(None);
                            event
                        }
                        (S::DocId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocID",
                                false,
                            )?;
                            match self.handle_doc_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Title(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Title",
                                false,
                            )?;
                            match self.handle_title(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Author(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Author",
                                false,
                            )?;
                            match self.handle_author(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Subject(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Subject",
                                false,
                            )?;
                            match self.handle_subject(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Abstract(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Abstract",
                                false,
                            )?;
                            match self.handle_abstract_(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CreationDate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CreationDate",
                                false,
                            )?;
                            match self.handle_creation_date(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::ModDate(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ModDate",
                                false,
                            )?;
                            match self.handle_mod_date(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocUsage(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocUsage",
                                false,
                            )?;
                            match self.handle_doc_usage(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Cover(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Cover",
                                false,
                            )?;
                            match self.handle_cover(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Keywords(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Keywords",
                                false,
                            )?;
                            match self.handle_keywords(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Creator(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Creator",
                                false,
                            )?;
                            match self.handle_creator(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CreatorVersion(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CreatorVersion",
                                false,
                            )?;
                            match self.handle_creator_version(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::CustomDatas(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CustomDatas",
                                false,
                            )?;
                            match self.handle_custom_datas(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDocInfoXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtDocInfoXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtDocInfoXType {
                    doc_id: helper.finish_element("DocID", self.doc_id)?,
                    title: self.title,
                    author: self.author,
                    subject: self.subject,
                    abstract_: self.abstract_,
                    creation_date: self.creation_date,
                    mod_date: self.mod_date,
                    doc_usage: self.doc_usage,
                    cover: self.cover,
                    keywords: self.keywords,
                    creator: self.creator,
                    creator_version: self.creator_version,
                    custom_datas: self.custom_datas,
                })
            }
        }
        #[derive(Debug)]
        pub struct OfdXElementTypeDeserializer {
            version: String,
            doc_type: super::OfdDocTypeXType,
            doc_body: Vec<super::OfdDocBodyXElementType>,
            state__: Box<OfdXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OfdXElementTypeDeserializerState {
            Init__,
            DocBody(Option<<super::OfdDocBodyXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl OfdXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut version: Option<String> = None;
                let mut doc_type: Option<super::OfdDocTypeXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Version")
                    ) {
                        helper.read_attrib(&mut version, b"Version", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DocType")
                    ) {
                        helper.read_attrib(&mut doc_type, b"DocType", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    version: version
                        .ok_or_else(|| ErrorKind::MissingAttribute("Version".into()))?,
                    doc_type: doc_type
                        .ok_or_else(|| ErrorKind::MissingAttribute("DocType".into()))?,
                    doc_body: Vec::new(),
                    state__: Box::new(OfdXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: OfdXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use OfdXElementTypeDeserializerState as S;
                match state {
                    S::DocBody(Some(deserializer)) => {
                        self.store_doc_body(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_doc_body(
                &mut self,
                value: super::OfdDocBodyXElementType,
            ) -> Result<(), Error> {
                self.doc_body.push(value);
                Ok(())
            }
            fn handle_doc_body<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::OfdDocBodyXElementType>,
                fallback: &mut Option<OfdXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.doc_body.len() < 1usize {
                        fallback.get_or_insert(S::DocBody(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::DocBody(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_body(data)?;
                        *self.state__ = S::DocBody(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocBody(Some(deserializer)));
                        *self.state__ = S::DocBody(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::OfdXElementType> for OfdXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdXElementType> {
                use OfdXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::DocBody(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_body(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::DocBody(None);
                            event
                        }
                        (S::DocBody(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocBody",
                                false,
                            )?;
                            match self.handle_doc_body(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::OfdXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    OfdXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::OfdXElementType {
                    version: self.version,
                    doc_type: self.doc_type,
                    doc_body: helper.finish_vec(1usize, None, self.doc_body)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoKeywordsXElementTypeDeserializer {
            keyword: Vec<String>,
            state__: Box<CtDocInfoKeywordsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDocInfoKeywordsXElementTypeDeserializerState {
            Init__,
            Keyword(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtDocInfoKeywordsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    keyword: Vec::new(),
                    state__: Box::new(CtDocInfoKeywordsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDocInfoKeywordsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtDocInfoKeywordsXElementTypeDeserializerState as S;
                match state {
                    S::Keyword(Some(deserializer)) => {
                        self.store_keyword(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_keyword(&mut self, value: String) -> Result<(), Error> {
                self.keyword.push(value);
                Ok(())
            }
            fn handle_keyword<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtDocInfoKeywordsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoKeywordsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.keyword.len() < 1usize {
                        fallback.get_or_insert(S::Keyword(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Keyword(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_keyword(data)?;
                        *self.state__ = S::Keyword(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Keyword(Some(deserializer)));
                        *self.state__ = S::Keyword(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtDocInfoKeywordsXElementType>
            for CtDocInfoKeywordsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoKeywordsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoKeywordsXElementType> {
                use CtDocInfoKeywordsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Keyword(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_keyword(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Keyword(None);
                            event
                        }
                        (S::Keyword(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Keyword",
                                false,
                            )?;
                            match self.handle_keyword(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDocInfoKeywordsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtDocInfoKeywordsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtDocInfoKeywordsXElementType {
                    keyword: helper.finish_vec(1usize, None, self.keyword)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoCustomDatasXElementTypeDeserializer {
            custom_data: Vec<super::CtDocInfoCustomDatasCustomDataXElementType>,
            state__: Box<CtDocInfoCustomDatasXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDocInfoCustomDatasXElementTypeDeserializerState {
            Init__ , CustomData (Option << super :: CtDocInfoCustomDatasCustomDataXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl CtDocInfoCustomDatasXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    custom_data: Vec::new(),
                    state__: Box::new(CtDocInfoCustomDatasXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDocInfoCustomDatasXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtDocInfoCustomDatasXElementTypeDeserializerState as S;
                match state {
                    S::CustomData(Some(deserializer)) => {
                        self.store_custom_data(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_custom_data(
                &mut self,
                value: super::CtDocInfoCustomDatasCustomDataXElementType,
            ) -> Result<(), Error> {
                self.custom_data.push(value);
                Ok(())
            }
            fn handle_custom_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtDocInfoCustomDatasCustomDataXElementType>,
                fallback: &mut Option<CtDocInfoCustomDatasXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDocInfoCustomDatasXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.custom_data.len() < 1usize {
                        fallback.get_or_insert(S::CustomData(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::CustomData(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_custom_data(data)?;
                        *self.state__ = S::CustomData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CustomData(Some(deserializer)));
                        *self.state__ = S::CustomData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtDocInfoCustomDatasXElementType>
            for CtDocInfoCustomDatasXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasXElementType> {
                use CtDocInfoCustomDatasXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CustomData(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_custom_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CustomData(None);
                            event
                        }
                        (S::CustomData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CustomData",
                                false,
                            )?;
                            match self.handle_custom_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDocInfoCustomDatasXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtDocInfoCustomDatasXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtDocInfoCustomDatasXElementType {
                    custom_data: helper.finish_vec(1usize, None, self.custom_data)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyXElementTypeDeserializer {
            doc_info: Option<super::CtDocInfoXType>,
            doc_root: Option<String>,
            versions: Option<super::OfdDocBodyVersionsXElementType>,
            signatures: Option<String>,
            state__: Box<OfdDocBodyXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OfdDocBodyXElementTypeDeserializerState {
            Init__,
            DocInfo(Option<<super::CtDocInfoXType as WithDeserializer>::Deserializer>),
            DocRoot(Option<<String as WithDeserializer>::Deserializer>),
            Versions(
                Option<<super::OfdDocBodyVersionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Signatures(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl OfdDocBodyXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    doc_info: None,
                    doc_root: None,
                    versions: None,
                    signatures: None,
                    state__: Box::new(OfdDocBodyXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: OfdDocBodyXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                match state {
                    S::DocInfo(Some(deserializer)) => {
                        self.store_doc_info(deserializer.finish(helper)?)?
                    }
                    S::DocRoot(Some(deserializer)) => {
                        self.store_doc_root(deserializer.finish(helper)?)?
                    }
                    S::Versions(Some(deserializer)) => {
                        self.store_versions(deserializer.finish(helper)?)?
                    }
                    S::Signatures(Some(deserializer)) => {
                        self.store_signatures(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_doc_info(&mut self, value: super::CtDocInfoXType) -> Result<(), Error> {
                if self.doc_info.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DocInfo",
                    )))?;
                }
                self.doc_info = Some(value);
                Ok(())
            }
            fn store_doc_root(&mut self, value: String) -> Result<(), Error> {
                if self.doc_root.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DocRoot",
                    )))?;
                }
                self.doc_root = Some(value);
                Ok(())
            }
            fn store_versions(
                &mut self,
                value: super::OfdDocBodyVersionsXElementType,
            ) -> Result<(), Error> {
                if self.versions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Versions",
                    )))?;
                }
                self.versions = Some(value);
                Ok(())
            }
            fn store_signatures(&mut self, value: String) -> Result<(), Error> {
                if self.signatures.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Signatures",
                    )))?;
                }
                self.signatures = Some(value);
                Ok(())
            }
            fn handle_doc_info<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtDocInfoXType>,
                fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocInfo(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_info(data)?;
                        *self.state__ = S::DocRoot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocInfo(Some(deserializer)));
                        *self.state__ = S::DocRoot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_doc_root<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocRoot(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_root(data)?;
                        *self.state__ = S::Versions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocRoot(Some(deserializer)));
                        *self.state__ = S::Versions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_versions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::OfdDocBodyVersionsXElementType>,
                fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Versions(None));
                    *self.state__ = S::Signatures(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_versions(data)?;
                        *self.state__ = S::Signatures(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Versions(Some(deserializer)));
                        *self.state__ = S::Signatures(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_signatures<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<OfdDocBodyXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Signatures(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_signatures(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Signatures(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::OfdDocBodyXElementType> for OfdDocBodyXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyXElementType> {
                use OfdDocBodyXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::DocInfo(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_info(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocRoot(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_root(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Versions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_versions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signatures(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_signatures(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::DocInfo(None);
                            event
                        }
                        (S::DocInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocInfo",
                                false,
                            )?;
                            match self.handle_doc_info(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocRoot",
                                false,
                            )?;
                            match self.handle_doc_root(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Versions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Versions",
                                false,
                            )?;
                            match self.handle_versions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signatures(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Signatures",
                                false,
                            )?;
                            match self.handle_signatures(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::OfdDocBodyXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    OfdDocBodyXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::OfdDocBodyXElementType {
                    doc_info: helper.finish_element("DocInfo", self.doc_info)?,
                    doc_root: helper.finish_element("DocRoot", self.doc_root)?,
                    versions: self.versions,
                    signatures: self.signatures,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoCustomDatasCustomDataXElementTypeDeserializer {
            name: String,
            content: Option<String>,
            state__: Box<CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtDocInfoCustomDatasCustomDataXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut name: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    name: name.ok_or_else(|| ErrorKind::MissingAttribute("Name".into()))?,
                    content: None,
                    state__: Box::new(
                        CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Content__(
                    deserializer,
                ) = state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
            {
                use CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(helper)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
            for CtDocInfoCustomDatasCustomDataXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
            {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(helper, x)?.next(helper, event)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDocInfoCustomDatasCustomDataXElementType>
            {
                use CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState as S;
                match replace(&mut *self.state__, S::Unknown__) {
                    S::Unknown__ => unreachable!(),
                    S::Init__ => {
                        let output = ContentDeserializer::init(helper, event)?;
                        self.handle_content(helper, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(helper, event)?;
                        self.handle_content(helper, output)
                    }
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDocInfoCustomDatasCustomDataXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtDocInfoCustomDatasCustomDataXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtDocInfoCustomDatasCustomDataXElementType {
                    name: self.name,
                    content: helper.finish_content(self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyVersionsXElementTypeDeserializer {
            version: Vec<super::OfdDocBodyVersionsVersionXElementType>,
            state__: Box<OfdDocBodyVersionsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OfdDocBodyVersionsXElementTypeDeserializerState {
            Init__ , Version (Option << super :: OfdDocBodyVersionsVersionXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl OfdDocBodyVersionsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    version: Vec::new(),
                    state__: Box::new(OfdDocBodyVersionsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: OfdDocBodyVersionsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use OfdDocBodyVersionsXElementTypeDeserializerState as S;
                match state {
                    S::Version(Some(deserializer)) => {
                        self.store_version(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_version(
                &mut self,
                value: super::OfdDocBodyVersionsVersionXElementType,
            ) -> Result<(), Error> {
                self.version.push(value);
                Ok(())
            }
            fn handle_version<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::OfdDocBodyVersionsVersionXElementType>,
                fallback: &mut Option<OfdDocBodyVersionsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use OfdDocBodyVersionsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.version.len() < 1usize {
                        fallback.get_or_insert(S::Version(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Version(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_version(data)?;
                        *self.state__ = S::Version(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Version(Some(deserializer)));
                        *self.state__ = S::Version(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::OfdDocBodyVersionsXElementType>
            for OfdDocBodyVersionsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyVersionsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyVersionsXElementType> {
                use OfdDocBodyVersionsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Version(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_version(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Version(None);
                            event
                        }
                        (S::Version(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Version",
                                false,
                            )?;
                            match self.handle_version(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::OfdDocBodyVersionsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    OfdDocBodyVersionsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::OfdDocBodyVersionsXElementType {
                    version: helper.finish_vec(1usize, None, self.version)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyVersionsVersionXElementTypeDeserializer {
            id: String,
            index: i32,
            current: bool,
            base_loc: String,
            state__: Box<OfdDocBodyVersionsVersionXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum OfdDocBodyVersionsVersionXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl OfdDocBodyVersionsVersionXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut index: Option<i32> = None;
                let mut current: Option<bool> = None;
                let mut base_loc: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Index")
                    ) {
                        helper.read_attrib(&mut index, b"Index", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Current")
                    ) {
                        helper.read_attrib(&mut current, b"Current", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BaseLoc")
                    ) {
                        helper.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    index: index.ok_or_else(|| ErrorKind::MissingAttribute("Index".into()))?,
                    current: current.unwrap_or_else(
                        super::OfdDocBodyVersionsVersionXElementType::default_current,
                    ),
                    base_loc: base_loc
                        .ok_or_else(|| ErrorKind::MissingAttribute("BaseLoc".into()))?,
                    state__: Box::new(
                        OfdDocBodyVersionsVersionXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: OfdDocBodyVersionsVersionXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::OfdDocBodyVersionsVersionXElementType>
            for OfdDocBodyVersionsVersionXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyVersionsVersionXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::OfdDocBodyVersionsVersionXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::OfdDocBodyVersionsVersionXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    OfdDocBodyVersionsVersionXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::OfdDocBodyVersionsVersionXElementType {
                    id: self.id,
                    index: self.index,
                    current: self.current,
                    base_loc: self.base_loc,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct CtDocInfoXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDocInfoXType,
            pub(super) state: Box<CtDocInfoXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDocInfoXTypeSerializerState<'ser> {
            Init__,
            DocId(<String as WithSerializer>::Serializer<'ser>),
            Title(IterSerializer<'ser, Option<&'ser String>, String>),
            Author(IterSerializer<'ser, Option<&'ser String>, String>),
            Subject(IterSerializer<'ser, Option<&'ser String>, String>),
            Abstract(IterSerializer<'ser, Option<&'ser String>, String>),
            CreationDate(IterSerializer<'ser, Option<&'ser String>, String>),
            ModDate(IterSerializer<'ser, Option<&'ser String>, String>),
            DocUsage(IterSerializer<'ser, Option<&'ser String>, String>),
            Cover(IterSerializer<'ser, Option<&'ser String>, String>),
            Keywords(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtDocInfoKeywordsXElementType>,
                    super::CtDocInfoKeywordsXElementType,
                >,
            ),
            Creator(IterSerializer<'ser, Option<&'ser String>, String>),
            CreatorVersion(IterSerializer<'ser, Option<&'ser String>, String>),
            CustomDatas(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtDocInfoCustomDatasXElementType>,
                    super::CtDocInfoCustomDatasXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDocInfoXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtDocInfoXTypeSerializerState::Init__ => {
                            *self.state =
                                CtDocInfoXTypeSerializerState::DocId(WithSerializer::serializer(
                                    &self.value.doc_id,
                                    Some("DocID"),
                                    false,
                                )?);
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtDocInfoXTypeSerializerState::DocId(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::Title(IterSerializer::new(
                                            self.value.title.as_ref(),
                                            Some("Title"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Title(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::Author(IterSerializer::new(
                                            self.value.author.as_ref(),
                                            Some("Author"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Author(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::Subject(IterSerializer::new(
                                            self.value.subject.as_ref(),
                                            Some("Subject"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Subject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::Abstract(
                                        IterSerializer::new(
                                            self.value.abstract_.as_ref(),
                                            Some("Abstract"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Abstract(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::CreationDate(
                                        IterSerializer::new(
                                            self.value.creation_date.as_ref(),
                                            Some("CreationDate"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::CreationDate(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::ModDate(IterSerializer::new(
                                            self.value.mod_date.as_ref(),
                                            Some("ModDate"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::ModDate(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::DocUsage(
                                        IterSerializer::new(
                                            self.value.doc_usage.as_ref(),
                                            Some("DocUsage"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::DocUsage(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::Cover(IterSerializer::new(
                                            self.value.cover.as_ref(),
                                            Some("Cover"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Cover(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::Keywords(
                                        IterSerializer::new(
                                            self.value.keywords.as_ref(),
                                            Some("Keywords"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Keywords(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoXTypeSerializerState::Creator(IterSerializer::new(
                                            self.value.creator.as_ref(),
                                            Some("Creator"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::Creator(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::CreatorVersion(
                                        IterSerializer::new(
                                            self.value.creator_version.as_ref(),
                                            Some("CreatorVersion"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::CreatorVersion(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDocInfoXTypeSerializerState::CustomDatas(
                                        IterSerializer::new(
                                            self.value.custom_datas.as_ref(),
                                            Some("CustomDatas"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDocInfoXTypeSerializerState::CustomDatas(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtDocInfoXTypeSerializerState::End__,
                            }
                        }
                        CtDocInfoXTypeSerializerState::End__ => {
                            *self.state = CtDocInfoXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtDocInfoXTypeSerializerState::Done__ => return Ok(None),
                        CtDocInfoXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDocInfoXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtDocInfoXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OfdXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::OfdXElementType,
            pub(super) state: Box<OfdXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OfdXElementTypeSerializerState<'ser> {
            Init__,
            DocBody(
                IterSerializer<
                    'ser,
                    &'ser [super::OfdDocBodyXElementType],
                    super::OfdDocBodyXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OfdXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OfdXElementTypeSerializerState::Init__ => {
                            *self.state =
                                OfdXElementTypeSerializerState::DocBody(IterSerializer::new(
                                    &self.value.doc_body[..],
                                    Some("DocBody"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Version", &self.value.version)?;
                            helper.write_attrib(&mut bytes, "DocType", &self.value.doc_type)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        OfdXElementTypeSerializerState::DocBody(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = OfdXElementTypeSerializerState::End__,
                            }
                        }
                        OfdXElementTypeSerializerState::End__ => {
                            *self.state = OfdXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        OfdXElementTypeSerializerState::Done__ => return Ok(None),
                        OfdXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for OfdXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OfdXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoKeywordsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDocInfoKeywordsXElementType,
            pub(super) state: Box<CtDocInfoKeywordsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDocInfoKeywordsXElementTypeSerializerState<'ser> {
            Init__,
            Keyword(IterSerializer<'ser, &'ser [String], String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDocInfoKeywordsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtDocInfoKeywordsXElementTypeSerializerState::Init__ => {
                            *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Keyword(
                                IterSerializer::new(
                                    &self.value.keyword[..],
                                    Some("Keyword"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtDocInfoKeywordsXElementTypeSerializerState::Keyword(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoKeywordsXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtDocInfoKeywordsXElementTypeSerializerState::End__ => {
                            *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtDocInfoKeywordsXElementTypeSerializerState::Done__ => return Ok(None),
                        CtDocInfoKeywordsXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDocInfoKeywordsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtDocInfoKeywordsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDocInfoCustomDatasXElementType,
            pub(super) state: Box<CtDocInfoCustomDatasXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDocInfoCustomDatasXElementTypeSerializerState<'ser> {
            Init__,
            CustomData(
                IterSerializer<
                    'ser,
                    &'ser [super::CtDocInfoCustomDatasCustomDataXElementType],
                    super::CtDocInfoCustomDatasCustomDataXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtDocInfoCustomDatasXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtDocInfoCustomDatasXElementTypeSerializerState::CustomData(
                                    IterSerializer::new(
                                        &self.value.custom_data[..],
                                        Some("CustomData"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtDocInfoCustomDatasXElementTypeSerializerState::CustomData(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtDocInfoCustomDatasXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtDocInfoCustomDatasXElementTypeSerializerState::End__ => {
                            *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtDocInfoCustomDatasXElementTypeSerializerState::Done__ => return Ok(None),
                        CtDocInfoCustomDatasXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDocInfoCustomDatasXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtDocInfoCustomDatasXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::OfdDocBodyXElementType,
            pub(super) state: Box<OfdDocBodyXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OfdDocBodyXElementTypeSerializerState<'ser> {
            Init__,
            DocInfo(<super::CtDocInfoXType as WithSerializer>::Serializer<'ser>),
            DocRoot(<String as WithSerializer>::Serializer<'ser>),
            Versions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::OfdDocBodyVersionsXElementType>,
                    super::OfdDocBodyVersionsXElementType,
                >,
            ),
            Signatures(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OfdDocBodyXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OfdDocBodyXElementTypeSerializerState::Init__ => {
                            *self.state = OfdDocBodyXElementTypeSerializerState::DocInfo(
                                WithSerializer::serializer(
                                    &self.value.doc_info,
                                    Some("DocInfo"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        OfdDocBodyXElementTypeSerializerState::DocInfo(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = OfdDocBodyXElementTypeSerializerState::DocRoot(
                                        WithSerializer::serializer(
                                            &self.value.doc_root,
                                            Some("DocRoot"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        OfdDocBodyXElementTypeSerializerState::DocRoot(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = OfdDocBodyXElementTypeSerializerState::Versions(
                                        IterSerializer::new(
                                            self.value.versions.as_ref(),
                                            Some("Versions"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        OfdDocBodyXElementTypeSerializerState::Versions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = OfdDocBodyXElementTypeSerializerState::Signatures(
                                        IterSerializer::new(
                                            self.value.signatures.as_ref(),
                                            Some("Signatures"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        OfdDocBodyXElementTypeSerializerState::Signatures(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = OfdDocBodyXElementTypeSerializerState::End__,
                            }
                        }
                        OfdDocBodyXElementTypeSerializerState::End__ => {
                            *self.state = OfdDocBodyXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        OfdDocBodyXElementTypeSerializerState::Done__ => return Ok(None),
                        OfdDocBodyXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for OfdDocBodyXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OfdDocBodyXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDocInfoCustomDatasCustomDataXElementType,
            pub(super) state: Box<CtDocInfoCustomDatasCustomDataXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDocInfoCustomDatasCustomDataXElementTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Init__ => { * self . state = CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Content__ (WithSerializer :: serializer (& self . value . content , None , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; helper . begin_ns_scope () ; helper . write_xmlns (& mut bytes , None , & super :: super :: NS_UNNAMED_2) ; helper . write_attrib (& mut bytes , "Name" , & self . value . name) ? ; return Ok (Some (Event :: Start (bytes))) } CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Content__ (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: End__ , } CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: End__ => { * self . state = CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Done__ ; helper . end_ns_scope () ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Done__ => return Ok (None) , CtDocInfoCustomDatasCustomDataXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDocInfoCustomDatasCustomDataXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            CtDocInfoCustomDatasCustomDataXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyVersionsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::OfdDocBodyVersionsXElementType,
            pub(super) state: Box<OfdDocBodyVersionsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OfdDocBodyVersionsXElementTypeSerializerState<'ser> {
            Init__,
            Version(
                IterSerializer<
                    'ser,
                    &'ser [super::OfdDocBodyVersionsVersionXElementType],
                    super::OfdDocBodyVersionsVersionXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OfdDocBodyVersionsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OfdDocBodyVersionsXElementTypeSerializerState::Init__ => {
                            *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Version(
                                IterSerializer::new(
                                    &self.value.version[..],
                                    Some("Version"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        OfdDocBodyVersionsXElementTypeSerializerState::Version(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        OfdDocBodyVersionsXElementTypeSerializerState::End__
                                }
                            }
                        }
                        OfdDocBodyVersionsXElementTypeSerializerState::End__ => {
                            *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        OfdDocBodyVersionsXElementTypeSerializerState::Done__ => return Ok(None),
                        OfdDocBodyVersionsXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for OfdDocBodyVersionsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OfdDocBodyVersionsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::OfdDocBodyVersionsVersionXElementType,
            pub(super) state: Box<OfdDocBodyVersionsVersionXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum OfdDocBodyVersionsVersionXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        OfdDocBodyVersionsVersionXElementTypeSerializerState::Init__ => {
                            *self.state =
                                OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "Index", &self.value.index)?;
                            helper.write_attrib(&mut bytes, "Current", &self.value.current)?;
                            helper.write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        OfdDocBodyVersionsVersionXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for OfdDocBodyVersionsVersionXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = OfdDocBodyVersionsVersionXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod page {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    #[derive(Debug)]
    pub struct CtAxialShdXType {
        pub map_type: CtAxialShdMapTypeXType,
        pub map_unit: Option<f64>,
        pub extend: CtAxialShdExtendXType,
        pub start_point: String,
        pub end_point: String,
        pub segment: Vec<CtAxialShdSegmentXElementType>,
    }
    impl CtAxialShdXType {
        #[must_use]
        pub fn default_map_type() -> CtAxialShdMapTypeXType {
            CtAxialShdMapTypeXType::Direct
        }
        #[must_use]
        pub fn default_extend() -> CtAxialShdExtendXType {
            CtAxialShdExtendXType::_0
        }
    }
    impl WithSerializer for CtAxialShdXType {
        type Serializer<'x> = quick_xml_serialize::CtAxialShdXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtAxialShdXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtAxialShdXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_AxialShd"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtAxialShdXType {
        type Deserializer = quick_xml_deserialize::CtAxialShdXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtCgTransformXType {
        pub code_position: i32,
        pub code_count: i32,
        pub glyph_count: i32,
        pub glyphs: Option<String>,
    }
    impl CtCgTransformXType {
        #[must_use]
        pub fn default_code_count() -> i32 {
            1i32
        }
        #[must_use]
        pub fn default_glyph_count() -> i32 {
            1i32
        }
    }
    impl WithSerializer for CtCgTransformXType {
        type Serializer<'x> = quick_xml_serialize::CtCgTransformXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtCgTransformXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtCgTransformXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_CGTransform"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtCgTransformXType {
        type Deserializer = quick_xml_deserialize::CtCgTransformXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtClipXType {
        pub area: Vec<CtClipAreaXElementType>,
    }
    impl WithSerializer for CtClipXType {
        type Serializer<'x> = quick_xml_serialize::CtClipXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtClipXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtClipXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Clip"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtClipXType {
        type Deserializer = quick_xml_deserialize::CtClipXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtColorXType {
        pub value: Option<String>,
        pub index: Option<i32>,
        pub color_space: Option<u32>,
        pub alpha: i32,
        pub content: Option<CtColorXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtColorXTypeContent {
        Pattern(CtPatternXType),
        AxialShd(CtAxialShdXType),
        RadialShd(CtRadialShdXType),
        GouraudShd(CtGouraudShdXType),
        LaGourandShd(CtLaGouraudShdXType),
    }
    impl CtColorXType {
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtColorXType {
        type Serializer<'x> = quick_xml_serialize::CtColorXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtColorXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtColorXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Color"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtColorXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtColorXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtColorXTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtColorXTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for CtColorXType {
        type Deserializer = quick_xml_deserialize::CtColorXTypeDeserializer;
    }
    impl WithDeserializer for CtColorXTypeContent {
        type Deserializer = quick_xml_deserialize::CtColorXTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtCompositeXType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub resource_id: u32,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
    }
    impl CtCompositeXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtCompositeXType {
        type Serializer<'x> = quick_xml_serialize::CtCompositeXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtCompositeXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtCompositeXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Composite"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtCompositeXType {
        type Deserializer = quick_xml_deserialize::CtCompositeXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtGouraudShdXType {
        pub extend: Option<i32>,
        pub point: Vec<CtGouraudShdPointXElementType>,
        pub back_color: Option<Box<CtColorXType>>,
    }
    impl WithSerializer for CtGouraudShdXType {
        type Serializer<'x> = quick_xml_serialize::CtGouraudShdXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtGouraudShdXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtGouraudShdXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_GouraudShd"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtGouraudShdXType {
        type Deserializer = quick_xml_deserialize::CtGouraudShdXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitXType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
    }
    impl CtGraphicUnitXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtGraphicUnitXType {
        type Serializer<'x> = quick_xml_serialize::CtGraphicUnitXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtGraphicUnitXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtGraphicUnitXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_GraphicUnit"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtGraphicUnitXType {
        type Deserializer = quick_xml_deserialize::CtGraphicUnitXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtImageXType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub resource_id: u32,
        pub substitution: Option<u32>,
        pub image_mask: Option<u32>,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
        pub border: Option<CtImageBorderXElementType>,
    }
    impl CtImageXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtImageXType {
        type Serializer<'x> = quick_xml_serialize::CtImageXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtImageXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtImageXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Image"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtImageXType {
        type Deserializer = quick_xml_deserialize::CtImageXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdXType {
        pub vertices_per_row: i32,
        pub extend: Option<i32>,
        pub point: Vec<CtLaGouraudShdPointXElementType>,
        pub back_color: Option<Box<CtColorXType>>,
    }
    impl WithSerializer for CtLaGouraudShdXType {
        type Serializer<'x> = quick_xml_serialize::CtLaGouraudShdXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtLaGouraudShdXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtLaGouraudShdXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_LaGouraudShd"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtLaGouraudShdXType {
        type Deserializer = quick_xml_deserialize::CtLaGouraudShdXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtLayerXType {
        pub type_: CtLayerTypeXType,
        pub draw_param: Option<u32>,
        pub content: Vec<CtLayerXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtLayerXTypeContent {
        TextObject(CtPageBlockTextObjectXElementType),
        PathObject(CtPageBlockPathObjectXElementType),
        ImageObject(CtPageBlockImageObjectXElementType),
        CompositeObject(CtPageBlockCompositeObjectXElementType),
        PageBlock(CtPageBlockPageBlockXElementType),
    }
    impl CtLayerXType {
        #[must_use]
        pub fn default_type_() -> CtLayerTypeXType {
            CtLayerTypeXType::Body
        }
    }
    impl WithSerializer for CtLayerXType {
        type Serializer<'x> = quick_xml_serialize::CtLayerXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtLayerXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtLayerXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Layer"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtLayerXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtLayerXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtLayerXTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtLayerXTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for CtLayerXType {
        type Deserializer = quick_xml_deserialize::CtLayerXTypeDeserializer;
    }
    impl WithDeserializer for CtLayerXTypeContent {
        type Deserializer = quick_xml_deserialize::CtLayerXTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageBlockXType {
        pub content: Vec<CtPageBlockXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockXTypeContent {
        TextObject(CtPageBlockTextObjectXElementType),
        PathObject(CtPageBlockPathObjectXElementType),
        ImageObject(CtPageBlockImageObjectXElementType),
        CompositeObject(CtPageBlockCompositeObjectXElementType),
        PageBlock(CtPageBlockPageBlockXElementType),
    }
    impl WithSerializer for CtPageBlockXType {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtPageBlockXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtPageBlockXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_PageBlock"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtPageBlockXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtPageBlockXTypeContentSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtPageBlockXTypeContentSerializerState::Init__,
                ),
            })
        }
    }
    impl WithDeserializer for CtPageBlockXType {
        type Deserializer = quick_xml_deserialize::CtPageBlockXTypeDeserializer;
    }
    impl WithDeserializer for CtPageBlockXTypeContent {
        type Deserializer = quick_xml_deserialize::CtPageBlockXTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPathXType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub stroke: bool,
        pub fill: bool,
        pub rule: CtPathRuleXType,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
        pub stroke_color: Option<CtColorXType>,
        pub fill_color: Option<CtColorXType>,
        pub abbreviated_data: String,
    }
    impl CtPathXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
        #[must_use]
        pub fn default_stroke() -> bool {
            true
        }
        #[must_use]
        pub fn default_fill() -> bool {
            false
        }
        #[must_use]
        pub fn default_rule() -> CtPathRuleXType {
            CtPathRuleXType::NonZero
        }
    }
    impl WithSerializer for CtPathXType {
        type Serializer<'x> = quick_xml_serialize::CtPathXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtPathXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtPathXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Path"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtPathXType {
        type Deserializer = quick_xml_deserialize::CtPathXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPatternXType {
        pub width: f64,
        pub height: f64,
        pub x_step: Option<f64>,
        pub y_step: Option<f64>,
        pub reflect_method: CtPatternReflectMethodXType,
        pub relative_to: CtPatternRelativeToXType,
        pub ctm: Option<String>,
        pub cell_content: CtPatternCellContentXElementType,
    }
    impl CtPatternXType {
        #[must_use]
        pub fn default_reflect_method() -> CtPatternReflectMethodXType {
            CtPatternReflectMethodXType::Normal
        }
        #[must_use]
        pub fn default_relative_to() -> CtPatternRelativeToXType {
            CtPatternRelativeToXType::Object
        }
    }
    impl WithSerializer for CtPatternXType {
        type Serializer<'x> = quick_xml_serialize::CtPatternXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtPatternXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtPatternXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Pattern"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtPatternXType {
        type Deserializer = quick_xml_deserialize::CtPatternXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtRadialShdXType {
        pub map_type: CtAxialShdMapTypeXType,
        pub map_unit: Option<f64>,
        pub eccentricity: f64,
        pub angle: f64,
        pub start_point: String,
        pub start_radius: f64,
        pub end_point: String,
        pub end_radius: f64,
        pub extend: i32,
        pub seqment: Vec<CtAxialShdSegmentXElementType>,
    }
    impl CtRadialShdXType {
        #[must_use]
        pub fn default_map_type() -> CtAxialShdMapTypeXType {
            CtAxialShdMapTypeXType::Direct
        }
        #[must_use]
        pub fn default_eccentricity() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_angle() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_start_radius() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_extend() -> i32 {
            0i32
        }
    }
    impl WithSerializer for CtRadialShdXType {
        type Serializer<'x> = quick_xml_serialize::CtRadialShdXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtRadialShdXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtRadialShdXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_RadialShd"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtRadialShdXType {
        type Deserializer = quick_xml_deserialize::CtRadialShdXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtTextXType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub font: u32,
        pub size: f64,
        pub stroke: bool,
        pub fill: bool,
        pub h_scale: f64,
        pub read_direction: i32,
        pub char_direction: i32,
        pub weight: CtTextWeightXType,
        pub italic: bool,
        pub content: Vec<CtTextXTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtTextXTypeContent {
        Actions(CtGraphicUnitActionsXElementType),
        Clips(CtGraphicUnitClipsXElementType),
        FillColor(CtColorXType),
        StrokeColor(CtColorXType),
        CgTransform(CtCgTransformXType),
        TextCode(CtTextTextCodeXElementType),
    }
    impl CtTextXType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
        #[must_use]
        pub fn default_stroke() -> bool {
            false
        }
        #[must_use]
        pub fn default_fill() -> bool {
            true
        }
        #[must_use]
        pub fn default_h_scale() -> f64 {
            1f64
        }
        #[must_use]
        pub fn default_read_direction() -> i32 {
            0i32
        }
        #[must_use]
        pub fn default_char_direction() -> i32 {
            0i32
        }
        #[must_use]
        pub fn default_weight() -> CtTextWeightXType {
            CtTextWeightXType::_400
        }
        #[must_use]
        pub fn default_italic() -> bool {
            false
        }
    }
    impl WithSerializer for CtTextXType {
        type Serializer<'x> = quick_xml_serialize::CtTextXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtTextXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtTextXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Text"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtTextXTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtTextXTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::CtTextXTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtTextXTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for CtTextXType {
        type Deserializer = quick_xml_deserialize::CtTextXTypeDeserializer;
    }
    impl WithDeserializer for CtTextXTypeContent {
        type Deserializer = quick_xml_deserialize::CtTextXTypeContentDeserializer;
    }
    pub type Page = PageXElementType;
    #[derive(Debug)]
    pub struct PageXElementType {
        pub template: Vec<PageTemplateXElementType>,
        pub page_res: Vec<String>,
        pub area: Option<super::definition::CtPageAreaXType>,
        pub content: Option<PageContentXElementType>,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
    }
    impl WithSerializer for PageXElementType {
        type Serializer<'x> = quick_xml_serialize::PageXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PageXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::PageXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Page"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PageXElementType {
        type Deserializer = quick_xml_deserialize::PageXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtAxialShdMapTypeXType {
        Direct,
        Repeat,
        Reflect,
    }
    impl SerializeBytes for CtAxialShdMapTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Direct => Ok(Some(Cow::Borrowed("Direct"))),
                Self::Repeat => Ok(Some(Cow::Borrowed("Repeat"))),
                Self::Reflect => Ok(Some(Cow::Borrowed("Reflect"))),
            }
        }
    }
    impl DeserializeBytes for CtAxialShdMapTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Direct" => Ok(Self::Direct),
                b"Repeat" => Ok(Self::Repeat),
                b"Reflect" => Ok(Self::Reflect),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtAxialShdExtendXType {
        _0,
        _1,
        _2,
        _3,
    }
    impl SerializeBytes for CtAxialShdExtendXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::_0 => Ok(Some(Cow::Borrowed("0"))),
                Self::_1 => Ok(Some(Cow::Borrowed("1"))),
                Self::_2 => Ok(Some(Cow::Borrowed("2"))),
                Self::_3 => Ok(Some(Cow::Borrowed("3"))),
            }
        }
    }
    impl DeserializeBytes for CtAxialShdExtendXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"0" => Ok(Self::_0),
                b"1" => Ok(Self::_1),
                b"2" => Ok(Self::_2),
                b"3" => Ok(Self::_3),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtAxialShdSegmentXElementType {
        pub position: Option<f64>,
        pub color: Box<CtColorXType>,
    }
    impl WithSerializer for CtAxialShdSegmentXElementType {
        type Serializer<'x> = quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtAxialShdSegmentXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtAxialShdSegment"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtAxialShdSegmentXElementType {
        type Deserializer = quick_xml_deserialize::CtAxialShdSegmentXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtClipAreaXElementType {
        pub draw_param: Option<u32>,
        pub ctm: Option<String>,
        pub content: CtClipAreaXElementTypeContent,
    }
    #[derive(Debug)]
    pub enum CtClipAreaXElementTypeContent {
        Path(CtPathXType),
        Text(CtTextXType),
    }
    impl WithSerializer for CtClipAreaXElementType {
        type Serializer<'x> = quick_xml_serialize::CtClipAreaXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtClipAreaXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtClipAreaXElementTypeSerializerState::Init__),
                name: name.unwrap_or("CtClipArea"),
                is_root,
            })
        }
    }
    impl WithSerializer for CtClipAreaXElementTypeContent {
        type Serializer<'x> = quick_xml_serialize::CtClipAreaXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(
                quick_xml_serialize::CtClipAreaXElementTypeContentSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtClipAreaXElementTypeContentSerializerState::Init__,
                    ),
                },
            )
        }
    }
    impl WithDeserializer for CtClipAreaXElementType {
        type Deserializer = quick_xml_deserialize::CtClipAreaXElementTypeDeserializer;
    }
    impl WithDeserializer for CtClipAreaXElementTypeContent {
        type Deserializer = quick_xml_deserialize::CtClipAreaXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub enum CtGraphicUnitCapXType {
        Butt,
        Round,
        Square,
    }
    impl SerializeBytes for CtGraphicUnitCapXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Butt => Ok(Some(Cow::Borrowed("Butt"))),
                Self::Round => Ok(Some(Cow::Borrowed("Round"))),
                Self::Square => Ok(Some(Cow::Borrowed("Square"))),
            }
        }
    }
    impl DeserializeBytes for CtGraphicUnitCapXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Butt" => Ok(Self::Butt),
                b"Round" => Ok(Self::Round),
                b"Square" => Ok(Self::Square),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtGraphicUnitJoinXType {
        Miter,
        Round,
        Bevel,
    }
    impl SerializeBytes for CtGraphicUnitJoinXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Miter => Ok(Some(Cow::Borrowed("Miter"))),
                Self::Round => Ok(Some(Cow::Borrowed("Round"))),
                Self::Bevel => Ok(Some(Cow::Borrowed("Bevel"))),
            }
        }
    }
    impl DeserializeBytes for CtGraphicUnitJoinXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Miter" => Ok(Self::Miter),
                b"Round" => Ok(Self::Round),
                b"Bevel" => Ok(Self::Bevel),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitActionsXElementType {
        pub action: Vec<super::definition::CtActionXType>,
    }
    impl WithSerializer for CtGraphicUnitActionsXElementType {
        type Serializer<'x> = quick_xml_serialize::CtGraphicUnitActionsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtGraphicUnitActionsXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtGraphicUnitActionsXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtGraphicUnitActions") , is_root , })
        }
    }
    impl WithDeserializer for CtGraphicUnitActionsXElementType {
        type Deserializer = quick_xml_deserialize::CtGraphicUnitActionsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtGraphicUnitClipsXElementType {
        pub clip: Vec<CtClipXType>,
    }
    impl WithSerializer for CtGraphicUnitClipsXElementType {
        type Serializer<'x> = quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtGraphicUnitClipsXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtGraphicUnitClips"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtGraphicUnitClipsXElementType {
        type Deserializer = quick_xml_deserialize::CtGraphicUnitClipsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtGouraudShdPointXElementType {
        pub x: f64,
        pub y: f64,
        pub edge_flag: Option<CtGouraudShdPointEdgeFlagXType>,
        pub color: Box<CtColorXType>,
    }
    impl WithSerializer for CtGouraudShdPointXElementType {
        type Serializer<'x> = quick_xml_serialize::CtGouraudShdPointXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtGouraudShdPointXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtGouraudShdPointXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtGouraudShdPoint"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtGouraudShdPointXElementType {
        type Deserializer = quick_xml_deserialize::CtGouraudShdPointXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtImageBorderXElementType {
        pub line_width: f64,
        pub horizonal_corner_radius: f64,
        pub vertical_corner_radius: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub border_color: Option<CtColorXType>,
    }
    impl CtImageBorderXElementType {
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_horizonal_corner_radius() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_vertical_corner_radius() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
    }
    impl WithSerializer for CtImageBorderXElementType {
        type Serializer<'x> = quick_xml_serialize::CtImageBorderXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtImageBorderXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtImageBorderXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtImageBorder"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtImageBorderXElementType {
        type Deserializer = quick_xml_deserialize::CtImageBorderXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtLaGouraudShdPointXElementType {
        pub x: Option<f64>,
        pub y: Option<f64>,
        pub color: Box<CtColorXType>,
    }
    impl WithSerializer for CtLaGouraudShdPointXElementType {
        type Serializer<'x> = quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtLaGouraudShdPointXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtLaGouraudShdPoint"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtLaGouraudShdPointXElementType {
        type Deserializer = quick_xml_deserialize::CtLaGouraudShdPointXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtLayerTypeXType {
        Body,
        Background,
        Foreground,
        Custom,
    }
    impl SerializeBytes for CtLayerTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Body => Ok(Some(Cow::Borrowed("Body"))),
                Self::Background => Ok(Some(Cow::Borrowed("Background"))),
                Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
                Self::Custom => Ok(Some(Cow::Borrowed("Custom"))),
            }
        }
    }
    impl DeserializeBytes for CtLayerTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Body" => Ok(Self::Body),
                b"Background" => Ok(Self::Background),
                b"Foreground" => Ok(Self::Foreground),
                b"Custom" => Ok(Self::Custom),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPageBlockTextObjectXElementType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub font: u32,
        pub size: f64,
        pub stroke: bool,
        pub fill: bool,
        pub h_scale: f64,
        pub read_direction: i32,
        pub char_direction: i32,
        pub weight: CtTextWeightXType,
        pub italic: bool,
        pub id: u32,
        pub content: Vec<CtPageBlockTextObjectXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockTextObjectXElementTypeContent {
        Actions(CtGraphicUnitActionsXElementType),
        Clips(CtGraphicUnitClipsXElementType),
        FillColor(CtColorXType),
        StrokeColor(CtColorXType),
        CgTransform(CtCgTransformXType),
        TextCode(CtTextTextCodeXElementType),
    }
    impl CtPageBlockTextObjectXElementType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
        #[must_use]
        pub fn default_stroke() -> bool {
            false
        }
        #[must_use]
        pub fn default_fill() -> bool {
            true
        }
        #[must_use]
        pub fn default_h_scale() -> f64 {
            1f64
        }
        #[must_use]
        pub fn default_read_direction() -> i32 {
            0i32
        }
        #[must_use]
        pub fn default_char_direction() -> i32 {
            0i32
        }
        #[must_use]
        pub fn default_weight() -> CtTextWeightXType {
            CtTextWeightXType::_400
        }
        #[must_use]
        pub fn default_italic() -> bool {
            false
        }
    }
    impl WithSerializer for CtPageBlockTextObjectXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockTextObjectXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockTextObject") , is_root , })
        }
    }
    impl WithSerializer for CtPageBlockTextObjectXElementTypeContent {
        type Serializer<'x> =
            quick_xml_serialize::CtPageBlockTextObjectXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockTextObjectXElementTypeContentSerializerState :: Init__) , })
        }
    }
    impl WithDeserializer for CtPageBlockTextObjectXElementType {
        type Deserializer = quick_xml_deserialize::CtPageBlockTextObjectXElementTypeDeserializer;
    }
    impl WithDeserializer for CtPageBlockTextObjectXElementTypeContent {
        type Deserializer =
            quick_xml_deserialize::CtPageBlockTextObjectXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageBlockPathObjectXElementType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub stroke: bool,
        pub fill: bool,
        pub rule: CtPathRuleXType,
        pub id: u32,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
        pub stroke_color: Option<CtColorXType>,
        pub fill_color: Option<CtColorXType>,
        pub abbreviated_data: String,
    }
    impl CtPageBlockPathObjectXElementType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
        #[must_use]
        pub fn default_stroke() -> bool {
            true
        }
        #[must_use]
        pub fn default_fill() -> bool {
            false
        }
        #[must_use]
        pub fn default_rule() -> CtPathRuleXType {
            CtPathRuleXType::NonZero
        }
    }
    impl WithSerializer for CtPageBlockPathObjectXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockPathObjectXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPageBlockPathObjectXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockPathObjectXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockPathObject") , is_root , })
        }
    }
    impl WithDeserializer for CtPageBlockPathObjectXElementType {
        type Deserializer = quick_xml_deserialize::CtPageBlockPathObjectXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageBlockImageObjectXElementType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub resource_id: u32,
        pub substitution: Option<u32>,
        pub image_mask: Option<u32>,
        pub id: u32,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
        pub border: Option<CtImageBorderXElementType>,
    }
    impl CtPageBlockImageObjectXElementType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtPageBlockImageObjectXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockImageObjectXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPageBlockImageObjectXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockImageObjectXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockImageObject") , is_root , })
        }
    }
    impl WithDeserializer for CtPageBlockImageObjectXElementType {
        type Deserializer = quick_xml_deserialize::CtPageBlockImageObjectXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageBlockCompositeObjectXElementType {
        pub boundary: String,
        pub name: Option<String>,
        pub visible: bool,
        pub ctm: Option<String>,
        pub draw_param: Option<u32>,
        pub line_width: f64,
        pub cap: CtGraphicUnitCapXType,
        pub join: CtGraphicUnitJoinXType,
        pub miter_limit: f64,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub alpha: i32,
        pub resource_id: u32,
        pub id: u32,
        pub actions: Option<CtGraphicUnitActionsXElementType>,
        pub clips: Option<CtGraphicUnitClipsXElementType>,
    }
    impl CtPageBlockCompositeObjectXElementType {
        #[must_use]
        pub fn default_visible() -> bool {
            true
        }
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_cap() -> CtGraphicUnitCapXType {
            CtGraphicUnitCapXType::Butt
        }
        #[must_use]
        pub fn default_join() -> CtGraphicUnitJoinXType {
            CtGraphicUnitJoinXType::Miter
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_alpha() -> i32 {
            255i32
        }
    }
    impl WithSerializer for CtPageBlockCompositeObjectXElementType {
        type Serializer<'x> =
            quick_xml_serialize::CtPageBlockCompositeObjectXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPageBlockCompositeObjectXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockCompositeObjectXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockCompositeObject") , is_root , })
        }
    }
    impl WithDeserializer for CtPageBlockCompositeObjectXElementType {
        type Deserializer =
            quick_xml_deserialize::CtPageBlockCompositeObjectXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtPageBlockPageBlockXElementType {
        pub id: u32,
        pub content: Vec<CtPageBlockPageBlockXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtPageBlockPageBlockXElementTypeContent {
        TextObject(CtPageBlockTextObjectXElementType),
        PathObject(CtPageBlockPathObjectXElementType),
        ImageObject(CtPageBlockImageObjectXElementType),
        CompositeObject(CtPageBlockCompositeObjectXElementType),
        PageBlock(CtPageBlockPageBlockXElementType),
    }
    impl WithSerializer for CtPageBlockPageBlockXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPageBlockPageBlockXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPageBlockPageBlock") , is_root , })
        }
    }
    impl WithSerializer for CtPageBlockPageBlockXElementTypeContent {
        type Serializer<'x> =
            quick_xml_serialize::CtPageBlockPageBlockXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPageBlockPageBlockXElementTypeContentSerializerState :: Init__) , })
        }
    }
    impl WithDeserializer for CtPageBlockPageBlockXElementType {
        type Deserializer = quick_xml_deserialize::CtPageBlockPageBlockXElementTypeDeserializer;
    }
    impl WithDeserializer for CtPageBlockPageBlockXElementTypeContent {
        type Deserializer =
            quick_xml_deserialize::CtPageBlockPageBlockXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub enum CtPathRuleXType {
        NonZero,
        EvenOdd,
    }
    impl SerializeBytes for CtPathRuleXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::NonZero => Ok(Some(Cow::Borrowed("NonZero"))),
                Self::EvenOdd => Ok(Some(Cow::Borrowed("Even-Odd"))),
            }
        }
    }
    impl DeserializeBytes for CtPathRuleXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"NonZero" => Ok(Self::NonZero),
                b"Even-Odd" => Ok(Self::EvenOdd),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtPatternReflectMethodXType {
        Normal,
        Row,
        Column,
        RowAndColumn,
    }
    impl SerializeBytes for CtPatternReflectMethodXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Normal => Ok(Some(Cow::Borrowed("Normal"))),
                Self::Row => Ok(Some(Cow::Borrowed("Row"))),
                Self::Column => Ok(Some(Cow::Borrowed("Column"))),
                Self::RowAndColumn => Ok(Some(Cow::Borrowed("RowAndColumn"))),
            }
        }
    }
    impl DeserializeBytes for CtPatternReflectMethodXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Normal" => Ok(Self::Normal),
                b"Row" => Ok(Self::Row),
                b"Column" => Ok(Self::Column),
                b"RowAndColumn" => Ok(Self::RowAndColumn),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtPatternRelativeToXType {
        Page,
        Object,
    }
    impl SerializeBytes for CtPatternRelativeToXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Page => Ok(Some(Cow::Borrowed("Page"))),
                Self::Object => Ok(Some(Cow::Borrowed("Object"))),
            }
        }
    }
    impl DeserializeBytes for CtPatternRelativeToXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Page" => Ok(Self::Page),
                b"Object" => Ok(Self::Object),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtPatternCellContentXElementType {
        pub thumbnail: Option<u32>,
        pub content: Vec<CtPatternCellContentXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum CtPatternCellContentXElementTypeContent {
        TextObject(CtPageBlockTextObjectXElementType),
        PathObject(CtPageBlockPathObjectXElementType),
        ImageObject(CtPageBlockImageObjectXElementType),
        CompositeObject(CtPageBlockCompositeObjectXElementType),
        PageBlock(CtPageBlockPageBlockXElementType),
    }
    impl WithSerializer for CtPatternCellContentXElementType {
        type Serializer<'x> = quick_xml_serialize::CtPatternCellContentXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: CtPatternCellContentXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPatternCellContentXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("CtPatternCellContent") , is_root , })
        }
    }
    impl WithSerializer for CtPatternCellContentXElementTypeContent {
        type Serializer<'x> =
            quick_xml_serialize::CtPatternCellContentXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok (quick_xml_serialize :: CtPatternCellContentXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: CtPatternCellContentXElementTypeContentSerializerState :: Init__) , })
        }
    }
    impl WithDeserializer for CtPatternCellContentXElementType {
        type Deserializer = quick_xml_deserialize::CtPatternCellContentXElementTypeDeserializer;
    }
    impl WithDeserializer for CtPatternCellContentXElementTypeContent {
        type Deserializer =
            quick_xml_deserialize::CtPatternCellContentXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub enum CtTextWeightXType {
        _0,
        _100,
        _200,
        _300,
        _400,
        _500,
        _600,
        _700,
        _800,
        _900,
        _1000,
    }
    impl SerializeBytes for CtTextWeightXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::_0 => Ok(Some(Cow::Borrowed("0"))),
                Self::_100 => Ok(Some(Cow::Borrowed("100"))),
                Self::_200 => Ok(Some(Cow::Borrowed("200"))),
                Self::_300 => Ok(Some(Cow::Borrowed("300"))),
                Self::_400 => Ok(Some(Cow::Borrowed("400"))),
                Self::_500 => Ok(Some(Cow::Borrowed("500"))),
                Self::_600 => Ok(Some(Cow::Borrowed("600"))),
                Self::_700 => Ok(Some(Cow::Borrowed("700"))),
                Self::_800 => Ok(Some(Cow::Borrowed("800"))),
                Self::_900 => Ok(Some(Cow::Borrowed("900"))),
                Self::_1000 => Ok(Some(Cow::Borrowed("1000"))),
            }
        }
    }
    impl DeserializeBytes for CtTextWeightXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"0" => Ok(Self::_0),
                b"100" => Ok(Self::_100),
                b"200" => Ok(Self::_200),
                b"300" => Ok(Self::_300),
                b"400" => Ok(Self::_400),
                b"500" => Ok(Self::_500),
                b"600" => Ok(Self::_600),
                b"700" => Ok(Self::_700),
                b"800" => Ok(Self::_800),
                b"900" => Ok(Self::_900),
                b"1000" => Ok(Self::_1000),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtTextTextCodeXElementType {
        pub x: Option<f64>,
        pub y: Option<f64>,
        pub delta_x: Option<String>,
        pub deltay: Option<String>,
        pub content: String,
    }
    impl WithSerializer for CtTextTextCodeXElementType {
        type Serializer<'x> = quick_xml_serialize::CtTextTextCodeXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtTextTextCodeXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::CtTextTextCodeXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("CtTextTextCode"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtTextTextCodeXElementType {
        type Deserializer = quick_xml_deserialize::CtTextTextCodeXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct PageTemplateXElementType {
        pub template_id: u32,
        pub z_order: PageTemplateZOrderXType,
    }
    impl PageTemplateXElementType {
        #[must_use]
        pub fn default_z_order() -> PageTemplateZOrderXType {
            PageTemplateZOrderXType::Backqround
        }
    }
    impl WithSerializer for PageTemplateXElementType {
        type Serializer<'x> = quick_xml_serialize::PageTemplateXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PageTemplateXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PageTemplateXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PageTemplate"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PageTemplateXElementType {
        type Deserializer = quick_xml_deserialize::PageTemplateXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct PageContentXElementType {
        pub layer: Vec<PageContentLayerXElementType>,
    }
    impl WithSerializer for PageContentXElementType {
        type Serializer<'x> = quick_xml_serialize::PageContentXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::PageContentXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::PageContentXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("PageContent"),
                is_root,
            })
        }
    }
    impl WithDeserializer for PageContentXElementType {
        type Deserializer = quick_xml_deserialize::PageContentXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtGouraudShdPointEdgeFlagXType {
        _0,
        _1,
        _2,
    }
    impl SerializeBytes for CtGouraudShdPointEdgeFlagXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::_0 => Ok(Some(Cow::Borrowed("0"))),
                Self::_1 => Ok(Some(Cow::Borrowed("1"))),
                Self::_2 => Ok(Some(Cow::Borrowed("2"))),
            }
        }
    }
    impl DeserializeBytes for CtGouraudShdPointEdgeFlagXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"0" => Ok(Self::_0),
                b"1" => Ok(Self::_1),
                b"2" => Ok(Self::_2),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum PageTemplateZOrderXType {
        Backqround,
        Foreground,
    }
    impl SerializeBytes for PageTemplateZOrderXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Backqround => Ok(Some(Cow::Borrowed("Backqround"))),
                Self::Foreground => Ok(Some(Cow::Borrowed("Foreground"))),
            }
        }
    }
    impl DeserializeBytes for PageTemplateZOrderXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Backqround" => Ok(Self::Backqround),
                b"Foreground" => Ok(Self::Foreground),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct PageContentLayerXElementType {
        pub type_: CtLayerTypeXType,
        pub draw_param: Option<u32>,
        pub id: u32,
        pub content: Vec<PageContentLayerXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum PageContentLayerXElementTypeContent {
        TextObject(CtPageBlockTextObjectXElementType),
        PathObject(CtPageBlockPathObjectXElementType),
        ImageObject(CtPageBlockImageObjectXElementType),
        CompositeObject(CtPageBlockCompositeObjectXElementType),
        PageBlock(CtPageBlockPageBlockXElementType),
    }
    impl PageContentLayerXElementType {
        #[must_use]
        pub fn default_type_() -> CtLayerTypeXType {
            CtLayerTypeXType::Body
        }
    }
    impl WithSerializer for PageContentLayerXElementType {
        type Serializer<'x> = quick_xml_serialize::PageContentLayerXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::PageContentLayerXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::PageContentLayerXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("PageContentLayer"),
                    is_root,
                },
            )
        }
    }
    impl WithSerializer for PageContentLayerXElementTypeContent {
        type Serializer<'x> =
            quick_xml_serialize::PageContentLayerXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok (quick_xml_serialize :: PageContentLayerXElementTypeContentSerializer { value : self , state : Box :: new (quick_xml_serialize :: PageContentLayerXElementTypeContentSerializerState :: Init__) , })
        }
    }
    impl WithDeserializer for PageContentLayerXElementType {
        type Deserializer = quick_xml_deserialize::PageContentLayerXElementTypeDeserializer;
    }
    impl WithDeserializer for PageContentLayerXElementTypeContent {
        type Deserializer = quick_xml_deserialize::PageContentLayerXElementTypeContentDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, ContentDeserializer, DeserializeHelper, Deserializer, DeserializerArtifact,
            DeserializerEvent, DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error,
            ErrorKind, Event, RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct CtAxialShdXTypeDeserializer {
            map_type: super::CtAxialShdMapTypeXType,
            map_unit: Option<f64>,
            extend: super::CtAxialShdExtendXType,
            start_point: String,
            end_point: String,
            segment: Vec<super::CtAxialShdSegmentXElementType>,
            state__: Box<CtAxialShdXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtAxialShdXTypeDeserializerState {
            Init__,
            Segment(
                Option<<super::CtAxialShdSegmentXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtAxialShdXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut map_type: Option<super::CtAxialShdMapTypeXType> = None;
                let mut map_unit: Option<f64> = None;
                let mut extend: Option<super::CtAxialShdExtendXType> = None;
                let mut start_point: Option<String> = None;
                let mut end_point: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MapType")
                    ) {
                        helper.read_attrib(&mut map_type, b"MapType", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MapUnit")
                    ) {
                        helper.read_attrib(&mut map_unit, b"MapUnit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Extend")
                    ) {
                        helper.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"StartPoint")
                    ) {
                        helper.read_attrib(&mut start_point, b"StartPoint", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EndPoint")
                    ) {
                        helper.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    map_type: map_type.unwrap_or_else(super::CtAxialShdXType::default_map_type),
                    map_unit: map_unit,
                    extend: extend.unwrap_or_else(super::CtAxialShdXType::default_extend),
                    start_point: start_point
                        .ok_or_else(|| ErrorKind::MissingAttribute("StartPoint".into()))?,
                    end_point: end_point
                        .ok_or_else(|| ErrorKind::MissingAttribute("EndPoint".into()))?,
                    segment: Vec::new(),
                    state__: Box::new(CtAxialShdXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtAxialShdXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtAxialShdXTypeDeserializerState as S;
                match state {
                    S::Segment(Some(deserializer)) => {
                        self.store_segment(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_segment(
                &mut self,
                value: super::CtAxialShdSegmentXElementType,
            ) -> Result<(), Error> {
                self.segment.push(value);
                Ok(())
            }
            fn handle_segment<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtAxialShdSegmentXElementType>,
                fallback: &mut Option<CtAxialShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtAxialShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.segment.len() < 2usize {
                        fallback.get_or_insert(S::Segment(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Segment(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_segment(data)?;
                        *self.state__ = S::Segment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Segment(Some(deserializer)));
                        *self.state__ = S::Segment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtAxialShdXType> for CtAxialShdXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAxialShdXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAxialShdXType> {
                use CtAxialShdXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Segment(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_segment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Segment(None);
                            event
                        }
                        (S::Segment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Segment",
                                true,
                            )?;
                            match self.handle_segment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtAxialShdXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtAxialShdXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtAxialShdXType {
                    map_type: self.map_type,
                    map_unit: self.map_unit,
                    extend: self.extend,
                    start_point: self.start_point,
                    end_point: self.end_point,
                    segment: helper.finish_vec(2usize, None, self.segment)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtCgTransformXTypeDeserializer {
            code_position: i32,
            code_count: i32,
            glyph_count: i32,
            glyphs: Option<String>,
            state__: Box<CtCgTransformXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtCgTransformXTypeDeserializerState {
            Init__,
            Glyphs(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtCgTransformXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut code_position: Option<i32> = None;
                let mut code_count: Option<i32> = None;
                let mut glyph_count: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CodePosition")
                    ) {
                        helper.read_attrib(&mut code_position, b"CodePosition", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CodeCount")
                    ) {
                        helper.read_attrib(&mut code_count, b"CodeCount", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"GlyphCount")
                    ) {
                        helper.read_attrib(&mut glyph_count, b"GlyphCount", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    code_position: code_position
                        .ok_or_else(|| ErrorKind::MissingAttribute("CodePosition".into()))?,
                    code_count: code_count
                        .unwrap_or_else(super::CtCgTransformXType::default_code_count),
                    glyph_count: glyph_count
                        .unwrap_or_else(super::CtCgTransformXType::default_glyph_count),
                    glyphs: None,
                    state__: Box::new(CtCgTransformXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtCgTransformXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtCgTransformXTypeDeserializerState as S;
                match state {
                    S::Glyphs(Some(deserializer)) => {
                        self.store_glyphs(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_glyphs(&mut self, value: String) -> Result<(), Error> {
                if self.glyphs.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Glyphs",
                    )))?;
                }
                self.glyphs = Some(value);
                Ok(())
            }
            fn handle_glyphs<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtCgTransformXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtCgTransformXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Glyphs(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_glyphs(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Glyphs(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtCgTransformXType> for CtCgTransformXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtCgTransformXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtCgTransformXType> {
                use CtCgTransformXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Glyphs(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_glyphs(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Glyphs(None);
                            event
                        }
                        (S::Glyphs(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Glyphs",
                                false,
                            )?;
                            match self.handle_glyphs(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtCgTransformXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtCgTransformXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtCgTransformXType {
                    code_position: self.code_position,
                    code_count: self.code_count,
                    glyph_count: self.glyph_count,
                    glyphs: self.glyphs,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtClipXTypeDeserializer {
            area: Vec<super::CtClipAreaXElementType>,
            state__: Box<CtClipXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtClipXTypeDeserializerState {
            Init__,
            Area(Option<<super::CtClipAreaXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtClipXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    area: Vec::new(),
                    state__: Box::new(CtClipXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtClipXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtClipXTypeDeserializerState as S;
                match state {
                    S::Area(Some(deserializer)) => self.store_area(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_area(&mut self, value: super::CtClipAreaXElementType) -> Result<(), Error> {
                self.area.push(value);
                Ok(())
            }
            fn handle_area<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtClipAreaXElementType>,
                fallback: &mut Option<CtClipXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtClipXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.area.len() < 1usize {
                        fallback.get_or_insert(S::Area(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Area(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_area(data)?;
                        *self.state__ = S::Area(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Area(Some(deserializer)));
                        *self.state__ = S::Area(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtClipXType> for CtClipXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipXType> {
                use CtClipXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Area(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Area(None);
                            event
                        }
                        (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Area",
                                true,
                            )?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtClipXType, Error> {
                let state = replace(&mut *self.state__, CtClipXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtClipXType {
                    area: helper.finish_vec(1usize, None, self.area)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtColorXTypeDeserializer {
            value: Option<String>,
            index: Option<i32>,
            color_space: Option<u32>,
            alpha: i32,
            content: Option<super::CtColorXTypeContent>,
            state__: Box<CtColorXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtColorXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtColorXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtColorXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut value: Option<String> = None;
                let mut index: Option<i32> = None;
                let mut color_space: Option<u32> = None;
                let mut alpha: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Value")
                    ) {
                        helper.read_attrib(&mut value, b"Value", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Index")
                    ) {
                        helper.read_attrib(&mut index, b"Index", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ColorSpace")
                    ) {
                        helper.read_attrib(&mut color_space, b"ColorSpace", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    value: value,
                    index: index,
                    color_space: color_space,
                    alpha: alpha.unwrap_or_else(super::CtColorXType::default_alpha),
                    content: None,
                    state__: Box::new(CtColorXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtColorXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtColorXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::CtColorXTypeContent) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXTypeContent>,
                fallback: &mut Option<CtColorXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtColorXType> for CtColorXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorXType> {
                use CtColorXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = <super::CtColorXTypeContent as WithDeserializer>::init(
                                helper, event,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtColorXType, Error> {
                let state = replace(&mut *self.state__, CtColorXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtColorXType {
                    value: self.value,
                    index: self.index,
                    color_space: self.color_space,
                    alpha: self.alpha,
                    content: self.content,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtColorXTypeContentDeserializer {
            state__: Box<CtColorXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtColorXTypeContentDeserializerState {
            Init__,
            Pattern(
                Option<super::CtPatternXType>,
                Option<<super::CtPatternXType as WithDeserializer>::Deserializer>,
                Option<<super::CtPatternXType as WithDeserializer>::Deserializer>,
            ),
            AxialShd(
                Option<super::CtAxialShdXType>,
                Option<<super::CtAxialShdXType as WithDeserializer>::Deserializer>,
                Option<<super::CtAxialShdXType as WithDeserializer>::Deserializer>,
            ),
            RadialShd(
                Option<super::CtRadialShdXType>,
                Option<<super::CtRadialShdXType as WithDeserializer>::Deserializer>,
                Option<<super::CtRadialShdXType as WithDeserializer>::Deserializer>,
            ),
            GouraudShd(
                Option<super::CtGouraudShdXType>,
                Option<<super::CtGouraudShdXType as WithDeserializer>::Deserializer>,
                Option<<super::CtGouraudShdXType as WithDeserializer>::Deserializer>,
            ),
            LaGourandShd(
                Option<super::CtLaGouraudShdXType>,
                Option<<super::CtLaGouraudShdXType as WithDeserializer>::Deserializer>,
                Option<<super::CtLaGouraudShdXType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtColorXTypeContent),
            Unknown__,
        }
        impl CtColorXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Pattern")
                    ) {
                        let output =
                            <super::CtPatternXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_pattern(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"AxialShd")
                    ) {
                        let output =
                            <super::CtAxialShdXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_axial_shd(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"RadialShd")
                    ) {
                        let output =
                            <super::CtRadialShdXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_radial_shd(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"GouraudShd")
                    ) {
                        let output =
                            <super::CtGouraudShdXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_gouraud_shd(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"LaGourandShd")
                    ) {
                        let output =
                            <super::CtLaGouraudShdXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_la_gourand_shd(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                }
                *self.state__ = CtColorXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtColorXTypeContentDeserializerState,
            ) -> Result<super::CtColorXTypeContent, Error> {
                use CtColorXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Pattern(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_pattern(&mut values, value)?;
                        }
                        Ok(super::CtColorXTypeContent::Pattern(
                            helper.finish_element("Pattern", values)?,
                        ))
                    }
                    S::AxialShd(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_axial_shd(&mut values, value)?;
                        }
                        Ok(super::CtColorXTypeContent::AxialShd(
                            helper.finish_element("AxialShd", values)?,
                        ))
                    }
                    S::RadialShd(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_radial_shd(&mut values, value)?;
                        }
                        Ok(super::CtColorXTypeContent::RadialShd(
                            helper.finish_element("RadialShd", values)?,
                        ))
                    }
                    S::GouraudShd(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_gouraud_shd(&mut values, value)?;
                        }
                        Ok(super::CtColorXTypeContent::GouraudShd(
                            helper.finish_element("GouraudShd", values)?,
                        ))
                    }
                    S::LaGourandShd(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_la_gourand_shd(&mut values, value)?;
                        }
                        Ok(super::CtColorXTypeContent::LaGourandShd(
                            helper.finish_element("LaGourandShd", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_pattern(
                values: &mut Option<super::CtPatternXType>,
                value: super::CtPatternXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Pattern",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_axial_shd(
                values: &mut Option<super::CtAxialShdXType>,
                value: super::CtAxialShdXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"AxialShd",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_radial_shd(
                values: &mut Option<super::CtRadialShdXType>,
                value: super::CtRadialShdXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"RadialShd",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_gouraud_shd(
                values: &mut Option<super::CtGouraudShdXType>,
                value: super::CtGouraudShdXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"GouraudShd",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_la_gourand_shd(
                values: &mut Option<super::CtLaGouraudShdXType>,
                value: super::CtLaGouraudShdXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"LaGourandShd",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_pattern<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPatternXType>,
                fallback: Option<<super::CtPatternXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtPatternXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_pattern(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_pattern(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Pattern(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Pattern(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_axial_shd<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtAxialShdXType>,
                fallback: Option<<super::CtAxialShdXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtAxialShdXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_axial_shd(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_axial_shd(&mut values, data)?;
                        let data = Self::finish_state(helper, S::AxialShd(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::AxialShd(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_radial_shd<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtRadialShdXType>,
                fallback: Option<<super::CtRadialShdXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtRadialShdXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_radial_shd(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_radial_shd(&mut values, data)?;
                        let data = Self::finish_state(helper, S::RadialShd(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::RadialShd(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_gouraud_shd<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtGouraudShdXType>,
                fallback: Option<<super::CtGouraudShdXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtGouraudShdXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_gouraud_shd(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_gouraud_shd(&mut values, data)?;
                        let data = Self::finish_state(helper, S::GouraudShd(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::GouraudShd(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_la_gourand_shd<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtLaGouraudShdXType>,
                fallback: Option<<super::CtLaGouraudShdXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtLaGouraudShdXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_la_gourand_shd(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_la_gourand_shd(&mut values, data)?;
                        let data = Self::finish_state(helper, S::LaGourandShd(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::LaGourandShd(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtColorXTypeContent> for CtColorXTypeContentDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtColorXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state__, CtColorXTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorXTypeContent> {
                use CtColorXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Pattern(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_pattern(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::AxialShd(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_axial_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::RadialShd(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_radial_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::GouraudShd(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_gouraud_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::LaGourandShd(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_la_gourand_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Pattern(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Pattern",
                                true,
                            )?;
                            match self.handle_pattern(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::AxialShd(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"AxialShd",
                                true,
                            )?;
                            match self.handle_axial_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::RadialShd(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"RadialShd",
                                true,
                            )?;
                            match self.handle_radial_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::GouraudShd(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"GouraudShd",
                                true,
                            )?;
                            match self.handle_gouraud_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::LaGourandShd(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"LaGourandShd",
                                true,
                            )?;
                            match self.handle_la_gourand_shd(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtColorXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtCompositeXTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            resource_id: u32,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            state__: Box<CtCompositeXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtCompositeXTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtCompositeXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut resource_id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(super::CtCompositeXType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width
                        .unwrap_or_else(super::CtCompositeXType::default_line_width),
                    cap: cap.unwrap_or_else(super::CtCompositeXType::default_cap),
                    join: join.unwrap_or_else(super::CtCompositeXType::default_join),
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtCompositeXType::default_miter_limit),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtCompositeXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(super::CtCompositeXType::default_alpha),
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    actions: None,
                    clips: None,
                    state__: Box::new(CtCompositeXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtCompositeXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtCompositeXTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtCompositeXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtCompositeXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtCompositeXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtCompositeXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtCompositeXType> for CtCompositeXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtCompositeXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtCompositeXType> {
                use CtCompositeXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtCompositeXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtCompositeXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtCompositeXType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    resource_id: self.resource_id,
                    actions: self.actions,
                    clips: self.clips,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtGouraudShdXTypeDeserializer {
            extend: Option<i32>,
            point: Vec<super::CtGouraudShdPointXElementType>,
            back_color: Option<super::CtColorXType>,
            state__: Box<CtGouraudShdXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtGouraudShdXTypeDeserializerState {
            Init__,
            Point(Option<<super::CtGouraudShdPointXElementType as WithDeserializer>::Deserializer>),
            BackColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtGouraudShdXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut extend: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Extend")
                    ) {
                        helper.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    extend: extend,
                    point: Vec::new(),
                    back_color: None,
                    state__: Box::new(CtGouraudShdXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtGouraudShdXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtGouraudShdXTypeDeserializerState as S;
                match state {
                    S::Point(Some(deserializer)) => {
                        self.store_point(deserializer.finish(helper)?)?
                    }
                    S::BackColor(Some(deserializer)) => {
                        self.store_back_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_point(
                &mut self,
                value: super::CtGouraudShdPointXElementType,
            ) -> Result<(), Error> {
                self.point.push(value);
                Ok(())
            }
            fn store_back_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.back_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"BackColor",
                    )))?;
                }
                self.back_color = Some(value);
                Ok(())
            }
            fn handle_point<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGouraudShdPointXElementType>,
                fallback: &mut Option<CtGouraudShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGouraudShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.point.len() < 3usize {
                        fallback.get_or_insert(S::Point(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Point(None));
                        *self.state__ = S::BackColor(None);
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_point(data)?;
                        *self.state__ = S::Point(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Point(Some(deserializer)));
                        *self.state__ = S::Point(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_back_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtGouraudShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGouraudShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::BackColor(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_back_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::BackColor(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtGouraudShdXType> for CtGouraudShdXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGouraudShdXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGouraudShdXType> {
                use CtGouraudShdXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Point(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_point(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BackColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_back_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Point(None);
                            event
                        }
                        (S::Point(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Point",
                                true,
                            )?;
                            match self.handle_point(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BackColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"BackColor",
                                true,
                            )?;
                            match self.handle_back_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtGouraudShdXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtGouraudShdXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtGouraudShdXType {
                    extend: self.extend,
                    point: helper.finish_vec(3usize, None, self.point)?,
                    back_color: self.back_color.map(Box::new),
                })
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitXTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            state__: Box<CtGraphicUnitXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtGraphicUnitXTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtGraphicUnitXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(super::CtGraphicUnitXType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width
                        .unwrap_or_else(super::CtGraphicUnitXType::default_line_width),
                    cap: cap.unwrap_or_else(super::CtGraphicUnitXType::default_cap),
                    join: join.unwrap_or_else(super::CtGraphicUnitXType::default_join),
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtGraphicUnitXType::default_miter_limit),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtGraphicUnitXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(super::CtGraphicUnitXType::default_alpha),
                    actions: None,
                    clips: None,
                    state__: Box::new(CtGraphicUnitXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtGraphicUnitXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtGraphicUnitXTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtGraphicUnitXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGraphicUnitXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtGraphicUnitXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGraphicUnitXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtGraphicUnitXType> for CtGraphicUnitXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitXType> {
                use CtGraphicUnitXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtGraphicUnitXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtGraphicUnitXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtGraphicUnitXType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    actions: self.actions,
                    clips: self.clips,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtImageXTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            resource_id: u32,
            substitution: Option<u32>,
            image_mask: Option<u32>,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            border: Option<super::CtImageBorderXElementType>,
            state__: Box<CtImageXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtImageXTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            Border(Option<<super::CtImageBorderXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtImageXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut resource_id: Option<u32> = None;
                let mut substitution: Option<u32> = None;
                let mut image_mask: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Substitution")
                    ) {
                        helper.read_attrib(&mut substitution, b"Substitution", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ImageMask")
                    ) {
                        helper.read_attrib(&mut image_mask, b"ImageMask", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(super::CtImageXType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(super::CtImageXType::default_line_width),
                    cap: cap.unwrap_or_else(super::CtImageXType::default_cap),
                    join: join.unwrap_or_else(super::CtImageXType::default_join),
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtImageXType::default_miter_limit),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtImageXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(super::CtImageXType::default_alpha),
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    substitution: substitution,
                    image_mask: image_mask,
                    actions: None,
                    clips: None,
                    border: None,
                    state__: Box::new(CtImageXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtImageXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtImageXTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    S::Border(Some(deserializer)) => {
                        self.store_border(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn store_border(
                &mut self,
                value: super::CtImageBorderXElementType,
            ) -> Result<(), Error> {
                if self.border.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Border",
                    )))?;
                }
                self.border = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtImageXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtImageXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtImageXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtImageXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::Border(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::Border(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::Border(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_border<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtImageBorderXElementType>,
                fallback: &mut Option<CtImageXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtImageXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Border(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_border(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Border(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtImageXType> for CtImageXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtImageXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtImageXType> {
                use CtImageXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Border(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_border(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Border(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Border",
                                true,
                            )?;
                            match self.handle_border(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtImageXType, Error> {
                let state = replace(&mut *self.state__, CtImageXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtImageXType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    resource_id: self.resource_id,
                    substitution: self.substitution,
                    image_mask: self.image_mask,
                    actions: self.actions,
                    clips: self.clips,
                    border: self.border,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtLaGouraudShdXTypeDeserializer {
            vertices_per_row: i32,
            extend: Option<i32>,
            point: Vec<super::CtLaGouraudShdPointXElementType>,
            back_color: Option<super::CtColorXType>,
            state__: Box<CtLaGouraudShdXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtLaGouraudShdXTypeDeserializerState {
            Init__,
            Point(
                Option<<super::CtLaGouraudShdPointXElementType as WithDeserializer>::Deserializer>,
            ),
            BackColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtLaGouraudShdXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut vertices_per_row: Option<i32> = None;
                let mut extend: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"VerticesPerRow")
                    ) {
                        helper.read_attrib(
                            &mut vertices_per_row,
                            b"VerticesPerRow",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Extend")
                    ) {
                        helper.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    vertices_per_row: vertices_per_row
                        .ok_or_else(|| ErrorKind::MissingAttribute("VerticesPerRow".into()))?,
                    extend: extend,
                    point: Vec::new(),
                    back_color: None,
                    state__: Box::new(CtLaGouraudShdXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtLaGouraudShdXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtLaGouraudShdXTypeDeserializerState as S;
                match state {
                    S::Point(Some(deserializer)) => {
                        self.store_point(deserializer.finish(helper)?)?
                    }
                    S::BackColor(Some(deserializer)) => {
                        self.store_back_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_point(
                &mut self,
                value: super::CtLaGouraudShdPointXElementType,
            ) -> Result<(), Error> {
                self.point.push(value);
                Ok(())
            }
            fn store_back_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.back_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"BackColor",
                    )))?;
                }
                self.back_color = Some(value);
                Ok(())
            }
            fn handle_point<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtLaGouraudShdPointXElementType>,
                fallback: &mut Option<CtLaGouraudShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLaGouraudShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.point.len() < 4usize {
                        fallback.get_or_insert(S::Point(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Point(None));
                        *self.state__ = S::BackColor(None);
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_point(data)?;
                        *self.state__ = S::Point(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Point(Some(deserializer)));
                        *self.state__ = S::Point(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_back_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtLaGouraudShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLaGouraudShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::BackColor(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_back_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::BackColor(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtLaGouraudShdXType> for CtLaGouraudShdXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLaGouraudShdXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLaGouraudShdXType> {
                use CtLaGouraudShdXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Point(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_point(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BackColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_back_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Point(None);
                            event
                        }
                        (S::Point(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Point",
                                true,
                            )?;
                            match self.handle_point(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::BackColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"BackColor",
                                true,
                            )?;
                            match self.handle_back_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtLaGouraudShdXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtLaGouraudShdXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtLaGouraudShdXType {
                    vertices_per_row: self.vertices_per_row,
                    extend: self.extend,
                    point: helper.finish_vec(4usize, None, self.point)?,
                    back_color: self.back_color.map(Box::new),
                })
            }
        }
        #[derive(Debug)]
        pub struct CtLayerXTypeDeserializer {
            type_: super::CtLayerTypeXType,
            draw_param: Option<u32>,
            content: Vec<super::CtLayerXTypeContent>,
            state__: Box<CtLayerXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtLayerXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtLayerXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtLayerXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtLayerTypeXType> = None;
                let mut draw_param: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.unwrap_or_else(super::CtLayerXType::default_type_),
                    draw_param: draw_param,
                    content: Vec::new(),
                    state__: Box::new(CtLayerXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtLayerXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtLayerXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::CtLayerXTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtLayerXTypeContent>,
                fallback: &mut Option<CtLayerXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtLayerXType> for CtLayerXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLayerXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLayerXType> {
                use CtLayerXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = <super::CtLayerXTypeContent as WithDeserializer>::init(
                                helper, event,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtLayerXType, Error> {
                let state = replace(&mut *self.state__, CtLayerXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtLayerXType {
                    type_: self.type_,
                    draw_param: self.draw_param,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtLayerXTypeContentDeserializer {
            state__: Box<CtLayerXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtLayerXTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: CtPageBlockTextObjectXElementType > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: CtPageBlockPathObjectXElementType > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: CtPageBlockImageObjectXElementType > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: CtPageBlockCompositeObjectXElementType > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: CtPageBlockPageBlockXElementType > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: CtLayerXTypeContent) , Unknown__ , }
        impl CtLayerXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output =
                            <super::CtPageBlockTextObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output =
                            <super::CtPageBlockPathObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output =
                            <super::CtPageBlockImageObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output =
                            <super::CtPageBlockPageBlockXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtLayerXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtLayerXTypeContentDeserializerState,
            ) -> Result<super::CtLayerXTypeContent, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(super::CtLayerXTypeContent::TextObject(
                            helper.finish_element("TextObject", values)?,
                        ))
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(super::CtLayerXTypeContent::PathObject(
                            helper.finish_element("PathObject", values)?,
                        ))
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(super::CtLayerXTypeContent::ImageObject(
                            helper.finish_element("ImageObject", values)?,
                        ))
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(super::CtLayerXTypeContent::CompositeObject(
                            helper.finish_element("CompositeObject", values)?,
                        ))
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(super::CtLayerXTypeContent::PageBlock(
                            helper.finish_element("PageBlock", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::CtPageBlockTextObjectXElementType>,
                value: super::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::CtPageBlockPathObjectXElementType>,
                value: super::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::CtPageBlockImageObjectXElementType>,
                value: super::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
                value: super::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::CtPageBlockPageBlockXElementType>,
                value: super::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockTextObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPathObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockImageObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPageBlockXElementType>,
                fallback: Option<
                    <super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLayerXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtLayerXTypeContent> for CtLayerXTypeContentDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLayerXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtLayerXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state__, CtLayerXTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLayerXTypeContent> {
                use CtLayerXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtLayerXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockXTypeDeserializer {
            content: Vec<super::CtPageBlockXTypeContent>,
            state__: Box<CtPageBlockXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtPageBlockXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtPageBlockXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    content: Vec::new(),
                    state__: Box::new(CtPageBlockXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtPageBlockXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtPageBlockXTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPageBlockXTypeContent>,
                fallback: &mut Option<CtPageBlockXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockXType> for CtPageBlockXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockXType> {
                use CtPageBlockXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::CtPageBlockXTypeContent as WithDeserializer>::init(
                                    helper, event,
                                )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockXType {
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockXTypeContentDeserializer {
            state__: Box<CtPageBlockXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtPageBlockXTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: CtPageBlockTextObjectXElementType > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: CtPageBlockPathObjectXElementType > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: CtPageBlockImageObjectXElementType > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: CtPageBlockCompositeObjectXElementType > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: CtPageBlockPageBlockXElementType > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: CtPageBlockXTypeContent) , Unknown__ , }
        impl CtPageBlockXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output =
                            <super::CtPageBlockTextObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output =
                            <super::CtPageBlockPathObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output =
                            <super::CtPageBlockImageObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output =
                            <super::CtPageBlockPageBlockXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtPageBlockXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtPageBlockXTypeContentDeserializerState,
            ) -> Result<super::CtPageBlockXTypeContent, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockXTypeContent::TextObject(
                            helper.finish_element("TextObject", values)?,
                        ))
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockXTypeContent::PathObject(
                            helper.finish_element("PathObject", values)?,
                        ))
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockXTypeContent::ImageObject(
                            helper.finish_element("ImageObject", values)?,
                        ))
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockXTypeContent::CompositeObject(
                            helper.finish_element("CompositeObject", values)?,
                        ))
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockXTypeContent::PageBlock(
                            helper.finish_element("PageBlock", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::CtPageBlockTextObjectXElementType>,
                value: super::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::CtPageBlockPathObjectXElementType>,
                value: super::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::CtPageBlockImageObjectXElementType>,
                value: super::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
                value: super::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::CtPageBlockPageBlockXElementType>,
                value: super::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockTextObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPathObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockImageObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPageBlockXElementType>,
                fallback: Option<
                    <super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockXTypeContent>
            for CtPageBlockXTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtPageBlockXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtPageBlockXTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockXTypeContent> {
                use CtPageBlockXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtPathXTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            stroke: bool,
            fill: bool,
            rule: super::CtPathRuleXType,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            stroke_color: Option<super::CtColorXType>,
            fill_color: Option<super::CtColorXType>,
            abbreviated_data: Option<String>,
            state__: Box<CtPathXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPathXTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            AbbreviatedData(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtPathXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut stroke: Option<bool> = None;
                let mut fill: Option<bool> = None;
                let mut rule: Option<super::CtPathRuleXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Stroke")
                    ) {
                        helper.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Fill")
                    ) {
                        helper.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Rule")
                    ) {
                        helper.read_attrib(&mut rule, b"Rule", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(super::CtPathXType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(super::CtPathXType::default_line_width),
                    cap: cap.unwrap_or_else(super::CtPathXType::default_cap),
                    join: join.unwrap_or_else(super::CtPathXType::default_join),
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtPathXType::default_miter_limit),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtPathXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(super::CtPathXType::default_alpha),
                    stroke: stroke.unwrap_or_else(super::CtPathXType::default_stroke),
                    fill: fill.unwrap_or_else(super::CtPathXType::default_fill),
                    rule: rule.unwrap_or_else(super::CtPathXType::default_rule),
                    actions: None,
                    clips: None,
                    stroke_color: None,
                    fill_color: None,
                    abbreviated_data: None,
                    state__: Box::new(CtPathXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPathXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPathXTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    S::StrokeColor(Some(deserializer)) => {
                        self.store_stroke_color(deserializer.finish(helper)?)?
                    }
                    S::FillColor(Some(deserializer)) => {
                        self.store_fill_color(deserializer.finish(helper)?)?
                    }
                    S::AbbreviatedData(Some(deserializer)) => {
                        self.store_abbreviated_data(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.stroke_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                self.stroke_color = Some(value);
                Ok(())
            }
            fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.fill_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                self.fill_color = Some(value);
                Ok(())
            }
            fn store_abbreviated_data(&mut self, value: String) -> Result<(), Error> {
                if self.abbreviated_data.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"AbbreviatedData",
                    )))?;
                }
                self.abbreviated_data = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtPathXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPathXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtPathXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPathXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::StrokeColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtPathXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPathXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::StrokeColor(None));
                    *self.state__ = S::FillColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_stroke_color(data)?;
                        *self.state__ = S::FillColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::StrokeColor(Some(deserializer)));
                        *self.state__ = S::FillColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtPathXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPathXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FillColor(None));
                    *self.state__ = S::AbbreviatedData(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fill_color(data)?;
                        *self.state__ = S::AbbreviatedData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FillColor(Some(deserializer)));
                        *self.state__ = S::AbbreviatedData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_abbreviated_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPathXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPathXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::AbbreviatedData(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_abbreviated_data(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::AbbreviatedData(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPathXType> for CtPathXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPathXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPathXType> {
                use CtPathXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FillColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::AbbreviatedData(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_abbreviated_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::AbbreviatedData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"AbbreviatedData",
                                false,
                            )?;
                            match self.handle_abbreviated_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPathXType, Error> {
                let state = replace(&mut *self.state__, CtPathXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtPathXType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    stroke: self.stroke,
                    fill: self.fill,
                    rule: self.rule,
                    actions: self.actions,
                    clips: self.clips,
                    stroke_color: self.stroke_color,
                    fill_color: self.fill_color,
                    abbreviated_data: helper
                        .finish_element("AbbreviatedData", self.abbreviated_data)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPatternXTypeDeserializer {
            width: f64,
            height: f64,
            x_step: Option<f64>,
            y_step: Option<f64>,
            reflect_method: super::CtPatternReflectMethodXType,
            relative_to: super::CtPatternRelativeToXType,
            ctm: Option<String>,
            cell_content: Option<super::CtPatternCellContentXElementType>,
            state__: Box<CtPatternXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPatternXTypeDeserializerState {
            Init__,
            CellContent(
                Option<<super::CtPatternCellContentXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtPatternXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut width: Option<f64> = None;
                let mut height: Option<f64> = None;
                let mut x_step: Option<f64> = None;
                let mut y_step: Option<f64> = None;
                let mut reflect_method: Option<super::CtPatternReflectMethodXType> = None;
                let mut relative_to: Option<super::CtPatternRelativeToXType> = None;
                let mut ctm: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Width")
                    ) {
                        helper.read_attrib(&mut width, b"Width", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Height")
                    ) {
                        helper.read_attrib(&mut height, b"Height", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"XStep")
                    ) {
                        helper.read_attrib(&mut x_step, b"XStep", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"YStep")
                    ) {
                        helper.read_attrib(&mut y_step, b"YStep", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ReflectMethod")
                    ) {
                        helper.read_attrib(&mut reflect_method, b"ReflectMethod", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"RelativeTo")
                    ) {
                        helper.read_attrib(&mut relative_to, b"RelativeTo", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    width: width.ok_or_else(|| ErrorKind::MissingAttribute("Width".into()))?,
                    height: height.ok_or_else(|| ErrorKind::MissingAttribute("Height".into()))?,
                    x_step: x_step,
                    y_step: y_step,
                    reflect_method: reflect_method
                        .unwrap_or_else(super::CtPatternXType::default_reflect_method),
                    relative_to: relative_to
                        .unwrap_or_else(super::CtPatternXType::default_relative_to),
                    ctm: ctm,
                    cell_content: None,
                    state__: Box::new(CtPatternXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPatternXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPatternXTypeDeserializerState as S;
                match state {
                    S::CellContent(Some(deserializer)) => {
                        self.store_cell_content(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_cell_content(
                &mut self,
                value: super::CtPatternCellContentXElementType,
            ) -> Result<(), Error> {
                if self.cell_content.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CellContent",
                    )))?;
                }
                self.cell_content = Some(value);
                Ok(())
            }
            fn handle_cell_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPatternCellContentXElementType>,
                fallback: &mut Option<CtPatternXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CellContent(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_cell_content(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CellContent(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPatternXType> for CtPatternXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternXType> {
                use CtPatternXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CellContent(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cell_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CellContent(None);
                            event
                        }
                        (S::CellContent(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CellContent",
                                true,
                            )?;
                            match self.handle_cell_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPatternXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPatternXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPatternXType {
                    width: self.width,
                    height: self.height,
                    x_step: self.x_step,
                    y_step: self.y_step,
                    reflect_method: self.reflect_method,
                    relative_to: self.relative_to,
                    ctm: self.ctm,
                    cell_content: helper.finish_element("CellContent", self.cell_content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtRadialShdXTypeDeserializer {
            map_type: super::CtAxialShdMapTypeXType,
            map_unit: Option<f64>,
            eccentricity: f64,
            angle: f64,
            start_point: String,
            start_radius: f64,
            end_point: String,
            end_radius: f64,
            extend: i32,
            seqment: Vec<super::CtAxialShdSegmentXElementType>,
            state__: Box<CtRadialShdXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtRadialShdXTypeDeserializerState {
            Init__,
            Seqment(
                Option<<super::CtAxialShdSegmentXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtRadialShdXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut map_type: Option<super::CtAxialShdMapTypeXType> = None;
                let mut map_unit: Option<f64> = None;
                let mut eccentricity: Option<f64> = None;
                let mut angle: Option<f64> = None;
                let mut start_point: Option<String> = None;
                let mut start_radius: Option<f64> = None;
                let mut end_point: Option<String> = None;
                let mut end_radius: Option<f64> = None;
                let mut extend: Option<i32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MapType")
                    ) {
                        helper.read_attrib(&mut map_type, b"MapType", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MapUnit")
                    ) {
                        helper.read_attrib(&mut map_unit, b"MapUnit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Eccentricity")
                    ) {
                        helper.read_attrib(&mut eccentricity, b"Eccentricity", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Angle")
                    ) {
                        helper.read_attrib(&mut angle, b"Angle", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"StartPoint")
                    ) {
                        helper.read_attrib(&mut start_point, b"StartPoint", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"StartRadius")
                    ) {
                        helper.read_attrib(&mut start_radius, b"StartRadius", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EndPoint")
                    ) {
                        helper.read_attrib(&mut end_point, b"EndPoint", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EndRadius")
                    ) {
                        helper.read_attrib(&mut end_radius, b"EndRadius", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Extend")
                    ) {
                        helper.read_attrib(&mut extend, b"Extend", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    map_type: map_type.unwrap_or_else(super::CtRadialShdXType::default_map_type),
                    map_unit: map_unit,
                    eccentricity: eccentricity
                        .unwrap_or_else(super::CtRadialShdXType::default_eccentricity),
                    angle: angle.unwrap_or_else(super::CtRadialShdXType::default_angle),
                    start_point: start_point
                        .ok_or_else(|| ErrorKind::MissingAttribute("StartPoint".into()))?,
                    start_radius: start_radius
                        .unwrap_or_else(super::CtRadialShdXType::default_start_radius),
                    end_point: end_point
                        .ok_or_else(|| ErrorKind::MissingAttribute("EndPoint".into()))?,
                    end_radius: end_radius
                        .ok_or_else(|| ErrorKind::MissingAttribute("EndRadius".into()))?,
                    extend: extend.unwrap_or_else(super::CtRadialShdXType::default_extend),
                    seqment: Vec::new(),
                    state__: Box::new(CtRadialShdXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtRadialShdXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtRadialShdXTypeDeserializerState as S;
                match state {
                    S::Seqment(Some(deserializer)) => {
                        self.store_seqment(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_seqment(
                &mut self,
                value: super::CtAxialShdSegmentXElementType,
            ) -> Result<(), Error> {
                self.seqment.push(value);
                Ok(())
            }
            fn handle_seqment<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtAxialShdSegmentXElementType>,
                fallback: &mut Option<CtRadialShdXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtRadialShdXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.seqment.len() < 2usize {
                        fallback.get_or_insert(S::Seqment(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Seqment(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_seqment(data)?;
                        *self.state__ = S::Seqment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Seqment(Some(deserializer)));
                        *self.state__ = S::Seqment(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtRadialShdXType> for CtRadialShdXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRadialShdXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtRadialShdXType> {
                use CtRadialShdXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Seqment(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_seqment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Seqment(None);
                            event
                        }
                        (S::Seqment(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Seqment",
                                true,
                            )?;
                            match self.handle_seqment(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtRadialShdXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtRadialShdXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtRadialShdXType {
                    map_type: self.map_type,
                    map_unit: self.map_unit,
                    eccentricity: self.eccentricity,
                    angle: self.angle,
                    start_point: self.start_point,
                    start_radius: self.start_radius,
                    end_point: self.end_point,
                    end_radius: self.end_radius,
                    extend: self.extend,
                    seqment: helper.finish_vec(2usize, None, self.seqment)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtTextXTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            font: u32,
            size: f64,
            stroke: bool,
            fill: bool,
            h_scale: f64,
            read_direction: i32,
            char_direction: i32,
            weight: super::CtTextWeightXType,
            italic: bool,
            content: Vec<super::CtTextXTypeContent>,
            state__: Box<CtTextXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtTextXTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtTextXTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtTextXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut font: Option<u32> = None;
                let mut size: Option<f64> = None;
                let mut stroke: Option<bool> = None;
                let mut fill: Option<bool> = None;
                let mut h_scale: Option<f64> = None;
                let mut read_direction: Option<i32> = None;
                let mut char_direction: Option<i32> = None;
                let mut weight: Option<super::CtTextWeightXType> = None;
                let mut italic: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Font")
                    ) {
                        helper.read_attrib(&mut font, b"Font", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Size")
                    ) {
                        helper.read_attrib(&mut size, b"Size", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Stroke")
                    ) {
                        helper.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Fill")
                    ) {
                        helper.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"HScale")
                    ) {
                        helper.read_attrib(&mut h_scale, b"HScale", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ReadDirection")
                    ) {
                        helper.read_attrib(&mut read_direction, b"ReadDirection", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CharDirection")
                    ) {
                        helper.read_attrib(&mut char_direction, b"CharDirection", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Weight")
                    ) {
                        helper.read_attrib(&mut weight, b"Weight", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Italic")
                    ) {
                        helper.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(super::CtTextXType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(super::CtTextXType::default_line_width),
                    cap: cap.unwrap_or_else(super::CtTextXType::default_cap),
                    join: join.unwrap_or_else(super::CtTextXType::default_join),
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtTextXType::default_miter_limit),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtTextXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(super::CtTextXType::default_alpha),
                    font: font.ok_or_else(|| ErrorKind::MissingAttribute("Font".into()))?,
                    size: size.ok_or_else(|| ErrorKind::MissingAttribute("Size".into()))?,
                    stroke: stroke.unwrap_or_else(super::CtTextXType::default_stroke),
                    fill: fill.unwrap_or_else(super::CtTextXType::default_fill),
                    h_scale: h_scale.unwrap_or_else(super::CtTextXType::default_h_scale),
                    read_direction: read_direction
                        .unwrap_or_else(super::CtTextXType::default_read_direction),
                    char_direction: char_direction
                        .unwrap_or_else(super::CtTextXType::default_char_direction),
                    weight: weight.unwrap_or_else(super::CtTextXType::default_weight),
                    italic: italic.unwrap_or_else(super::CtTextXType::default_italic),
                    content: Vec::new(),
                    state__: Box::new(CtTextXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtTextXTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtTextXTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::CtTextXTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtTextXTypeContent>,
                fallback: &mut Option<CtTextXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtTextXType> for CtTextXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextXType> {
                use CtTextXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = <super::CtTextXTypeContent as WithDeserializer>::init(
                                helper, event,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtTextXType, Error> {
                let state = replace(&mut *self.state__, CtTextXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtTextXType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    font: self.font,
                    size: self.size,
                    stroke: self.stroke,
                    fill: self.fill,
                    h_scale: self.h_scale,
                    read_direction: self.read_direction,
                    char_direction: self.char_direction,
                    weight: self.weight,
                    italic: self.italic,
                    content: helper.finish_vec(1usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtTextXTypeContentDeserializer {
            state__: Box<CtTextXTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtTextXTypeContentDeserializerState {
            Init__,
            Actions(
                Option<super::CtGraphicUnitActionsXElementType>,
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<super::CtGraphicUnitClipsXElementType>,
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            FillColor(
                Option<super::CtColorXType>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            StrokeColor(
                Option<super::CtColorXType>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            CgTransform(
                Option<super::CtCgTransformXType>,
                Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
                Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
            ),
            TextCode(
                Option<super::CtTextTextCodeXElementType>,
                Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtTextXTypeContent),
            Unknown__,
        }
        impl CtTextXTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Actions")
                    ) {
                        let output =
                            <super::CtGraphicUnitActionsXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_actions(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Clips")
                    ) {
                        let output =
                            <super::CtGraphicUnitClipsXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_clips(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"FillColor")
                    ) {
                        let output =
                            <super::CtColorXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_fill_color(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"StrokeColor")
                    ) {
                        let output =
                            <super::CtColorXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_stroke_color(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CGTransform")
                    ) {
                        let output =
                            <super::CtCgTransformXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_cg_transform(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextCode")
                    ) {
                        let output = <super::CtTextTextCodeXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_text_code(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtTextXTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtTextXTypeContentDeserializerState,
            ) -> Result<super::CtTextXTypeContent, Error> {
                use CtTextXTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Actions(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_actions(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::Actions(
                            helper.finish_element("Actions", values)?,
                        ))
                    }
                    S::Clips(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_clips(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::Clips(
                            helper.finish_element("Clips", values)?,
                        ))
                    }
                    S::FillColor(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_fill_color(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::FillColor(
                            helper.finish_element("FillColor", values)?,
                        ))
                    }
                    S::StrokeColor(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_stroke_color(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::StrokeColor(
                            helper.finish_element("StrokeColor", values)?,
                        ))
                    }
                    S::CgTransform(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_cg_transform(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::CgTransform(
                            helper.finish_element("CGTransform", values)?,
                        ))
                    }
                    S::TextCode(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_code(&mut values, value)?;
                        }
                        Ok(super::CtTextXTypeContent::TextCode(
                            helper.finish_element("TextCode", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_actions(
                values: &mut Option<super::CtGraphicUnitActionsXElementType>,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_clips(
                values: &mut Option<super::CtGraphicUnitClipsXElementType>,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fill_color(
                values: &mut Option<super::CtColorXType>,
                value: super::CtColorXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_stroke_color(
                values: &mut Option<super::CtColorXType>,
                value: super::CtColorXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_cg_transform(
                values: &mut Option<super::CtCgTransformXType>,
                value: super::CtCgTransformXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CGTransform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text_code(
                values: &mut Option<super::CtTextTextCodeXElementType>,
                value: super::CtTextTextCodeXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextCode",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtGraphicUnitActionsXElementType>,
                fallback: Option<
                    <super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_actions(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_actions(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Actions(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Actions(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtGraphicUnitClipsXElementType>,
                fallback: Option<
                    <super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_clips(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_clips(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Clips(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Clips(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtColorXType>,
                fallback: Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtColorXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_fill_color(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fill_color(&mut values, data)?;
                        let data = Self::finish_state(helper, S::FillColor(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::FillColor(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtColorXType>,
                fallback: Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtColorXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_stroke_color(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_stroke_color(&mut values, data)?;
                        let data = Self::finish_state(helper, S::StrokeColor(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::StrokeColor(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_cg_transform<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtCgTransformXType>,
                fallback: Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtCgTransformXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_cg_transform(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_cg_transform(&mut values, data)?;
                        let data = Self::finish_state(helper, S::CgTransform(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CgTransform(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_text_code<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtTextTextCodeXElementType>,
                fallback: Option<
                    <super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtTextTextCodeXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtTextXTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_code(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_code(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextCode(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextCode(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtTextXTypeContent> for CtTextXTypeContentDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextXTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtTextXTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(&*x.state__, CtTextXTypeContentDeserializerState::Init__) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextXTypeContent> {
                use CtTextXTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Clips(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::FillColor(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::StrokeColor(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CgTransform(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cg_transform(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TextCode(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_code(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Actions(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Clips(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::FillColor(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::StrokeColor(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CgTransform(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CGTransform",
                                false,
                            )?;
                            match self.handle_cg_transform(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::TextCode(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextCode",
                                false,
                            )?;
                            match self.handle_text_code(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtTextXTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct PageXElementTypeDeserializer {
            template: Vec<super::PageTemplateXElementType>,
            page_res: Vec<String>,
            area: Option<super::super::definition::CtPageAreaXType>,
            content: Option<super::PageContentXElementType>,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            state__: Box<PageXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageXElementTypeDeserializerState {
            Init__,
            Template(Option<<super::PageTemplateXElementType as WithDeserializer>::Deserializer>),
            PageRes(Option<<String as WithDeserializer>::Deserializer>),
            Area(
                Option<
                    <super::super::definition::CtPageAreaXType as WithDeserializer>::Deserializer,
                >,
            ),
            Content(Option<<super::PageContentXElementType as WithDeserializer>::Deserializer>),
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl PageXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    template: Vec::new(),
                    page_res: Vec::new(),
                    area: None,
                    content: None,
                    actions: None,
                    state__: Box::new(PageXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use PageXElementTypeDeserializerState as S;
                match state {
                    S::Template(Some(deserializer)) => {
                        self.store_template(deserializer.finish(helper)?)?
                    }
                    S::PageRes(Some(deserializer)) => {
                        self.store_page_res(deserializer.finish(helper)?)?
                    }
                    S::Area(Some(deserializer)) => self.store_area(deserializer.finish(helper)?)?,
                    S::Content(Some(deserializer)) => {
                        self.store_content(deserializer.finish(helper)?)?
                    }
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_template(
                &mut self,
                value: super::PageTemplateXElementType,
            ) -> Result<(), Error> {
                self.template.push(value);
                Ok(())
            }
            fn store_page_res(&mut self, value: String) -> Result<(), Error> {
                self.page_res.push(value);
                Ok(())
            }
            fn store_area(
                &mut self,
                value: super::super::definition::CtPageAreaXType,
            ) -> Result<(), Error> {
                if self.area.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Area")))?;
                }
                self.area = Some(value);
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::PageContentXElementType,
            ) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Content",
                    )))?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn handle_template<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageTemplateXElementType>,
                fallback: &mut Option<PageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Template(None));
                    *self.state__ = S::PageRes(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_template(data)?;
                        *self.state__ = S::Template(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Template(Some(deserializer)));
                        *self.state__ = S::Template(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_page_res<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<PageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::PageRes(None));
                    *self.state__ = S::Area(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_page_res(data)?;
                        *self.state__ = S::PageRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::PageRes(Some(deserializer)));
                        *self.state__ = S::PageRes(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_area<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::definition::CtPageAreaXType>,
                fallback: &mut Option<PageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Area(None));
                    *self.state__ = S::Content(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_area(data)?;
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Area(Some(deserializer)));
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageContentXElementType>,
                fallback: &mut Option<PageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Content(None));
                    *self.state__ = S::Actions(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Actions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Content(Some(deserializer)));
                        *self.state__ = S::Actions(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<PageXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageXElementType> for PageXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageXElementType> {
                use PageXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Template(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_template(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PageRes(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Area(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Template(None);
                            event
                        }
                        (S::Template(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Template",
                                false,
                            )?;
                            match self.handle_template(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::PageRes(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageRes",
                                false,
                            )?;
                            match self.handle_page_res(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Area(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Area",
                                false,
                            )?;
                            match self.handle_area(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Content",
                                true,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageXElementType {
                    template: self.template,
                    page_res: self.page_res,
                    area: self.area,
                    content: self.content,
                    actions: self.actions,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtAxialShdSegmentXElementTypeDeserializer {
            position: Option<f64>,
            color: Option<super::CtColorXType>,
            state__: Box<CtAxialShdSegmentXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtAxialShdSegmentXElementTypeDeserializerState {
            Init__,
            Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtAxialShdSegmentXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut position: Option<f64> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Position")
                    ) {
                        helper.read_attrib(&mut position, b"Position", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    position: position,
                    color: None,
                    state__: Box::new(CtAxialShdSegmentXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtAxialShdSegmentXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtAxialShdSegmentXElementTypeDeserializerState as S;
                match state {
                    S::Color(Some(deserializer)) => {
                        self.store_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Color",
                    )))?;
                }
                self.color = Some(value);
                Ok(())
            }
            fn handle_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtAxialShdSegmentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtAxialShdSegmentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Color(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Color(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtAxialShdSegmentXElementType>
            for CtAxialShdSegmentXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAxialShdSegmentXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtAxialShdSegmentXElementType> {
                use CtAxialShdSegmentXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Color(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Color(None);
                            event
                        }
                        (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Color",
                                true,
                            )?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtAxialShdSegmentXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtAxialShdSegmentXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtAxialShdSegmentXElementType {
                    position: self.position,
                    color: Box::new(helper.finish_element("Color", self.color)?),
                })
            }
        }
        #[derive(Debug)]
        pub struct CtClipAreaXElementTypeDeserializer {
            draw_param: Option<u32>,
            ctm: Option<String>,
            content: Option<super::CtClipAreaXElementTypeContent>,
            state__: Box<CtClipAreaXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtClipAreaXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::CtClipAreaXElementTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtClipAreaXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut draw_param: Option<u32> = None;
                let mut ctm: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    draw_param: draw_param,
                    ctm: ctm,
                    content: None,
                    state__: Box::new(CtClipAreaXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtClipAreaXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtClipAreaXElementTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtClipAreaXElementTypeContent,
            ) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtClipAreaXElementTypeContent>,
                fallback: &mut Option<CtClipAreaXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtClipAreaXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(ElementHandlerOutput::from_event_end(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtClipAreaXElementType> for CtClipAreaXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipAreaXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipAreaXElementType> {
                use CtClipAreaXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output =
                                <super::CtClipAreaXElementTypeContent as WithDeserializer>::init(
                                    helper, event,
                                )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtClipAreaXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtClipAreaXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtClipAreaXElementType {
                    draw_param: self.draw_param,
                    ctm: self.ctm,
                    content: helper.finish_content(self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtClipAreaXElementTypeContentDeserializer {
            state__: Box<CtClipAreaXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtClipAreaXElementTypeContentDeserializerState {
            Init__,
            Path(
                Option<super::CtPathXType>,
                Option<<super::CtPathXType as WithDeserializer>::Deserializer>,
                Option<<super::CtPathXType as WithDeserializer>::Deserializer>,
            ),
            Text(
                Option<super::CtTextXType>,
                Option<<super::CtTextXType as WithDeserializer>::Deserializer>,
                Option<<super::CtTextXType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtClipAreaXElementTypeContent),
            Unknown__,
        }
        impl CtClipAreaXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Path")
                    ) {
                        let output = <super::CtPathXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_path(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Text")
                    ) {
                        let output = <super::CtTextXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_text(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtClipAreaXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtClipAreaXElementTypeContentDeserializerState,
            ) -> Result<super::CtClipAreaXElementTypeContent, Error> {
                use CtClipAreaXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Path(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path(&mut values, value)?;
                        }
                        Ok(super::CtClipAreaXElementTypeContent::Path(
                            helper.finish_element("Path", values)?,
                        ))
                    }
                    S::Text(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text(&mut values, value)?;
                        }
                        Ok(super::CtClipAreaXElementTypeContent::Text(
                            helper.finish_element("Text", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_path(
                values: &mut Option<super::CtPathXType>,
                value: super::CtPathXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Path")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text(
                values: &mut Option<super::CtTextXType>,
                value: super::CtTextXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Text")))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_path<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPathXType>,
                fallback: Option<<super::CtPathXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtPathXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtClipAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Path(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Path(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_text<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtTextXType>,
                fallback: Option<<super::CtTextXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtTextXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtClipAreaXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Text(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Text(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtClipAreaXElementTypeContent>
            for CtClipAreaXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipAreaXElementTypeContent> {
                let deserializer = Self {
                    state__: Box::new(CtClipAreaXElementTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtClipAreaXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtClipAreaXElementTypeContent> {
                use CtClipAreaXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Path(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Text(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Path(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Path",
                                true,
                            )?;
                            match self.handle_path(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Text(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Text",
                                true,
                            )?;
                            match self.handle_text(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtClipAreaXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitActionsXElementTypeDeserializer {
            action: Vec<super::super::definition::CtActionXType>,
            state__: Box<CtGraphicUnitActionsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtGraphicUnitActionsXElementTypeDeserializerState {
            Init__,
            Action(
                Option<<super::super::definition::CtActionXType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtGraphicUnitActionsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    action: Vec::new(),
                    state__: Box::new(CtGraphicUnitActionsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtGraphicUnitActionsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtGraphicUnitActionsXElementTypeDeserializerState as S;
                match state {
                    S::Action(Some(deserializer)) => {
                        self.store_action(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_action(
                &mut self,
                value: super::super::definition::CtActionXType,
            ) -> Result<(), Error> {
                self.action.push(value);
                Ok(())
            }
            fn handle_action<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::definition::CtActionXType>,
                fallback: &mut Option<CtGraphicUnitActionsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGraphicUnitActionsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.action.len() < 1usize {
                        fallback.get_or_insert(S::Action(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Action(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_action(data)?;
                        *self.state__ = S::Action(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Action(Some(deserializer)));
                        *self.state__ = S::Action(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtGraphicUnitActionsXElementType>
            for CtGraphicUnitActionsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitActionsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitActionsXElementType> {
                use CtGraphicUnitActionsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Action(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_action(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Action(None);
                            event
                        }
                        (S::Action(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Action",
                                true,
                            )?;
                            match self.handle_action(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtGraphicUnitActionsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtGraphicUnitActionsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtGraphicUnitActionsXElementType {
                    action: helper.finish_vec(1usize, None, self.action)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitClipsXElementTypeDeserializer {
            clip: Vec<super::CtClipXType>,
            state__: Box<CtGraphicUnitClipsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtGraphicUnitClipsXElementTypeDeserializerState {
            Init__,
            Clip(Option<<super::CtClipXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtGraphicUnitClipsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    clip: Vec::new(),
                    state__: Box::new(CtGraphicUnitClipsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtGraphicUnitClipsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtGraphicUnitClipsXElementTypeDeserializerState as S;
                match state {
                    S::Clip(Some(deserializer)) => self.store_clip(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_clip(&mut self, value: super::CtClipXType) -> Result<(), Error> {
                self.clip.push(value);
                Ok(())
            }
            fn handle_clip<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtClipXType>,
                fallback: &mut Option<CtGraphicUnitClipsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGraphicUnitClipsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.clip.len() < 1usize {
                        fallback.get_or_insert(S::Clip(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Clip(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clip(data)?;
                        *self.state__ = S::Clip(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clip(Some(deserializer)));
                        *self.state__ = S::Clip(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtGraphicUnitClipsXElementType>
            for CtGraphicUnitClipsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitClipsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGraphicUnitClipsXElementType> {
                use CtGraphicUnitClipsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Clip(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clip(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Clip(None);
                            event
                        }
                        (S::Clip(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clip",
                                true,
                            )?;
                            match self.handle_clip(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtGraphicUnitClipsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtGraphicUnitClipsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtGraphicUnitClipsXElementType {
                    clip: helper.finish_vec(1usize, None, self.clip)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtGouraudShdPointXElementTypeDeserializer {
            x: f64,
            y: f64,
            edge_flag: Option<super::CtGouraudShdPointEdgeFlagXType>,
            color: Option<super::CtColorXType>,
            state__: Box<CtGouraudShdPointXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtGouraudShdPointXElementTypeDeserializerState {
            Init__,
            Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtGouraudShdPointXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut x: Option<f64> = None;
                let mut y: Option<f64> = None;
                let mut edge_flag: Option<super::CtGouraudShdPointEdgeFlagXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"X")
                    ) {
                        helper.read_attrib(&mut x, b"X", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"y")
                    ) {
                        helper.read_attrib(&mut y, b"y", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"EdgeFlag")
                    ) {
                        helper.read_attrib(&mut edge_flag, b"EdgeFlag", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    x: x.ok_or_else(|| ErrorKind::MissingAttribute("X".into()))?,
                    y: y.ok_or_else(|| ErrorKind::MissingAttribute("y".into()))?,
                    edge_flag: edge_flag,
                    color: None,
                    state__: Box::new(CtGouraudShdPointXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtGouraudShdPointXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtGouraudShdPointXElementTypeDeserializerState as S;
                match state {
                    S::Color(Some(deserializer)) => {
                        self.store_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Color",
                    )))?;
                }
                self.color = Some(value);
                Ok(())
            }
            fn handle_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtGouraudShdPointXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtGouraudShdPointXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Color(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Color(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtGouraudShdPointXElementType>
            for CtGouraudShdPointXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGouraudShdPointXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtGouraudShdPointXElementType> {
                use CtGouraudShdPointXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Color(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Color(None);
                            event
                        }
                        (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Color",
                                true,
                            )?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtGouraudShdPointXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtGouraudShdPointXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtGouraudShdPointXElementType {
                    x: self.x,
                    y: self.y,
                    edge_flag: self.edge_flag,
                    color: Box::new(helper.finish_element("Color", self.color)?),
                })
            }
        }
        #[derive(Debug)]
        pub struct CtImageBorderXElementTypeDeserializer {
            line_width: f64,
            horizonal_corner_radius: f64,
            vertical_corner_radius: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            border_color: Option<super::CtColorXType>,
            state__: Box<CtImageBorderXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtImageBorderXElementTypeDeserializerState {
            Init__,
            BorderColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtImageBorderXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut line_width: Option<f64> = None;
                let mut horizonal_corner_radius: Option<f64> = None;
                let mut vertical_corner_radius: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"HorizonalCornerRadius")
                    ) {
                        helper.read_attrib(
                            &mut horizonal_corner_radius,
                            b"HorizonalCornerRadius",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"VerticalCornerRadius")
                    ) {
                        helper.read_attrib(
                            &mut vertical_corner_radius,
                            b"VerticalCornerRadius",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    line_width: line_width
                        .unwrap_or_else(super::CtImageBorderXElementType::default_line_width),
                    horizonal_corner_radius: horizonal_corner_radius.unwrap_or_else(
                        super::CtImageBorderXElementType::default_horizonal_corner_radius,
                    ),
                    vertical_corner_radius: vertical_corner_radius.unwrap_or_else(
                        super::CtImageBorderXElementType::default_vertical_corner_radius,
                    ),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtImageBorderXElementType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    border_color: None,
                    state__: Box::new(CtImageBorderXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtImageBorderXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtImageBorderXElementTypeDeserializerState as S;
                match state {
                    S::BorderColor(Some(deserializer)) => {
                        self.store_border_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_border_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.border_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"BorderColor",
                    )))?;
                }
                self.border_color = Some(value);
                Ok(())
            }
            fn handle_border_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtImageBorderXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtImageBorderXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::BorderColor(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_border_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::BorderColor(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtImageBorderXElementType>
            for CtImageBorderXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtImageBorderXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtImageBorderXElementType> {
                use CtImageBorderXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::BorderColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_border_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::BorderColor(None);
                            event
                        }
                        (S::BorderColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"BorderColor",
                                true,
                            )?;
                            match self.handle_border_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtImageBorderXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtImageBorderXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtImageBorderXElementType {
                    line_width: self.line_width,
                    horizonal_corner_radius: self.horizonal_corner_radius,
                    vertical_corner_radius: self.vertical_corner_radius,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    border_color: self.border_color,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtLaGouraudShdPointXElementTypeDeserializer {
            x: Option<f64>,
            y: Option<f64>,
            color: Option<super::CtColorXType>,
            state__: Box<CtLaGouraudShdPointXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtLaGouraudShdPointXElementTypeDeserializerState {
            Init__,
            Color(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtLaGouraudShdPointXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut x: Option<f64> = None;
                let mut y: Option<f64> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"X")
                    ) {
                        helper.read_attrib(&mut x, b"X", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"y")
                    ) {
                        helper.read_attrib(&mut y, b"y", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    x: x,
                    y: y,
                    color: None,
                    state__: Box::new(CtLaGouraudShdPointXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtLaGouraudShdPointXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtLaGouraudShdPointXElementTypeDeserializerState as S;
                match state {
                    S::Color(Some(deserializer)) => {
                        self.store_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Color",
                    )))?;
                }
                self.color = Some(value);
                Ok(())
            }
            fn handle_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtLaGouraudShdPointXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtLaGouraudShdPointXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Color(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Color(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtLaGouraudShdPointXElementType>
            for CtLaGouraudShdPointXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLaGouraudShdPointXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtLaGouraudShdPointXElementType> {
                use CtLaGouraudShdPointXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Color(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Color(None);
                            event
                        }
                        (S::Color(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Color",
                                true,
                            )?;
                            match self.handle_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtLaGouraudShdPointXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtLaGouraudShdPointXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtLaGouraudShdPointXElementType {
                    x: self.x,
                    y: self.y,
                    color: Box::new(helper.finish_element("Color", self.color)?),
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockTextObjectXElementTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            font: u32,
            size: f64,
            stroke: bool,
            fill: bool,
            h_scale: f64,
            read_direction: i32,
            char_direction: i32,
            weight: super::CtTextWeightXType,
            italic: bool,
            id: u32,
            content: Vec<super::CtPageBlockTextObjectXElementTypeContent>,
            state__: Box<CtPageBlockTextObjectXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockTextObjectXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(
                <super::CtPageBlockTextObjectXElementTypeContent as WithDeserializer>::Deserializer,
            ),
            Unknown__,
        }
        impl CtPageBlockTextObjectXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut font: Option<u32> = None;
                let mut size: Option<f64> = None;
                let mut stroke: Option<bool> = None;
                let mut fill: Option<bool> = None;
                let mut h_scale: Option<f64> = None;
                let mut read_direction: Option<i32> = None;
                let mut char_direction: Option<i32> = None;
                let mut weight: Option<super::CtTextWeightXType> = None;
                let mut italic: Option<bool> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Font")
                    ) {
                        helper.read_attrib(&mut font, b"Font", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Size")
                    ) {
                        helper.read_attrib(&mut size, b"Size", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Stroke")
                    ) {
                        helper.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Fill")
                    ) {
                        helper.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"HScale")
                    ) {
                        helper.read_attrib(&mut h_scale, b"HScale", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ReadDirection")
                    ) {
                        helper.read_attrib(&mut read_direction, b"ReadDirection", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CharDirection")
                    ) {
                        helper.read_attrib(&mut char_direction, b"CharDirection", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Weight")
                    ) {
                        helper.read_attrib(&mut weight, b"Weight", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Italic")
                    ) {
                        helper.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(
                        super::CtPageBlockTextObjectXElementType::default_line_width,
                    ),
                    cap: cap.unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_cap),
                    join: join
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_join),
                    miter_limit: miter_limit.unwrap_or_else(
                        super::CtPageBlockTextObjectXElementType::default_miter_limit,
                    ),
                    dash_offset: dash_offset.unwrap_or_else(
                        super::CtPageBlockTextObjectXElementType::default_dash_offset,
                    ),
                    dash_pattern: dash_pattern,
                    alpha: alpha
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_alpha),
                    font: font.ok_or_else(|| ErrorKind::MissingAttribute("Font".into()))?,
                    size: size.ok_or_else(|| ErrorKind::MissingAttribute("Size".into()))?,
                    stroke: stroke
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_stroke),
                    fill: fill
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_fill),
                    h_scale: h_scale
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_h_scale),
                    read_direction: read_direction.unwrap_or_else(
                        super::CtPageBlockTextObjectXElementType::default_read_direction,
                    ),
                    char_direction: char_direction.unwrap_or_else(
                        super::CtPageBlockTextObjectXElementType::default_char_direction,
                    ),
                    weight: weight
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_weight),
                    italic: italic
                        .unwrap_or_else(super::CtPageBlockTextObjectXElementType::default_italic),
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    content: Vec::new(),
                    state__: Box::new(CtPageBlockTextObjectXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockTextObjectXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtPageBlockTextObjectXElementTypeDeserializerState::Content__(deserializer) =
                    state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtPageBlockTextObjectXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementTypeContent>,
                fallback: &mut Option<CtPageBlockTextObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockTextObjectXElementType>
            for CtPageBlockTextObjectXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementType> {
                use CtPageBlockTextObjectXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: CtPageBlockTextObjectXElementTypeContent as WithDeserializer > :: init (helper , event) ? ;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockTextObjectXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockTextObjectXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockTextObjectXElementType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    font: self.font,
                    size: self.size,
                    stroke: self.stroke,
                    fill: self.fill,
                    h_scale: self.h_scale,
                    read_direction: self.read_direction,
                    char_direction: self.char_direction,
                    weight: self.weight,
                    italic: self.italic,
                    id: self.id,
                    content: helper.finish_vec(1usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockTextObjectXElementTypeContentDeserializer {
            state__: Box<CtPageBlockTextObjectXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtPageBlockTextObjectXElementTypeContentDeserializerState {
            Init__,
            Actions(
                Option<super::CtGraphicUnitActionsXElementType>,
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<super::CtGraphicUnitClipsXElementType>,
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            FillColor(
                Option<super::CtColorXType>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            StrokeColor(
                Option<super::CtColorXType>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            CgTransform(
                Option<super::CtCgTransformXType>,
                Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
                Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
            ),
            TextCode(
                Option<super::CtTextTextCodeXElementType>,
                Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
                Option<<super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__(super::CtPageBlockTextObjectXElementTypeContent),
            Unknown__,
        }
        impl CtPageBlockTextObjectXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Actions")
                    ) {
                        let output =
                            <super::CtGraphicUnitActionsXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_actions(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Clips")
                    ) {
                        let output =
                            <super::CtGraphicUnitClipsXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_clips(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"FillColor")
                    ) {
                        let output =
                            <super::CtColorXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_fill_color(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"StrokeColor")
                    ) {
                        let output =
                            <super::CtColorXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_stroke_color(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CGTransform")
                    ) {
                        let output =
                            <super::CtCgTransformXType as WithDeserializer>::init(helper, event)?;
                        return self.handle_cg_transform(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextCode")
                    ) {
                        let output = <super::CtTextTextCodeXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_text_code(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtPageBlockTextObjectXElementTypeContentDeserializerState,
            ) -> Result<super::CtPageBlockTextObjectXElementTypeContent, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::Actions(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_actions(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockTextObjectXElementTypeContent::Actions(
                            helper.finish_element("Actions", values)?,
                        ))
                    }
                    S::Clips(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_clips(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockTextObjectXElementTypeContent::Clips(
                            helper.finish_element("Clips", values)?,
                        ))
                    }
                    S::FillColor(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_fill_color(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockTextObjectXElementTypeContent::FillColor(
                            helper.finish_element("FillColor", values)?,
                        ))
                    }
                    S::StrokeColor(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_stroke_color(&mut values, value)?;
                        }
                        Ok(
                            super::CtPageBlockTextObjectXElementTypeContent::StrokeColor(
                                helper.finish_element("StrokeColor", values)?,
                            ),
                        )
                    }
                    S::CgTransform(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_cg_transform(&mut values, value)?;
                        }
                        Ok(
                            super::CtPageBlockTextObjectXElementTypeContent::CgTransform(
                                helper.finish_element("CGTransform", values)?,
                            ),
                        )
                    }
                    S::TextCode(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_code(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockTextObjectXElementTypeContent::TextCode(
                            helper.finish_element("TextCode", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_actions(
                values: &mut Option<super::CtGraphicUnitActionsXElementType>,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_clips(
                values: &mut Option<super::CtGraphicUnitClipsXElementType>,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fill_color(
                values: &mut Option<super::CtColorXType>,
                value: super::CtColorXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_stroke_color(
                values: &mut Option<super::CtColorXType>,
                value: super::CtColorXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_cg_transform(
                values: &mut Option<super::CtCgTransformXType>,
                value: super::CtCgTransformXType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CGTransform",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_text_code(
                values: &mut Option<super::CtTextTextCodeXElementType>,
                value: super::CtTextTextCodeXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextCode",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtGraphicUnitActionsXElementType>,
                fallback: Option<
                    <super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_actions(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_actions(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Actions(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Actions(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtGraphicUnitClipsXElementType>,
                fallback: Option<
                    <super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_clips(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_clips(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Clips(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Clips(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtColorXType>,
                fallback: Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtColorXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_fill_color(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fill_color(&mut values, data)?;
                        let data = Self::finish_state(helper, S::FillColor(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::FillColor(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtColorXType>,
                fallback: Option<<super::CtColorXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtColorXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_stroke_color(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_stroke_color(&mut values, data)?;
                        let data = Self::finish_state(helper, S::StrokeColor(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::StrokeColor(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_cg_transform<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtCgTransformXType>,
                fallback: Option<<super::CtCgTransformXType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::CtCgTransformXType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_cg_transform(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_cg_transform(&mut values, data)?;
                        let data = Self::finish_state(helper, S::CgTransform(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CgTransform(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_text_code<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtTextTextCodeXElementType>,
                fallback: Option<
                    <super::CtTextTextCodeXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtTextTextCodeXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_code(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_code(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextCode(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextCode(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockTextObjectXElementTypeContent>
            for CtPageBlockTextObjectXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementTypeContent>
            {
                let deserializer = Self {
                    state__: Box::new(
                        CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__,
                    ),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtPageBlockTextObjectXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockTextObjectXElementTypeContent>
            {
                use CtPageBlockTextObjectXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Clips(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::FillColor(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::StrokeColor(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CgTransform(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cg_transform(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::TextCode(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_code(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::Actions(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Clips(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::FillColor(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::StrokeColor(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CgTransform(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CGTransform",
                                false,
                            )?;
                            match self.handle_cg_transform(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::TextCode(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextCode",
                                false,
                            )?;
                            match self.handle_text_code(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockTextObjectXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPathObjectXElementTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            stroke: bool,
            fill: bool,
            rule: super::CtPathRuleXType,
            id: u32,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            stroke_color: Option<super::CtColorXType>,
            fill_color: Option<super::CtColorXType>,
            abbreviated_data: Option<String>,
            state__: Box<CtPageBlockPathObjectXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockPathObjectXElementTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            StrokeColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            FillColor(Option<<super::CtColorXType as WithDeserializer>::Deserializer>),
            AbbreviatedData(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtPageBlockPathObjectXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut stroke: Option<bool> = None;
                let mut fill: Option<bool> = None;
                let mut rule: Option<super::CtPathRuleXType> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Stroke")
                    ) {
                        helper.read_attrib(&mut stroke, b"Stroke", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Fill")
                    ) {
                        helper.read_attrib(&mut fill, b"Fill", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Rule")
                    ) {
                        helper.read_attrib(&mut rule, b"Rule", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(
                        super::CtPageBlockPathObjectXElementType::default_line_width,
                    ),
                    cap: cap.unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_cap),
                    join: join
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_join),
                    miter_limit: miter_limit.unwrap_or_else(
                        super::CtPageBlockPathObjectXElementType::default_miter_limit,
                    ),
                    dash_offset: dash_offset.unwrap_or_else(
                        super::CtPageBlockPathObjectXElementType::default_dash_offset,
                    ),
                    dash_pattern: dash_pattern,
                    alpha: alpha
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_alpha),
                    stroke: stroke
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_stroke),
                    fill: fill
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_fill),
                    rule: rule
                        .unwrap_or_else(super::CtPageBlockPathObjectXElementType::default_rule),
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    actions: None,
                    clips: None,
                    stroke_color: None,
                    fill_color: None,
                    abbreviated_data: None,
                    state__: Box::new(CtPageBlockPathObjectXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockPathObjectXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    S::StrokeColor(Some(deserializer)) => {
                        self.store_stroke_color(deserializer.finish(helper)?)?
                    }
                    S::FillColor(Some(deserializer)) => {
                        self.store_fill_color(deserializer.finish(helper)?)?
                    }
                    S::AbbreviatedData(Some(deserializer)) => {
                        self.store_abbreviated_data(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn store_stroke_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.stroke_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                self.stroke_color = Some(value);
                Ok(())
            }
            fn store_fill_color(&mut self, value: super::CtColorXType) -> Result<(), Error> {
                if self.fill_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                self.fill_color = Some(value);
                Ok(())
            }
            fn store_abbreviated_data(&mut self, value: String) -> Result<(), Error> {
                if self.abbreviated_data.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"AbbreviatedData",
                    )))?;
                }
                self.abbreviated_data = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::StrokeColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::StrokeColor(None));
                    *self.state__ = S::FillColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_stroke_color(data)?;
                        *self.state__ = S::FillColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::StrokeColor(Some(deserializer)));
                        *self.state__ = S::FillColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorXType>,
                fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FillColor(None));
                    *self.state__ = S::AbbreviatedData(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fill_color(data)?;
                        *self.state__ = S::AbbreviatedData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FillColor(Some(deserializer)));
                        *self.state__ = S::AbbreviatedData(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_abbreviated_data<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtPageBlockPathObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::AbbreviatedData(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_abbreviated_data(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::AbbreviatedData(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockPathObjectXElementType>
            for CtPageBlockPathObjectXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPathObjectXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPathObjectXElementType> {
                use CtPageBlockPathObjectXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FillColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::AbbreviatedData(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_abbreviated_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::AbbreviatedData(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"AbbreviatedData",
                                false,
                            )?;
                            match self.handle_abbreviated_data(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockPathObjectXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockPathObjectXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockPathObjectXElementType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    stroke: self.stroke,
                    fill: self.fill,
                    rule: self.rule,
                    id: self.id,
                    actions: self.actions,
                    clips: self.clips,
                    stroke_color: self.stroke_color,
                    fill_color: self.fill_color,
                    abbreviated_data: helper
                        .finish_element("AbbreviatedData", self.abbreviated_data)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockImageObjectXElementTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            resource_id: u32,
            substitution: Option<u32>,
            image_mask: Option<u32>,
            id: u32,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            border: Option<super::CtImageBorderXElementType>,
            state__: Box<CtPageBlockImageObjectXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockImageObjectXElementTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            Border(Option<<super::CtImageBorderXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtPageBlockImageObjectXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut resource_id: Option<u32> = None;
                let mut substitution: Option<u32> = None;
                let mut image_mask: Option<u32> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Substitution")
                    ) {
                        helper.read_attrib(&mut substitution, b"Substitution", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ImageMask")
                    ) {
                        helper.read_attrib(&mut image_mask, b"ImageMask", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible
                        .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_visible),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(
                        super::CtPageBlockImageObjectXElementType::default_line_width,
                    ),
                    cap: cap.unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_cap),
                    join: join
                        .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_join),
                    miter_limit: miter_limit.unwrap_or_else(
                        super::CtPageBlockImageObjectXElementType::default_miter_limit,
                    ),
                    dash_offset: dash_offset.unwrap_or_else(
                        super::CtPageBlockImageObjectXElementType::default_dash_offset,
                    ),
                    dash_pattern: dash_pattern,
                    alpha: alpha
                        .unwrap_or_else(super::CtPageBlockImageObjectXElementType::default_alpha),
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    substitution: substitution,
                    image_mask: image_mask,
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    actions: None,
                    clips: None,
                    border: None,
                    state__: Box::new(CtPageBlockImageObjectXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockImageObjectXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPageBlockImageObjectXElementTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    S::Border(Some(deserializer)) => {
                        self.store_border(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn store_border(
                &mut self,
                value: super::CtImageBorderXElementType,
            ) -> Result<(), Error> {
                if self.border.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Border",
                    )))?;
                }
                self.border = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockImageObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockImageObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::Border(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::Border(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::Border(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_border<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtImageBorderXElementType>,
                fallback: &mut Option<CtPageBlockImageObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockImageObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Border(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_border(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Border(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockImageObjectXElementType>
            for CtPageBlockImageObjectXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockImageObjectXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockImageObjectXElementType> {
                use CtPageBlockImageObjectXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Border(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_border(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Border(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Border",
                                true,
                            )?;
                            match self.handle_border(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockImageObjectXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockImageObjectXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockImageObjectXElementType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    resource_id: self.resource_id,
                    substitution: self.substitution,
                    image_mask: self.image_mask,
                    id: self.id,
                    actions: self.actions,
                    clips: self.clips,
                    border: self.border,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockCompositeObjectXElementTypeDeserializer {
            boundary: String,
            name: Option<String>,
            visible: bool,
            ctm: Option<String>,
            draw_param: Option<u32>,
            line_width: f64,
            cap: super::CtGraphicUnitCapXType,
            join: super::CtGraphicUnitJoinXType,
            miter_limit: f64,
            dash_offset: f64,
            dash_pattern: Option<String>,
            alpha: i32,
            resource_id: u32,
            id: u32,
            actions: Option<super::CtGraphicUnitActionsXElementType>,
            clips: Option<super::CtGraphicUnitClipsXElementType>,
            state__: Box<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockCompositeObjectXElementTypeDeserializerState {
            Init__,
            Actions(
                Option<<super::CtGraphicUnitActionsXElementType as WithDeserializer>::Deserializer>,
            ),
            Clips(
                Option<<super::CtGraphicUnitClipsXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtPageBlockCompositeObjectXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut boundary: Option<String> = None;
                let mut name: Option<String> = None;
                let mut visible: Option<bool> = None;
                let mut ctm: Option<String> = None;
                let mut draw_param: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut cap: Option<super::CtGraphicUnitCapXType> = None;
                let mut join: Option<super::CtGraphicUnitJoinXType> = None;
                let mut miter_limit: Option<f64> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut alpha: Option<i32> = None;
                let mut resource_id: Option<u32> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Visible")
                    ) {
                        helper.read_attrib(&mut visible, b"Visible", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CTM")
                    ) {
                        helper.read_attrib(&mut ctm, b"CTM", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Alpha")
                    ) {
                        helper.read_attrib(&mut alpha, b"Alpha", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ResourceID")
                    ) {
                        helper.read_attrib(&mut resource_id, b"ResourceID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    name: name,
                    visible: visible.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_visible,
                    ),
                    ctm: ctm,
                    draw_param: draw_param,
                    line_width: line_width.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_line_width,
                    ),
                    cap: cap
                        .unwrap_or_else(super::CtPageBlockCompositeObjectXElementType::default_cap),
                    join: join.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_join,
                    ),
                    miter_limit: miter_limit.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_miter_limit,
                    ),
                    dash_offset: dash_offset.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_dash_offset,
                    ),
                    dash_pattern: dash_pattern,
                    alpha: alpha.unwrap_or_else(
                        super::CtPageBlockCompositeObjectXElementType::default_alpha,
                    ),
                    resource_id: resource_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("ResourceID".into()))?,
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    actions: None,
                    clips: None,
                    state__: Box::new(
                        CtPageBlockCompositeObjectXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockCompositeObjectXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
                match state {
                    S::Actions(Some(deserializer)) => {
                        self.store_actions(deserializer.finish(helper)?)?
                    }
                    S::Clips(Some(deserializer)) => {
                        self.store_clips(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_actions(
                &mut self,
                value: super::CtGraphicUnitActionsXElementType,
            ) -> Result<(), Error> {
                if self.actions.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Actions",
                    )))?;
                }
                self.actions = Some(value);
                Ok(())
            }
            fn store_clips(
                &mut self,
                value: super::CtGraphicUnitClipsXElementType,
            ) -> Result<(), Error> {
                if self.clips.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Clips",
                    )))?;
                }
                self.clips = Some(value);
                Ok(())
            }
            fn handle_actions<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitActionsXElementType>,
                fallback: &mut Option<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Actions(None));
                    *self.state__ = S::Clips(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_actions(data)?;
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Actions(Some(deserializer)));
                        *self.state__ = S::Clips(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_clips<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtGraphicUnitClipsXElementType>,
                fallback: &mut Option<CtPageBlockCompositeObjectXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Clips(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_clips(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Clips(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockCompositeObjectXElementType>
            for CtPageBlockCompositeObjectXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockCompositeObjectXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockCompositeObjectXElementType>
            {
                use CtPageBlockCompositeObjectXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Actions(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Actions(None);
                            event
                        }
                        (S::Actions(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Actions",
                                true,
                            )?;
                            match self.handle_actions(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Clips(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Clips",
                                true,
                            )?;
                            match self.handle_clips(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockCompositeObjectXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockCompositeObjectXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockCompositeObjectXElementType {
                    boundary: self.boundary,
                    name: self.name,
                    visible: self.visible,
                    ctm: self.ctm,
                    draw_param: self.draw_param,
                    line_width: self.line_width,
                    cap: self.cap,
                    join: self.join,
                    miter_limit: self.miter_limit,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    alpha: self.alpha,
                    resource_id: self.resource_id,
                    id: self.id,
                    actions: self.actions,
                    clips: self.clips,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPageBlockXElementTypeDeserializer {
            id: u32,
            content: Vec<super::CtPageBlockPageBlockXElementTypeContent>,
            state__: Box<CtPageBlockPageBlockXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPageBlockPageBlockXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(
                <super::CtPageBlockPageBlockXElementTypeContent as WithDeserializer>::Deserializer,
            ),
            Unknown__,
        }
        impl CtPageBlockPageBlockXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    content: Vec::new(),
                    state__: Box::new(CtPageBlockPageBlockXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPageBlockPageBlockXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtPageBlockPageBlockXElementTypeDeserializerState::Content__(deserializer) =
                    state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtPageBlockPageBlockXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementTypeContent>,
                fallback: &mut Option<CtPageBlockPageBlockXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockPageBlockXElementType>
            for CtPageBlockPageBlockXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementType> {
                use CtPageBlockPageBlockXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: CtPageBlockPageBlockXElementTypeContent as WithDeserializer > :: init (helper , event) ? ;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockPageBlockXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPageBlockPageBlockXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPageBlockPageBlockXElementType {
                    id: self.id,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPageBlockXElementTypeContentDeserializer {
            state__: Box<CtPageBlockPageBlockXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtPageBlockPageBlockXElementTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: CtPageBlockTextObjectXElementType > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: CtPageBlockPathObjectXElementType > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: CtPageBlockImageObjectXElementType > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: CtPageBlockCompositeObjectXElementType > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: CtPageBlockPageBlockXElementType > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: CtPageBlockPageBlockXElementTypeContent) , Unknown__ , }
        impl CtPageBlockPageBlockXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output =
                            <super::CtPageBlockTextObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output =
                            <super::CtPageBlockPathObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output =
                            <super::CtPageBlockImageObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output =
                            <super::CtPageBlockPageBlockXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtPageBlockPageBlockXElementTypeContentDeserializerState,
            ) -> Result<super::CtPageBlockPageBlockXElementTypeContent, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockPageBlockXElementTypeContent::TextObject(
                            helper.finish_element("TextObject", values)?,
                        ))
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockPageBlockXElementTypeContent::PathObject(
                            helper.finish_element("PathObject", values)?,
                        ))
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockPageBlockXElementTypeContent::ImageObject(
                            helper.finish_element("ImageObject", values)?,
                        ))
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(
                            super::CtPageBlockPageBlockXElementTypeContent::CompositeObject(
                                helper.finish_element("CompositeObject", values)?,
                            ),
                        )
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(super::CtPageBlockPageBlockXElementTypeContent::PageBlock(
                            helper.finish_element("PageBlock", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::CtPageBlockTextObjectXElementType>,
                value: super::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::CtPageBlockPathObjectXElementType>,
                value: super::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::CtPageBlockImageObjectXElementType>,
                value: super::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
                value: super::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::CtPageBlockPageBlockXElementType>,
                value: super::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockTextObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPathObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockImageObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPageBlockXElementType>,
                fallback: Option<
                    <super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPageBlockPageBlockXElementTypeContent>
            for CtPageBlockPageBlockXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementTypeContent>
            {
                let deserializer = Self {
                    state__: Box::new(
                        CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__,
                    ),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtPageBlockPageBlockXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPageBlockPageBlockXElementTypeContent>
            {
                use CtPageBlockPageBlockXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPageBlockPageBlockXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtPatternCellContentXElementTypeDeserializer {
            thumbnail: Option<u32>,
            content: Vec<super::CtPatternCellContentXElementTypeContent>,
            state__: Box<CtPatternCellContentXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtPatternCellContentXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(
                <super::CtPatternCellContentXElementTypeContent as WithDeserializer>::Deserializer,
            ),
            Unknown__,
        }
        impl CtPatternCellContentXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut thumbnail: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Thumbnail")
                    ) {
                        helper.read_attrib(&mut thumbnail, b"Thumbnail", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    thumbnail: thumbnail,
                    content: Vec::new(),
                    state__: Box::new(CtPatternCellContentXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtPatternCellContentXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtPatternCellContentXElementTypeDeserializerState::Content__(deserializer) =
                    state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::CtPatternCellContentXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtPatternCellContentXElementTypeContent>,
                fallback: &mut Option<CtPatternCellContentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPatternCellContentXElementType>
            for CtPatternCellContentXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternCellContentXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternCellContentXElementType> {
                use CtPatternCellContentXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: CtPatternCellContentXElementTypeContent as WithDeserializer > :: init (helper , event) ? ;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPatternCellContentXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtPatternCellContentXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtPatternCellContentXElementType {
                    thumbnail: self.thumbnail,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtPatternCellContentXElementTypeContentDeserializer {
            state__: Box<CtPatternCellContentXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum CtPatternCellContentXElementTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: CtPageBlockTextObjectXElementType > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: CtPageBlockPathObjectXElementType > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: CtPageBlockImageObjectXElementType > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: CtPageBlockCompositeObjectXElementType > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: CtPageBlockPageBlockXElementType > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: CtPatternCellContentXElementTypeContent) , Unknown__ , }
        impl CtPatternCellContentXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output =
                            <super::CtPageBlockTextObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output =
                            <super::CtPageBlockPathObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output =
                            <super::CtPageBlockImageObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output =
                            <super::CtPageBlockPageBlockXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = CtPatternCellContentXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: CtPatternCellContentXElementTypeContentDeserializerState,
            ) -> Result<super::CtPatternCellContentXElementTypeContent, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(super::CtPatternCellContentXElementTypeContent::TextObject(
                            helper.finish_element("TextObject", values)?,
                        ))
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(super::CtPatternCellContentXElementTypeContent::PathObject(
                            helper.finish_element("PathObject", values)?,
                        ))
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(super::CtPatternCellContentXElementTypeContent::ImageObject(
                            helper.finish_element("ImageObject", values)?,
                        ))
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(
                            super::CtPatternCellContentXElementTypeContent::CompositeObject(
                                helper.finish_element("CompositeObject", values)?,
                            ),
                        )
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(super::CtPatternCellContentXElementTypeContent::PageBlock(
                            helper.finish_element("PageBlock", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::CtPageBlockTextObjectXElementType>,
                value: super::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::CtPageBlockPathObjectXElementType>,
                value: super::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::CtPageBlockImageObjectXElementType>,
                value: super::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
                value: super::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::CtPageBlockPageBlockXElementType>,
                value: super::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockTextObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPathObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockImageObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPageBlockXElementType>,
                fallback: Option<
                    <super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtPatternCellContentXElementTypeContent>
            for CtPatternCellContentXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternCellContentXElementTypeContent>
            {
                let deserializer = Self {
                    state__: Box::new(
                        CtPatternCellContentXElementTypeContentDeserializerState::Init__,
                    ),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            CtPatternCellContentXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtPatternCellContentXElementTypeContent>
            {
                use CtPatternCellContentXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtPatternCellContentXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtTextTextCodeXElementTypeDeserializer {
            x: Option<f64>,
            y: Option<f64>,
            delta_x: Option<String>,
            deltay: Option<String>,
            content: Option<String>,
            state__: Box<CtTextTextCodeXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtTextTextCodeXElementTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl CtTextTextCodeXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut x: Option<f64> = None;
                let mut y: Option<f64> = None;
                let mut delta_x: Option<String> = None;
                let mut deltay: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"X")
                    ) {
                        helper.read_attrib(&mut x, b"X", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"y")
                    ) {
                        helper.read_attrib(&mut y, b"y", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DeltaX")
                    ) {
                        helper.read_attrib(&mut delta_x, b"DeltaX", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Deltay")
                    ) {
                        helper.read_attrib(&mut deltay, b"Deltay", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    x: x,
                    y: y,
                    delta_x: delta_x,
                    deltay: deltay,
                    content: None,
                    state__: Box::new(CtTextTextCodeXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtTextTextCodeXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let CtTextTextCodeXElementTypeDeserializerState::Content__(deserializer) = state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType> {
                use CtTextTextCodeXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(helper)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtTextTextCodeXElementType>
            for CtTextTextCodeXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType> {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(helper, x)?.next(helper, event)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtTextTextCodeXElementType> {
                use CtTextTextCodeXElementTypeDeserializerState as S;
                match replace(&mut *self.state__, S::Unknown__) {
                    S::Unknown__ => unreachable!(),
                    S::Init__ => {
                        let output = ContentDeserializer::init(helper, event)?;
                        self.handle_content(helper, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(helper, event)?;
                        self.handle_content(helper, output)
                    }
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtTextTextCodeXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtTextTextCodeXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtTextTextCodeXElementType {
                    x: self.x,
                    y: self.y,
                    delta_x: self.delta_x,
                    deltay: self.deltay,
                    content: helper.finish_content(self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageTemplateXElementTypeDeserializer {
            template_id: u32,
            z_order: super::PageTemplateZOrderXType,
            state__: Box<PageTemplateXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageTemplateXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl PageTemplateXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut template_id: Option<u32> = None;
                let mut z_order: Option<super::PageTemplateZOrderXType> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"TemplateID")
                    ) {
                        helper.read_attrib(&mut template_id, b"TemplateID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ZOrder")
                    ) {
                        helper.read_attrib(&mut z_order, b"ZOrder", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    template_id: template_id
                        .ok_or_else(|| ErrorKind::MissingAttribute("TemplateID".into()))?,
                    z_order: z_order
                        .unwrap_or_else(super::PageTemplateXElementType::default_z_order),
                    state__: Box::new(PageTemplateXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageTemplateXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::PageTemplateXElementType>
            for PageTemplateXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageTemplateXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageTemplateXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageTemplateXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageTemplateXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageTemplateXElementType {
                    template_id: self.template_id,
                    z_order: self.z_order,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageContentXElementTypeDeserializer {
            layer: Vec<super::PageContentLayerXElementType>,
            state__: Box<PageContentXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageContentXElementTypeDeserializerState {
            Init__,
            Layer(Option<<super::PageContentLayerXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl PageContentXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    layer: Vec::new(),
                    state__: Box::new(PageContentXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageContentXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use PageContentXElementTypeDeserializerState as S;
                match state {
                    S::Layer(Some(deserializer)) => {
                        self.store_layer(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_layer(
                &mut self,
                value: super::PageContentLayerXElementType,
            ) -> Result<(), Error> {
                self.layer.push(value);
                Ok(())
            }
            fn handle_layer<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageContentLayerXElementType>,
                fallback: &mut Option<PageContentXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.layer.len() < 1usize {
                        fallback.get_or_insert(S::Layer(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Layer(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_layer(data)?;
                        *self.state__ = S::Layer(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Layer(Some(deserializer)));
                        *self.state__ = S::Layer(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageContentXElementType>
            for PageContentXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentXElementType> {
                use PageContentXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Layer(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_layer(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Layer(None);
                            event
                        }
                        (S::Layer(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Layer",
                                true,
                            )?;
                            match self.handle_layer(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageContentXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageContentXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageContentXElementType {
                    layer: helper.finish_vec(1usize, None, self.layer)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageContentLayerXElementTypeDeserializer {
            type_: super::CtLayerTypeXType,
            draw_param: Option<u32>,
            id: u32,
            content: Vec<super::PageContentLayerXElementTypeContent>,
            state__: Box<PageContentLayerXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum PageContentLayerXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(
                <super::PageContentLayerXElementTypeContent as WithDeserializer>::Deserializer,
            ),
            Unknown__,
        }
        impl PageContentLayerXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtLayerTypeXType> = None;
                let mut draw_param: Option<u32> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DrawParam")
                    ) {
                        helper.read_attrib(&mut draw_param, b"DrawParam", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.unwrap_or_else(super::PageContentLayerXElementType::default_type_),
                    draw_param: draw_param,
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    content: Vec::new(),
                    state__: Box::new(PageContentLayerXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: PageContentLayerXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let PageContentLayerXElementTypeDeserializerState::Content__(deserializer) =
                    state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::PageContentLayerXElementTypeContent,
            ) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::PageContentLayerXElementTypeContent>,
                fallback: &mut Option<PageContentLayerXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageContentLayerXElementType>
            for PageContentLayerXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentLayerXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentLayerXElementType> {
                use PageContentLayerXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = < super :: PageContentLayerXElementTypeContent as WithDeserializer > :: init (helper , event) ? ;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageContentLayerXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    PageContentLayerXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::PageContentLayerXElementType {
                    type_: self.type_,
                    draw_param: self.draw_param,
                    id: self.id,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct PageContentLayerXElementTypeContentDeserializer {
            state__: Box<PageContentLayerXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum PageContentLayerXElementTypeContentDeserializerState {
            Init__ , TextObject (Option < super :: CtPageBlockTextObjectXElementType > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockTextObjectXElementType as WithDeserializer > :: Deserializer > ,) , PathObject (Option < super :: CtPageBlockPathObjectXElementType > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPathObjectXElementType as WithDeserializer > :: Deserializer > ,) , ImageObject (Option < super :: CtPageBlockImageObjectXElementType > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockImageObjectXElementType as WithDeserializer > :: Deserializer > ,) , CompositeObject (Option < super :: CtPageBlockCompositeObjectXElementType > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer > ,) , PageBlock (Option < super :: CtPageBlockPageBlockXElementType > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > , Option << super :: CtPageBlockPageBlockXElementType as WithDeserializer > :: Deserializer > ,) , Done__ (super :: PageContentLayerXElementTypeContent) , Unknown__ , }
        impl PageContentLayerXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"TextObject")
                    ) {
                        let output =
                            <super::CtPageBlockTextObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_text_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PathObject")
                    ) {
                        let output =
                            <super::CtPageBlockPathObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_path_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ImageObject")
                    ) {
                        let output =
                            <super::CtPageBlockImageObjectXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_image_object(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeObject")
                    ) {
                        let output = < super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_object(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"PageBlock")
                    ) {
                        let output =
                            <super::CtPageBlockPageBlockXElementType as WithDeserializer>::init(
                                helper, event,
                            )?;
                        return self.handle_page_block(helper, Default::default(), None, output);
                    }
                }
                *self.state__ = PageContentLayerXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: PageContentLayerXElementTypeContentDeserializerState,
            ) -> Result<super::PageContentLayerXElementTypeContent, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::TextObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_text_object(&mut values, value)?;
                        }
                        Ok(super::PageContentLayerXElementTypeContent::TextObject(
                            helper.finish_element("TextObject", values)?,
                        ))
                    }
                    S::PathObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_path_object(&mut values, value)?;
                        }
                        Ok(super::PageContentLayerXElementTypeContent::PathObject(
                            helper.finish_element("PathObject", values)?,
                        ))
                    }
                    S::ImageObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_image_object(&mut values, value)?;
                        }
                        Ok(super::PageContentLayerXElementTypeContent::ImageObject(
                            helper.finish_element("ImageObject", values)?,
                        ))
                    }
                    S::CompositeObject(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_object(&mut values, value)?;
                        }
                        Ok(super::PageContentLayerXElementTypeContent::CompositeObject(
                            helper.finish_element("CompositeObject", values)?,
                        ))
                    }
                    S::PageBlock(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_page_block(&mut values, value)?;
                        }
                        Ok(super::PageContentLayerXElementTypeContent::PageBlock(
                            helper.finish_element("PageBlock", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_text_object(
                values: &mut Option<super::CtPageBlockTextObjectXElementType>,
                value: super::CtPageBlockTextObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"TextObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_path_object(
                values: &mut Option<super::CtPageBlockPathObjectXElementType>,
                value: super::CtPageBlockPathObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PathObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_image_object(
                values: &mut Option<super::CtPageBlockImageObjectXElementType>,
                value: super::CtPageBlockImageObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ImageObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_object(
                values: &mut Option<super::CtPageBlockCompositeObjectXElementType>,
                value: super::CtPageBlockCompositeObjectXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeObject",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_page_block(
                values: &mut Option<super::CtPageBlockPageBlockXElementType>,
                value: super::CtPageBlockPageBlockXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"PageBlock",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_text_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockTextObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockTextObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockTextObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_text_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_text_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::TextObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::TextObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_path_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPathObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockPathObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPathObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_path_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_path_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PathObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PathObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_image_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockImageObjectXElementType>,
                fallback: Option<
                    <super::CtPageBlockImageObjectXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockImageObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_image_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_image_object(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ImageObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ImageObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_object<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockCompositeObjectXElementType>,
                fallback : Option << super :: CtPageBlockCompositeObjectXElementType as WithDeserializer > :: Deserializer >,
                output: DeserializerOutput<'de, super::CtPageBlockCompositeObjectXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_object(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_object(&mut values, data)?;
                        let data =
                            Self::finish_state(helper, S::CompositeObject(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeObject(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_page_block<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::CtPageBlockPageBlockXElementType>,
                fallback: Option<
                    <super::CtPageBlockPageBlockXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::CtPageBlockPageBlockXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_page_block(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_page_block(&mut values, data)?;
                        let data = Self::finish_state(helper, S::PageBlock(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::PageBlock(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::PageContentLayerXElementTypeContent>
            for PageContentLayerXElementTypeContentDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentLayerXElementTypeContent> {
                let deserializer = Self {
                    state__: Box::new(PageContentLayerXElementTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            PageContentLayerXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::PageContentLayerXElementTypeContent> {
                use PageContentLayerXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::TextObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PathObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::ImageObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeObject(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::PageBlock(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::TextObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"TextObject",
                                true,
                            )?;
                            match self.handle_text_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PathObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PathObject",
                                true,
                            )?;
                            match self.handle_path_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::ImageObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ImageObject",
                                true,
                            )?;
                            match self.handle_image_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeObject(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeObject",
                                true,
                            )?;
                            match self.handle_composite_object(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::PageBlock(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"PageBlock",
                                true,
                            )?;
                            match self.handle_page_block(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::PageContentLayerXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct CtAxialShdXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtAxialShdXType,
            pub(super) state: Box<CtAxialShdXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtAxialShdXTypeSerializerState<'ser> {
            Init__,
            Segment(
                IterSerializer<
                    'ser,
                    &'ser [super::CtAxialShdSegmentXElementType],
                    super::CtAxialShdSegmentXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtAxialShdXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtAxialShdXTypeSerializerState::Init__ => {
                            *self.state =
                                CtAxialShdXTypeSerializerState::Segment(IterSerializer::new(
                                    &self.value.segment[..],
                                    Some("Segment"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "MapType", &self.value.map_type)?;
                            helper.write_attrib_opt(&mut bytes, "MapUnit", &self.value.map_unit)?;
                            helper.write_attrib(&mut bytes, "Extend", &self.value.extend)?;
                            helper.write_attrib(
                                &mut bytes,
                                "StartPoint",
                                &self.value.start_point,
                            )?;
                            helper.write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtAxialShdXTypeSerializerState::Segment(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtAxialShdXTypeSerializerState::End__,
                            }
                        }
                        CtAxialShdXTypeSerializerState::End__ => {
                            *self.state = CtAxialShdXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtAxialShdXTypeSerializerState::Done__ => return Ok(None),
                        CtAxialShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtAxialShdXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtAxialShdXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtCgTransformXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtCgTransformXType,
            pub(super) state: Box<CtCgTransformXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtCgTransformXTypeSerializerState<'ser> {
            Init__,
            Glyphs(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtCgTransformXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtCgTransformXTypeSerializerState::Init__ => {
                            *self.state =
                                CtCgTransformXTypeSerializerState::Glyphs(IterSerializer::new(
                                    self.value.glyphs.as_ref(),
                                    Some("Glyphs"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "CodePosition",
                                &self.value.code_position,
                            )?;
                            helper.write_attrib(&mut bytes, "CodeCount", &self.value.code_count)?;
                            helper.write_attrib(
                                &mut bytes,
                                "GlyphCount",
                                &self.value.glyph_count,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtCgTransformXTypeSerializerState::Glyphs(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtCgTransformXTypeSerializerState::End__,
                            }
                        }
                        CtCgTransformXTypeSerializerState::End__ => {
                            *self.state = CtCgTransformXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtCgTransformXTypeSerializerState::Done__ => return Ok(None),
                        CtCgTransformXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtCgTransformXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtCgTransformXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtClipXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtClipXType,
            pub(super) state: Box<CtClipXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtClipXTypeSerializerState<'ser> {
            Init__,
            Area(
                IterSerializer<
                    'ser,
                    &'ser [super::CtClipAreaXElementType],
                    super::CtClipAreaXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtClipXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtClipXTypeSerializerState::Init__ => {
                            *self.state = CtClipXTypeSerializerState::Area(IterSerializer::new(
                                &self.value.area[..],
                                Some("Area"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtClipXTypeSerializerState::Area(x) => match x.next(helper).transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtClipXTypeSerializerState::End__,
                        },
                        CtClipXTypeSerializerState::End__ => {
                            *self.state = CtClipXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtClipXTypeSerializerState::Done__ => return Ok(None),
                        CtClipXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtClipXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtClipXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtColorXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtColorXType,
            pub(super) state: Box<CtColorXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtColorXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtColorXTypeContent>,
                    super::CtColorXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtColorXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtColorXTypeSerializerState::Init__ => {
                            *self.state = CtColorXTypeSerializerState::Content__(
                                IterSerializer::new(self.value.content.as_ref(), None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(&mut bytes, "Value", &self.value.value)?;
                            helper.write_attrib_opt(&mut bytes, "Index", &self.value.index)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "ColorSpace",
                                &self.value.color_space,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtColorXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeSerializerState::End__,
                            }
                        }
                        CtColorXTypeSerializerState::End__ => {
                            *self.state = CtColorXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtColorXTypeSerializerState::Done__ => return Ok(None),
                        CtColorXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtColorXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtColorXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtColorXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtColorXTypeContent,
            pub(super) state: Box<CtColorXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtColorXTypeContentSerializerState<'ser> {
            Init__,
            Pattern(<super::CtPatternXType as WithSerializer>::Serializer<'ser>),
            AxialShd(<super::CtAxialShdXType as WithSerializer>::Serializer<'ser>),
            RadialShd(<super::CtRadialShdXType as WithSerializer>::Serializer<'ser>),
            GouraudShd(<super::CtGouraudShdXType as WithSerializer>::Serializer<'ser>),
            LaGourandShd(<super::CtLaGouraudShdXType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtColorXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtColorXTypeContentSerializerState::Init__ => match self.value {
                            super::CtColorXTypeContent::Pattern(x) => {
                                *self.state = CtColorXTypeContentSerializerState::Pattern(
                                    WithSerializer::serializer(x, Some("Pattern"), false)?,
                                )
                            }
                            super::CtColorXTypeContent::AxialShd(x) => {
                                *self.state = CtColorXTypeContentSerializerState::AxialShd(
                                    WithSerializer::serializer(x, Some("AxialShd"), false)?,
                                )
                            }
                            super::CtColorXTypeContent::RadialShd(x) => {
                                *self.state = CtColorXTypeContentSerializerState::RadialShd(
                                    WithSerializer::serializer(x, Some("RadialShd"), false)?,
                                )
                            }
                            super::CtColorXTypeContent::GouraudShd(x) => {
                                *self.state = CtColorXTypeContentSerializerState::GouraudShd(
                                    WithSerializer::serializer(x, Some("GouraudShd"), false)?,
                                )
                            }
                            super::CtColorXTypeContent::LaGourandShd(x) => {
                                *self.state = CtColorXTypeContentSerializerState::LaGourandShd(
                                    WithSerializer::serializer(x, Some("LaGourandShd"), false)?,
                                )
                            }
                        },
                        CtColorXTypeContentSerializerState::Pattern(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeContentSerializerState::Done__,
                            }
                        }
                        CtColorXTypeContentSerializerState::AxialShd(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeContentSerializerState::Done__,
                            }
                        }
                        CtColorXTypeContentSerializerState::RadialShd(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeContentSerializerState::Done__,
                            }
                        }
                        CtColorXTypeContentSerializerState::GouraudShd(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeContentSerializerState::Done__,
                            }
                        }
                        CtColorXTypeContentSerializerState::LaGourandShd(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorXTypeContentSerializerState::Done__,
                            }
                        }
                        CtColorXTypeContentSerializerState::Done__ => return Ok(None),
                        CtColorXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtColorXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtColorXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtCompositeXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtCompositeXType,
            pub(super) state: Box<CtCompositeXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtCompositeXTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtCompositeXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtCompositeXTypeSerializerState::Init__ => {
                            *self.state =
                                CtCompositeXTypeSerializerState::Actions(IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtCompositeXTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtCompositeXTypeSerializerState::Clips(IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtCompositeXTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtCompositeXTypeSerializerState::End__,
                            }
                        }
                        CtCompositeXTypeSerializerState::End__ => {
                            *self.state = CtCompositeXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtCompositeXTypeSerializerState::Done__ => return Ok(None),
                        CtCompositeXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtCompositeXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtCompositeXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtGouraudShdXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtGouraudShdXType,
            pub(super) state: Box<CtGouraudShdXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtGouraudShdXTypeSerializerState<'ser> {
            Init__,
            Point(
                IterSerializer<
                    'ser,
                    &'ser [super::CtGouraudShdPointXElementType],
                    super::CtGouraudShdPointXElementType,
                >,
            ),
            BackColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtGouraudShdXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtGouraudShdXTypeSerializerState::Init__ => {
                            *self.state = CtGouraudShdXTypeSerializerState::Point(
                                IterSerializer::new(&self.value.point[..], Some("Point"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(&mut bytes, "Extend", &self.value.extend)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtGouraudShdXTypeSerializerState::Point(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtGouraudShdXTypeSerializerState::BackColor(
                                        IterSerializer::new(
                                            self.value.back_color.as_deref(),
                                            Some("BackColor"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtGouraudShdXTypeSerializerState::BackColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtGouraudShdXTypeSerializerState::End__,
                            }
                        }
                        CtGouraudShdXTypeSerializerState::End__ => {
                            *self.state = CtGouraudShdXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtGouraudShdXTypeSerializerState::Done__ => return Ok(None),
                        CtGouraudShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtGouraudShdXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtGouraudShdXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtGraphicUnitXType,
            pub(super) state: Box<CtGraphicUnitXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtGraphicUnitXTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtGraphicUnitXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtGraphicUnitXTypeSerializerState::Init__ => {
                            *self.state =
                                CtGraphicUnitXTypeSerializerState::Actions(IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtGraphicUnitXTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtGraphicUnitXTypeSerializerState::Clips(
                                        IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtGraphicUnitXTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtGraphicUnitXTypeSerializerState::End__,
                            }
                        }
                        CtGraphicUnitXTypeSerializerState::End__ => {
                            *self.state = CtGraphicUnitXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtGraphicUnitXTypeSerializerState::Done__ => return Ok(None),
                        CtGraphicUnitXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtGraphicUnitXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtGraphicUnitXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtImageXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtImageXType,
            pub(super) state: Box<CtImageXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtImageXTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            Border(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtImageBorderXElementType>,
                    super::CtImageBorderXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtImageXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtImageXTypeSerializerState::Init__ => {
                            *self.state =
                                CtImageXTypeSerializerState::Actions(IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Substitution",
                                &self.value.substitution,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "ImageMask",
                                &self.value.image_mask,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtImageXTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtImageXTypeSerializerState::Clips(IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtImageXTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtImageXTypeSerializerState::Border(IterSerializer::new(
                                            self.value.border.as_ref(),
                                            Some("Border"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtImageXTypeSerializerState::Border(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtImageXTypeSerializerState::End__,
                            }
                        }
                        CtImageXTypeSerializerState::End__ => {
                            *self.state = CtImageXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtImageXTypeSerializerState::Done__ => return Ok(None),
                        CtImageXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtImageXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtImageXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtLaGouraudShdXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtLaGouraudShdXType,
            pub(super) state: Box<CtLaGouraudShdXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtLaGouraudShdXTypeSerializerState<'ser> {
            Init__,
            Point(
                IterSerializer<
                    'ser,
                    &'ser [super::CtLaGouraudShdPointXElementType],
                    super::CtLaGouraudShdPointXElementType,
                >,
            ),
            BackColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtLaGouraudShdXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtLaGouraudShdXTypeSerializerState::Init__ => {
                            *self.state = CtLaGouraudShdXTypeSerializerState::Point(
                                IterSerializer::new(&self.value.point[..], Some("Point"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "VerticesPerRow",
                                &self.value.vertices_per_row,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Extend", &self.value.extend)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtLaGouraudShdXTypeSerializerState::Point(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtLaGouraudShdXTypeSerializerState::BackColor(
                                        IterSerializer::new(
                                            self.value.back_color.as_deref(),
                                            Some("BackColor"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtLaGouraudShdXTypeSerializerState::BackColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLaGouraudShdXTypeSerializerState::End__,
                            }
                        }
                        CtLaGouraudShdXTypeSerializerState::End__ => {
                            *self.state = CtLaGouraudShdXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtLaGouraudShdXTypeSerializerState::Done__ => return Ok(None),
                        CtLaGouraudShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtLaGouraudShdXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtLaGouraudShdXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtLayerXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtLayerXType,
            pub(super) state: Box<CtLayerXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtLayerXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtLayerXTypeContent],
                    super::CtLayerXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtLayerXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtLayerXTypeSerializerState::Init__ => {
                            *self.state = CtLayerXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtLayerXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeSerializerState::End__,
                            }
                        }
                        CtLayerXTypeSerializerState::End__ => {
                            *self.state = CtLayerXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtLayerXTypeSerializerState::Done__ => return Ok(None),
                        CtLayerXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtLayerXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtLayerXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtLayerXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtLayerXTypeContent,
            pub(super) state: Box<CtLayerXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtLayerXTypeContentSerializerState<'ser> {
            Init__,
            TextObject(
                <super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PathObject(
                <super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            ImageObject(
                <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            CompositeObject(
                <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageBlock(
                <super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtLayerXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtLayerXTypeContentSerializerState::Init__ => match self.value {
                            super::CtLayerXTypeContent::TextObject(x) => {
                                *self.state = CtLayerXTypeContentSerializerState::TextObject(
                                    WithSerializer::serializer(x, Some("TextObject"), false)?,
                                )
                            }
                            super::CtLayerXTypeContent::PathObject(x) => {
                                *self.state = CtLayerXTypeContentSerializerState::PathObject(
                                    WithSerializer::serializer(x, Some("PathObject"), false)?,
                                )
                            }
                            super::CtLayerXTypeContent::ImageObject(x) => {
                                *self.state = CtLayerXTypeContentSerializerState::ImageObject(
                                    WithSerializer::serializer(x, Some("ImageObject"), false)?,
                                )
                            }
                            super::CtLayerXTypeContent::CompositeObject(x) => {
                                *self.state = CtLayerXTypeContentSerializerState::CompositeObject(
                                    WithSerializer::serializer(x, Some("CompositeObject"), false)?,
                                )
                            }
                            super::CtLayerXTypeContent::PageBlock(x) => {
                                *self.state = CtLayerXTypeContentSerializerState::PageBlock(
                                    WithSerializer::serializer(x, Some("PageBlock"), false)?,
                                )
                            }
                        },
                        CtLayerXTypeContentSerializerState::TextObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                            }
                        }
                        CtLayerXTypeContentSerializerState::PathObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                            }
                        }
                        CtLayerXTypeContentSerializerState::ImageObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                            }
                        }
                        CtLayerXTypeContentSerializerState::CompositeObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                            }
                        }
                        CtLayerXTypeContentSerializerState::PageBlock(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtLayerXTypeContentSerializerState::Done__,
                            }
                        }
                        CtLayerXTypeContentSerializerState::Done__ => return Ok(None),
                        CtLayerXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtLayerXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtLayerXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockXType,
            pub(super) state: Box<CtPageBlockXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtPageBlockXTypeContent],
                    super::CtPageBlockXTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockXTypeSerializerState::Init__ => {
                            *self.state = CtPageBlockXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtPageBlockXTypeSerializerState::End__,
                            }
                        }
                        CtPageBlockXTypeSerializerState::End__ => {
                            *self.state = CtPageBlockXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockXTypeSerializerState::Done__ => return Ok(None),
                        CtPageBlockXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockXTypeContent,
            pub(super) state: Box<CtPageBlockXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockXTypeContentSerializerState<'ser> {
            Init__,
            TextObject(
                <super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PathObject(
                <super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            ImageObject(
                <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            CompositeObject(
                <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageBlock(
                <super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockXTypeContentSerializerState::Init__ => match self.value {
                            super::CtPageBlockXTypeContent::TextObject(x) => {
                                *self.state = CtPageBlockXTypeContentSerializerState::TextObject(
                                    WithSerializer::serializer(x, Some("TextObject"), false)?,
                                )
                            }
                            super::CtPageBlockXTypeContent::PathObject(x) => {
                                *self.state = CtPageBlockXTypeContentSerializerState::PathObject(
                                    WithSerializer::serializer(x, Some("PathObject"), false)?,
                                )
                            }
                            super::CtPageBlockXTypeContent::ImageObject(x) => {
                                *self.state = CtPageBlockXTypeContentSerializerState::ImageObject(
                                    WithSerializer::serializer(x, Some("ImageObject"), false)?,
                                )
                            }
                            super::CtPageBlockXTypeContent::CompositeObject(x) => {
                                *self.state =
                                    CtPageBlockXTypeContentSerializerState::CompositeObject(
                                        WithSerializer::serializer(
                                            x,
                                            Some("CompositeObject"),
                                            false,
                                        )?,
                                    )
                            }
                            super::CtPageBlockXTypeContent::PageBlock(x) => {
                                *self.state = CtPageBlockXTypeContentSerializerState::PageBlock(
                                    WithSerializer::serializer(x, Some("PageBlock"), false)?,
                                )
                            }
                        },
                        CtPageBlockXTypeContentSerializerState::TextObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageBlockXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtPageBlockXTypeContentSerializerState::PathObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageBlockXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtPageBlockXTypeContentSerializerState::ImageObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageBlockXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtPageBlockXTypeContentSerializerState::CompositeObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageBlockXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtPageBlockXTypeContentSerializerState::PageBlock(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPageBlockXTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtPageBlockXTypeContentSerializerState::Done__ => return Ok(None),
                        CtPageBlockXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPathXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPathXType,
            pub(super) state: Box<CtPathXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPathXTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            StrokeColor(
                IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>,
            ),
            FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
            AbbreviatedData(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPathXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPathXTypeSerializerState::Init__ => {
                            *self.state = CtPathXTypeSerializerState::Actions(IterSerializer::new(
                                self.value.actions.as_ref(),
                                Some("Actions"),
                                false,
                            ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                            helper.write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                            helper.write_attrib(&mut bytes, "Rule", &self.value.rule)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPathXTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPathXTypeSerializerState::Clips(IterSerializer::new(
                                            self.value.clips.as_ref(),
                                            Some("Clips"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtPathXTypeSerializerState::Clips(x) => match x.next(helper).transpose()? {
                            Some(event) => return Ok(Some(event)),
                            None => {
                                *self.state =
                                    CtPathXTypeSerializerState::StrokeColor(IterSerializer::new(
                                        self.value.stroke_color.as_ref(),
                                        Some("StrokeColor"),
                                        false,
                                    ))
                            }
                        },
                        CtPathXTypeSerializerState::StrokeColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPathXTypeSerializerState::FillColor(IterSerializer::new(
                                            self.value.fill_color.as_ref(),
                                            Some("FillColor"),
                                            false,
                                        ))
                                }
                            }
                        }
                        CtPathXTypeSerializerState::FillColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtPathXTypeSerializerState::AbbreviatedData(
                                        WithSerializer::serializer(
                                            &self.value.abbreviated_data,
                                            Some("AbbreviatedData"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        CtPathXTypeSerializerState::AbbreviatedData(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtPathXTypeSerializerState::End__,
                            }
                        }
                        CtPathXTypeSerializerState::End__ => {
                            *self.state = CtPathXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPathXTypeSerializerState::Done__ => return Ok(None),
                        CtPathXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPathXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPathXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPatternXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPatternXType,
            pub(super) state: Box<CtPatternXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPatternXTypeSerializerState<'ser> {
            Init__,
            CellContent(
                <super::CtPatternCellContentXElementType as WithSerializer>::Serializer<'ser>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPatternXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPatternXTypeSerializerState::Init__ => {
                            *self.state = CtPatternXTypeSerializerState::CellContent(
                                WithSerializer::serializer(
                                    &self.value.cell_content,
                                    Some("CellContent"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Width", &self.value.width)?;
                            helper.write_attrib(&mut bytes, "Height", &self.value.height)?;
                            helper.write_attrib_opt(&mut bytes, "XStep", &self.value.x_step)?;
                            helper.write_attrib_opt(&mut bytes, "YStep", &self.value.y_step)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ReflectMethod",
                                &self.value.reflect_method,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "RelativeTo",
                                &self.value.relative_to,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPatternXTypeSerializerState::CellContent(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtPatternXTypeSerializerState::End__,
                            }
                        }
                        CtPatternXTypeSerializerState::End__ => {
                            *self.state = CtPatternXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPatternXTypeSerializerState::Done__ => return Ok(None),
                        CtPatternXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPatternXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPatternXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtRadialShdXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtRadialShdXType,
            pub(super) state: Box<CtRadialShdXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtRadialShdXTypeSerializerState<'ser> {
            Init__,
            Seqment(
                IterSerializer<
                    'ser,
                    &'ser [super::CtAxialShdSegmentXElementType],
                    super::CtAxialShdSegmentXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtRadialShdXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtRadialShdXTypeSerializerState::Init__ => {
                            *self.state =
                                CtRadialShdXTypeSerializerState::Seqment(IterSerializer::new(
                                    &self.value.seqment[..],
                                    Some("Seqment"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "MapType", &self.value.map_type)?;
                            helper.write_attrib_opt(&mut bytes, "MapUnit", &self.value.map_unit)?;
                            helper.write_attrib(
                                &mut bytes,
                                "Eccentricity",
                                &self.value.eccentricity,
                            )?;
                            helper.write_attrib(&mut bytes, "Angle", &self.value.angle)?;
                            helper.write_attrib(
                                &mut bytes,
                                "StartPoint",
                                &self.value.start_point,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "StartRadius",
                                &self.value.start_radius,
                            )?;
                            helper.write_attrib(&mut bytes, "EndPoint", &self.value.end_point)?;
                            helper.write_attrib(&mut bytes, "EndRadius", &self.value.end_radius)?;
                            helper.write_attrib(&mut bytes, "Extend", &self.value.extend)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtRadialShdXTypeSerializerState::Seqment(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtRadialShdXTypeSerializerState::End__,
                            }
                        }
                        CtRadialShdXTypeSerializerState::End__ => {
                            *self.state = CtRadialShdXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtRadialShdXTypeSerializerState::Done__ => return Ok(None),
                        CtRadialShdXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtRadialShdXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtRadialShdXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtTextXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtTextXType,
            pub(super) state: Box<CtTextXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtTextXTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<'ser, &'ser [super::CtTextXTypeContent], super::CtTextXTypeContent>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtTextXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtTextXTypeSerializerState::Init__ => {
                            *self.state = CtTextXTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(&mut bytes, "Font", &self.value.font)?;
                            helper.write_attrib(&mut bytes, "Size", &self.value.size)?;
                            helper.write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                            helper.write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                            helper.write_attrib(&mut bytes, "HScale", &self.value.h_scale)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ReadDirection",
                                &self.value.read_direction,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "CharDirection",
                                &self.value.char_direction,
                            )?;
                            helper.write_attrib(&mut bytes, "Weight", &self.value.weight)?;
                            helper.write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtTextXTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeSerializerState::End__,
                            }
                        }
                        CtTextXTypeSerializerState::End__ => {
                            *self.state = CtTextXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtTextXTypeSerializerState::Done__ => return Ok(None),
                        CtTextXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtTextXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtTextXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtTextXTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtTextXTypeContent,
            pub(super) state: Box<CtTextXTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtTextXTypeContentSerializerState<'ser> {
            Init__,
            Actions(<super::CtGraphicUnitActionsXElementType as WithSerializer>::Serializer<'ser>),
            Clips(<super::CtGraphicUnitClipsXElementType as WithSerializer>::Serializer<'ser>),
            FillColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            StrokeColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            CgTransform(<super::CtCgTransformXType as WithSerializer>::Serializer<'ser>),
            TextCode(<super::CtTextTextCodeXElementType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtTextXTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtTextXTypeContentSerializerState::Init__ => match self.value {
                            super::CtTextXTypeContent::Actions(x) => {
                                *self.state = CtTextXTypeContentSerializerState::Actions(
                                    WithSerializer::serializer(x, Some("Actions"), false)?,
                                )
                            }
                            super::CtTextXTypeContent::Clips(x) => {
                                *self.state = CtTextXTypeContentSerializerState::Clips(
                                    WithSerializer::serializer(x, Some("Clips"), false)?,
                                )
                            }
                            super::CtTextXTypeContent::FillColor(x) => {
                                *self.state = CtTextXTypeContentSerializerState::FillColor(
                                    WithSerializer::serializer(x, Some("FillColor"), false)?,
                                )
                            }
                            super::CtTextXTypeContent::StrokeColor(x) => {
                                *self.state = CtTextXTypeContentSerializerState::StrokeColor(
                                    WithSerializer::serializer(x, Some("StrokeColor"), false)?,
                                )
                            }
                            super::CtTextXTypeContent::CgTransform(x) => {
                                *self.state = CtTextXTypeContentSerializerState::CgTransform(
                                    WithSerializer::serializer(x, Some("CGTransform"), false)?,
                                )
                            }
                            super::CtTextXTypeContent::TextCode(x) => {
                                *self.state = CtTextXTypeContentSerializerState::TextCode(
                                    WithSerializer::serializer(x, Some("TextCode"), false)?,
                                )
                            }
                        },
                        CtTextXTypeContentSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::FillColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::StrokeColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::CgTransform(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::TextCode(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtTextXTypeContentSerializerState::Done__,
                            }
                        }
                        CtTextXTypeContentSerializerState::Done__ => return Ok(None),
                        CtTextXTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtTextXTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtTextXTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageXElementType,
            pub(super) state: Box<PageXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageXElementTypeSerializerState<'ser> {
            Init__,
            Template(
                IterSerializer<
                    'ser,
                    &'ser [super::PageTemplateXElementType],
                    super::PageTemplateXElementType,
                >,
            ),
            PageRes(IterSerializer<'ser, &'ser [String], String>),
            Area(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::definition::CtPageAreaXType>,
                    super::super::definition::CtPageAreaXType,
                >,
            ),
            Content(
                IterSerializer<
                    'ser,
                    Option<&'ser super::PageContentXElementType>,
                    super::PageContentXElementType,
                >,
            ),
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageXElementTypeSerializerState::Init__ => {
                            *self.state =
                                PageXElementTypeSerializerState::Template(IterSerializer::new(
                                    &self.value.template[..],
                                    Some("Template"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageXElementTypeSerializerState::Template(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = PageXElementTypeSerializerState::PageRes(
                                        IterSerializer::new(
                                            &self.value.page_res[..],
                                            Some("PageRes"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        PageXElementTypeSerializerState::PageRes(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageXElementTypeSerializerState::Area(IterSerializer::new(
                                            self.value.area.as_ref(),
                                            Some("Area"),
                                            false,
                                        ))
                                }
                            }
                        }
                        PageXElementTypeSerializerState::Area(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = PageXElementTypeSerializerState::Content(
                                        IterSerializer::new(
                                            self.value.content.as_ref(),
                                            Some("Content"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        PageXElementTypeSerializerState::Content(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = PageXElementTypeSerializerState::Actions(
                                        IterSerializer::new(
                                            self.value.actions.as_ref(),
                                            Some("Actions"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        PageXElementTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = PageXElementTypeSerializerState::End__,
                            }
                        }
                        PageXElementTypeSerializerState::End__ => {
                            *self.state = PageXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageXElementTypeSerializerState::Done__ => return Ok(None),
                        PageXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtAxialShdSegmentXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtAxialShdSegmentXElementType,
            pub(super) state: Box<CtAxialShdSegmentXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtAxialShdSegmentXElementTypeSerializerState<'ser> {
            Init__,
            Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtAxialShdSegmentXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtAxialShdSegmentXElementTypeSerializerState::Init__ => {
                            *self.state = CtAxialShdSegmentXElementTypeSerializerState::Color(
                                WithSerializer::serializer(
                                    &*self.value.color,
                                    Some("Color"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Position",
                                &self.value.position,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtAxialShdSegmentXElementTypeSerializerState::Color(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtAxialShdSegmentXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtAxialShdSegmentXElementTypeSerializerState::End__ => {
                            *self.state = CtAxialShdSegmentXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtAxialShdSegmentXElementTypeSerializerState::Done__ => return Ok(None),
                        CtAxialShdSegmentXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtAxialShdSegmentXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtAxialShdSegmentXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtClipAreaXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtClipAreaXElementType,
            pub(super) state: Box<CtClipAreaXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtClipAreaXElementTypeSerializerState<'ser> {
            Init__,
            Content__(<super::CtClipAreaXElementTypeContent as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtClipAreaXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtClipAreaXElementTypeSerializerState::Init__ => {
                            *self.state = CtClipAreaXElementTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtClipAreaXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtClipAreaXElementTypeSerializerState::End__,
                            }
                        }
                        CtClipAreaXElementTypeSerializerState::End__ => {
                            *self.state = CtClipAreaXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtClipAreaXElementTypeSerializerState::Done__ => return Ok(None),
                        CtClipAreaXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtClipAreaXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtClipAreaXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtClipAreaXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtClipAreaXElementTypeContent,
            pub(super) state: Box<CtClipAreaXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtClipAreaXElementTypeContentSerializerState<'ser> {
            Init__,
            Path(<super::CtPathXType as WithSerializer>::Serializer<'ser>),
            Text(<super::CtTextXType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtClipAreaXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtClipAreaXElementTypeContentSerializerState::Init__ => match self.value {
                            super::CtClipAreaXElementTypeContent::Path(x) => {
                                *self.state = CtClipAreaXElementTypeContentSerializerState::Path(
                                    WithSerializer::serializer(x, Some("Path"), false)?,
                                )
                            }
                            super::CtClipAreaXElementTypeContent::Text(x) => {
                                *self.state = CtClipAreaXElementTypeContentSerializerState::Text(
                                    WithSerializer::serializer(x, Some("Text"), false)?,
                                )
                            }
                        },
                        CtClipAreaXElementTypeContentSerializerState::Path(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtClipAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtClipAreaXElementTypeContentSerializerState::Text(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtClipAreaXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        CtClipAreaXElementTypeContentSerializerState::Done__ => return Ok(None),
                        CtClipAreaXElementTypeContentSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtClipAreaXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtClipAreaXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitActionsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtGraphicUnitActionsXElementType,
            pub(super) state: Box<CtGraphicUnitActionsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtGraphicUnitActionsXElementTypeSerializerState<'ser> {
            Init__,
            Action(
                IterSerializer<
                    'ser,
                    &'ser [super::super::definition::CtActionXType],
                    super::super::definition::CtActionXType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtGraphicUnitActionsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtGraphicUnitActionsXElementTypeSerializerState::Init__ => {
                            *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Action(
                                IterSerializer::new(&self.value.action[..], Some("Action"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtGraphicUnitActionsXElementTypeSerializerState::Action(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtGraphicUnitActionsXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtGraphicUnitActionsXElementTypeSerializerState::End__ => {
                            *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtGraphicUnitActionsXElementTypeSerializerState::Done__ => return Ok(None),
                        CtGraphicUnitActionsXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtGraphicUnitActionsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtGraphicUnitActionsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtGraphicUnitClipsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtGraphicUnitClipsXElementType,
            pub(super) state: Box<CtGraphicUnitClipsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtGraphicUnitClipsXElementTypeSerializerState<'ser> {
            Init__,
            Clip(IterSerializer<'ser, &'ser [super::CtClipXType], super::CtClipXType>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtGraphicUnitClipsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtGraphicUnitClipsXElementTypeSerializerState::Init__ => {
                            *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Clip(
                                IterSerializer::new(&self.value.clip[..], Some("Clip"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtGraphicUnitClipsXElementTypeSerializerState::Clip(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtGraphicUnitClipsXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtGraphicUnitClipsXElementTypeSerializerState::End__ => {
                            *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtGraphicUnitClipsXElementTypeSerializerState::Done__ => return Ok(None),
                        CtGraphicUnitClipsXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtGraphicUnitClipsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtGraphicUnitClipsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtGouraudShdPointXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtGouraudShdPointXElementType,
            pub(super) state: Box<CtGouraudShdPointXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtGouraudShdPointXElementTypeSerializerState<'ser> {
            Init__,
            Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtGouraudShdPointXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtGouraudShdPointXElementTypeSerializerState::Init__ => {
                            *self.state = CtGouraudShdPointXElementTypeSerializerState::Color(
                                WithSerializer::serializer(
                                    &*self.value.color,
                                    Some("Color"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "X", &self.value.x)?;
                            helper.write_attrib(&mut bytes, "y", &self.value.y)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "EdgeFlag",
                                &self.value.edge_flag,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtGouraudShdPointXElementTypeSerializerState::Color(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtGouraudShdPointXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtGouraudShdPointXElementTypeSerializerState::End__ => {
                            *self.state = CtGouraudShdPointXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtGouraudShdPointXElementTypeSerializerState::Done__ => return Ok(None),
                        CtGouraudShdPointXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtGouraudShdPointXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtGouraudShdPointXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtImageBorderXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtImageBorderXElementType,
            pub(super) state: Box<CtImageBorderXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtImageBorderXElementTypeSerializerState<'ser> {
            Init__,
            BorderColor(
                IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtImageBorderXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtImageBorderXElementTypeSerializerState::Init__ => {
                            *self.state = CtImageBorderXElementTypeSerializerState::BorderColor(
                                IterSerializer::new(
                                    self.value.border_color.as_ref(),
                                    Some("BorderColor"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(
                                &mut bytes,
                                "HorizonalCornerRadius",
                                &self.value.horizonal_corner_radius,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "VerticalCornerRadius",
                                &self.value.vertical_corner_radius,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtImageBorderXElementTypeSerializerState::BorderColor(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtImageBorderXElementTypeSerializerState::End__,
                        },
                        CtImageBorderXElementTypeSerializerState::End__ => {
                            *self.state = CtImageBorderXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtImageBorderXElementTypeSerializerState::Done__ => return Ok(None),
                        CtImageBorderXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtImageBorderXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtImageBorderXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtLaGouraudShdPointXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtLaGouraudShdPointXElementType,
            pub(super) state: Box<CtLaGouraudShdPointXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtLaGouraudShdPointXElementTypeSerializerState<'ser> {
            Init__,
            Color(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtLaGouraudShdPointXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtLaGouraudShdPointXElementTypeSerializerState::Init__ => {
                            *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Color(
                                WithSerializer::serializer(
                                    &*self.value.color,
                                    Some("Color"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(&mut bytes, "X", &self.value.x)?;
                            helper.write_attrib_opt(&mut bytes, "y", &self.value.y)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtLaGouraudShdPointXElementTypeSerializerState::Color(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtLaGouraudShdPointXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtLaGouraudShdPointXElementTypeSerializerState::End__ => {
                            *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtLaGouraudShdPointXElementTypeSerializerState::Done__ => return Ok(None),
                        CtLaGouraudShdPointXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtLaGouraudShdPointXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtLaGouraudShdPointXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockTextObjectXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockTextObjectXElementType,
            pub(super) state: Box<CtPageBlockTextObjectXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockTextObjectXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtPageBlockTextObjectXElementTypeContent],
                    super::CtPageBlockTextObjectXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockTextObjectXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockTextObjectXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPageBlockTextObjectXElementTypeSerializerState::Content__(
                                    IterSerializer::new(&self.value.content[..], None, false),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(&mut bytes, "Font", &self.value.font)?;
                            helper.write_attrib(&mut bytes, "Size", &self.value.size)?;
                            helper.write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                            helper.write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                            helper.write_attrib(&mut bytes, "HScale", &self.value.h_scale)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ReadDirection",
                                &self.value.read_direction,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "CharDirection",
                                &self.value.char_direction,
                            )?;
                            helper.write_attrib(&mut bytes, "Weight", &self.value.weight)?;
                            helper.write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockTextObjectXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockTextObjectXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPageBlockTextObjectXElementTypeSerializerState::End__ => {
                            *self.state = CtPageBlockTextObjectXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockTextObjectXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtPageBlockTextObjectXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockTextObjectXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockTextObjectXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockTextObjectXElementTypeContent,
            pub(super) state: Box<CtPageBlockTextObjectXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockTextObjectXElementTypeContentSerializerState<'ser> {
            Init__,
            Actions(<super::CtGraphicUnitActionsXElementType as WithSerializer>::Serializer<'ser>),
            Clips(<super::CtGraphicUnitClipsXElementType as WithSerializer>::Serializer<'ser>),
            FillColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            StrokeColor(<super::CtColorXType as WithSerializer>::Serializer<'ser>),
            CgTransform(<super::CtCgTransformXType as WithSerializer>::Serializer<'ser>),
            TextCode(<super::CtTextTextCodeXElementType as WithSerializer>::Serializer<'ser>),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { CtPageBlockTextObjectXElementTypeContentSerializerState :: Init__ => { match self . value { super :: CtPageBlockTextObjectXElementTypeContent :: Actions (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Actions (WithSerializer :: serializer (x , Some ("Actions") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: Clips (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Clips (WithSerializer :: serializer (x , Some ("Clips") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: FillColor (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: FillColor (WithSerializer :: serializer (x , Some ("FillColor") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: StrokeColor (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: StrokeColor (WithSerializer :: serializer (x , Some ("StrokeColor") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: CgTransform (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: CgTransform (WithSerializer :: serializer (x , Some ("CGTransform") , false) ?) , super :: CtPageBlockTextObjectXElementTypeContent :: TextCode (x) => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: TextCode (WithSerializer :: serializer (x , Some ("TextCode") , false) ?) , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: Actions (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: Clips (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: FillColor (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: StrokeColor (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: CgTransform (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: TextCode (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ , } } CtPageBlockTextObjectXElementTypeContentSerializerState :: Done__ => return Ok (None) , CtPageBlockTextObjectXElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockTextObjectXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            CtPageBlockTextObjectXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPathObjectXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockPathObjectXElementType,
            pub(super) state: Box<CtPageBlockPathObjectXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockPathObjectXElementTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            StrokeColor(
                IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>,
            ),
            FillColor(IterSerializer<'ser, Option<&'ser super::CtColorXType>, super::CtColorXType>),
            AbbreviatedData(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockPathObjectXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockPathObjectXElementTypeSerializerState::Init__ => {
                            *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Actions(
                                IterSerializer::new(
                                    self.value.actions.as_ref(),
                                    Some("Actions"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(&mut bytes, "Stroke", &self.value.stroke)?;
                            helper.write_attrib(&mut bytes, "Fill", &self.value.fill)?;
                            helper.write_attrib(&mut bytes, "Rule", &self.value.rule)?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockPathObjectXElementTypeSerializerState::Clips(
                                            IterSerializer::new(
                                                self.value.clips.as_ref(),
                                                Some("Clips"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state =
                                    CtPageBlockPathObjectXElementTypeSerializerState::StrokeColor(
                                        IterSerializer::new(
                                            self.value.stroke_color.as_ref(),
                                            Some("StrokeColor"),
                                            false,
                                        ),
                                    ),
                            }
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::StrokeColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockPathObjectXElementTypeSerializerState::FillColor(
                                            IterSerializer::new(
                                                self.value.fill_color.as_ref(),
                                                Some("FillColor"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::FillColor(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state =
                                CtPageBlockPathObjectXElementTypeSerializerState::AbbreviatedData(
                                    WithSerializer::serializer(
                                        &self.value.abbreviated_data,
                                        Some("AbbreviatedData"),
                                        false,
                                    )?,
                                ),
                        },
                        CtPageBlockPathObjectXElementTypeSerializerState::AbbreviatedData(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockPathObjectXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::End__ => {
                            *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtPageBlockPathObjectXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockPathObjectXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockPathObjectXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockImageObjectXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockImageObjectXElementType,
            pub(super) state: Box<CtPageBlockImageObjectXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockImageObjectXElementTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            Border(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtImageBorderXElementType>,
                    super::CtImageBorderXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockImageObjectXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockImageObjectXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPageBlockImageObjectXElementTypeSerializerState::Actions(
                                    IterSerializer::new(
                                        self.value.actions.as_ref(),
                                        Some("Actions"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Substitution",
                                &self.value.substitution,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "ImageMask",
                                &self.value.image_mask,
                            )?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockImageObjectXElementTypeSerializerState::Clips(
                                            IterSerializer::new(
                                                self.value.clips.as_ref(),
                                                Some("Clips"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockImageObjectXElementTypeSerializerState::Border(
                                            IterSerializer::new(
                                                self.value.border.as_ref(),
                                                Some("Border"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::Border(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockImageObjectXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::End__ => {
                            *self.state = CtPageBlockImageObjectXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtPageBlockImageObjectXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockImageObjectXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockImageObjectXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockCompositeObjectXElementType,
            pub(super) state: Box<CtPageBlockCompositeObjectXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockCompositeObjectXElementTypeSerializerState<'ser> {
            Init__,
            Actions(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitActionsXElementType>,
                    super::CtGraphicUnitActionsXElementType,
                >,
            ),
            Clips(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtGraphicUnitClipsXElementType>,
                    super::CtGraphicUnitClipsXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockCompositeObjectXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeSerializerState::Actions(
                                    IterSerializer::new(
                                        self.value.actions.as_ref(),
                                        Some("Actions"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib(&mut bytes, "Visible", &self.value.visible)?;
                            helper.write_attrib_opt(&mut bytes, "CTM", &self.value.ctm)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(&mut bytes, "Alpha", &self.value.alpha)?;
                            helper.write_attrib(
                                &mut bytes,
                                "ResourceID",
                                &self.value.resource_id,
                            )?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockCompositeObjectXElementTypeSerializerState::Actions(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockCompositeObjectXElementTypeSerializerState::Clips(
                                            IterSerializer::new(
                                                self.value.clips.as_ref(),
                                                Some("Clips"),
                                                false,
                                            ),
                                        )
                                }
                            }
                        }
                        CtPageBlockCompositeObjectXElementTypeSerializerState::Clips(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockCompositeObjectXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPageBlockCompositeObjectXElementTypeSerializerState::End__ => {
                            *self.state =
                                CtPageBlockCompositeObjectXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockCompositeObjectXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        CtPageBlockCompositeObjectXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockCompositeObjectXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockCompositeObjectXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPageBlockXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockPageBlockXElementType,
            pub(super) state: Box<CtPageBlockPageBlockXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockPageBlockXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtPageBlockPageBlockXElementTypeContent],
                    super::CtPageBlockPageBlockXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockPageBlockXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPageBlockPageBlockXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPageBlockPageBlockXElementTypeSerializerState::Content__(
                                    IterSerializer::new(&self.value.content[..], None, false),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPageBlockPageBlockXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPageBlockPageBlockXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPageBlockPageBlockXElementTypeSerializerState::End__ => {
                            *self.state = CtPageBlockPageBlockXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPageBlockPageBlockXElementTypeSerializerState::Done__ => return Ok(None),
                        CtPageBlockPageBlockXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockPageBlockXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPageBlockPageBlockXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtPageBlockPageBlockXElementTypeContent,
            pub(super) state: Box<CtPageBlockPageBlockXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtPageBlockPageBlockXElementTypeContentSerializerState<'ser> {
            Init__,
            TextObject(
                <super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PathObject(
                <super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            ImageObject(
                <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            CompositeObject(
                <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageBlock(
                <super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { CtPageBlockPageBlockXElementTypeContentSerializerState :: Init__ => { match self . value { super :: CtPageBlockPageBlockXElementTypeContent :: TextObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: PathObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: ImageObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: CompositeObject (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: CtPageBlockPageBlockXElementTypeContent :: PageBlock (x) => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: TextObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: PathObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: ImageObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: CompositeObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: PageBlock (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ , } } CtPageBlockPageBlockXElementTypeContentSerializerState :: Done__ => return Ok (None) , CtPageBlockPageBlockXElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPageBlockPageBlockXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            CtPageBlockPageBlockXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPatternCellContentXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtPatternCellContentXElementType,
            pub(super) state: Box<CtPatternCellContentXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtPatternCellContentXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::CtPatternCellContentXElementTypeContent],
                    super::CtPatternCellContentXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPatternCellContentXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtPatternCellContentXElementTypeSerializerState::Init__ => {
                            *self.state =
                                CtPatternCellContentXElementTypeSerializerState::Content__(
                                    IterSerializer::new(&self.value.content[..], None, false),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Thumbnail",
                                &self.value.thumbnail,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtPatternCellContentXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtPatternCellContentXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtPatternCellContentXElementTypeSerializerState::End__ => {
                            *self.state = CtPatternCellContentXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtPatternCellContentXElementTypeSerializerState::Done__ => return Ok(None),
                        CtPatternCellContentXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPatternCellContentXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtPatternCellContentXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtPatternCellContentXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::CtPatternCellContentXElementTypeContent,
            pub(super) state: Box<CtPatternCellContentXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum CtPatternCellContentXElementTypeContentSerializerState<'ser> {
            Init__,
            TextObject(
                <super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PathObject(
                <super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            ImageObject(
                <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            CompositeObject(
                <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageBlock(
                <super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtPatternCellContentXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { CtPatternCellContentXElementTypeContentSerializerState :: Init__ => { match self . value { super :: CtPatternCellContentXElementTypeContent :: TextObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: PathObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: ImageObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: CompositeObject (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: CtPatternCellContentXElementTypeContent :: PageBlock (x) => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , } } CtPatternCellContentXElementTypeContentSerializerState :: TextObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: Done__ , } } CtPatternCellContentXElementTypeContentSerializerState :: PathObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: Done__ , } } CtPatternCellContentXElementTypeContentSerializerState :: ImageObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: Done__ , } } CtPatternCellContentXElementTypeContentSerializerState :: CompositeObject (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: Done__ , } } CtPatternCellContentXElementTypeContentSerializerState :: PageBlock (x) => { match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = CtPatternCellContentXElementTypeContentSerializerState :: Done__ , } } CtPatternCellContentXElementTypeContentSerializerState :: Done__ => return Ok (None) , CtPatternCellContentXElementTypeContentSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtPatternCellContentXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            CtPatternCellContentXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtTextTextCodeXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtTextTextCodeXElementType,
            pub(super) state: Box<CtTextTextCodeXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtTextTextCodeXElementTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtTextTextCodeXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtTextTextCodeXElementTypeSerializerState::Init__ => {
                            *self.state = CtTextTextCodeXElementTypeSerializerState::Content__(
                                WithSerializer::serializer(&self.value.content, None, false)?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(&mut bytes, "X", &self.value.x)?;
                            helper.write_attrib_opt(&mut bytes, "y", &self.value.y)?;
                            helper.write_attrib_opt(&mut bytes, "DeltaX", &self.value.delta_x)?;
                            helper.write_attrib_opt(&mut bytes, "Deltay", &self.value.deltay)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtTextTextCodeXElementTypeSerializerState::Content__(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = CtTextTextCodeXElementTypeSerializerState::End__,
                        },
                        CtTextTextCodeXElementTypeSerializerState::End__ => {
                            *self.state = CtTextTextCodeXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtTextTextCodeXElementTypeSerializerState::Done__ => return Ok(None),
                        CtTextTextCodeXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtTextTextCodeXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtTextTextCodeXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageTemplateXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageTemplateXElementType,
            pub(super) state: Box<PageTemplateXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageTemplateXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageTemplateXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageTemplateXElementTypeSerializerState::Init__ => {
                            *self.state = PageTemplateXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "TemplateID",
                                &self.value.template_id,
                            )?;
                            helper.write_attrib(&mut bytes, "ZOrder", &self.value.z_order)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        PageTemplateXElementTypeSerializerState::Done__ => return Ok(None),
                        PageTemplateXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageTemplateXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageTemplateXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageContentXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageContentXElementType,
            pub(super) state: Box<PageContentXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageContentXElementTypeSerializerState<'ser> {
            Init__,
            Layer(
                IterSerializer<
                    'ser,
                    &'ser [super::PageContentLayerXElementType],
                    super::PageContentLayerXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageContentXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageContentXElementTypeSerializerState::Init__ => {
                            *self.state = PageContentXElementTypeSerializerState::Layer(
                                IterSerializer::new(&self.value.layer[..], Some("Layer"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageContentXElementTypeSerializerState::Layer(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = PageContentXElementTypeSerializerState::End__,
                            }
                        }
                        PageContentXElementTypeSerializerState::End__ => {
                            *self.state = PageContentXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageContentXElementTypeSerializerState::Done__ => return Ok(None),
                        PageContentXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageContentXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageContentXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageContentLayerXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::PageContentLayerXElementType,
            pub(super) state: Box<PageContentLayerXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum PageContentLayerXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::PageContentLayerXElementTypeContent],
                    super::PageContentLayerXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageContentLayerXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageContentLayerXElementTypeSerializerState::Init__ => {
                            *self.state = PageContentLayerXElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DrawParam",
                                &self.value.draw_param,
                            )?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        PageContentLayerXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = PageContentLayerXElementTypeSerializerState::End__
                                }
                            }
                        }
                        PageContentLayerXElementTypeSerializerState::End__ => {
                            *self.state = PageContentLayerXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        PageContentLayerXElementTypeSerializerState::Done__ => return Ok(None),
                        PageContentLayerXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageContentLayerXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageContentLayerXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct PageContentLayerXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::PageContentLayerXElementTypeContent,
            pub(super) state: Box<PageContentLayerXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum PageContentLayerXElementTypeContentSerializerState<'ser> {
            Init__,
            TextObject(
                <super::CtPageBlockTextObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PathObject(
                <super::CtPageBlockPathObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            ImageObject(
                <super::CtPageBlockImageObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            CompositeObject(
                <super::CtPageBlockCompositeObjectXElementType as WithSerializer>::Serializer<'ser>,
            ),
            PageBlock(
                <super::CtPageBlockPageBlockXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> PageContentLayerXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        PageContentLayerXElementTypeContentSerializerState::Init__ => {
                            match self . value { super :: PageContentLayerXElementTypeContent :: TextObject (x) => * self . state = PageContentLayerXElementTypeContentSerializerState :: TextObject (WithSerializer :: serializer (x , Some ("TextObject") , false) ?) , super :: PageContentLayerXElementTypeContent :: PathObject (x) => * self . state = PageContentLayerXElementTypeContentSerializerState :: PathObject (WithSerializer :: serializer (x , Some ("PathObject") , false) ?) , super :: PageContentLayerXElementTypeContent :: ImageObject (x) => * self . state = PageContentLayerXElementTypeContentSerializerState :: ImageObject (WithSerializer :: serializer (x , Some ("ImageObject") , false) ?) , super :: PageContentLayerXElementTypeContent :: CompositeObject (x) => * self . state = PageContentLayerXElementTypeContentSerializerState :: CompositeObject (WithSerializer :: serializer (x , Some ("CompositeObject") , false) ?) , super :: PageContentLayerXElementTypeContent :: PageBlock (x) => * self . state = PageContentLayerXElementTypeContentSerializerState :: PageBlock (WithSerializer :: serializer (x , Some ("PageBlock") , false) ?) , }
                        }
                        PageContentLayerXElementTypeContentSerializerState::TextObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageContentLayerXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        PageContentLayerXElementTypeContentSerializerState::PathObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageContentLayerXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        PageContentLayerXElementTypeContentSerializerState::ImageObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageContentLayerXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        PageContentLayerXElementTypeContentSerializerState::CompositeObject(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageContentLayerXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        PageContentLayerXElementTypeContentSerializerState::PageBlock(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        PageContentLayerXElementTypeContentSerializerState::Done__
                                }
                            }
                        }
                        PageContentLayerXElementTypeContentSerializerState::Done__ => {
                            return Ok(None)
                        }
                        PageContentLayerXElementTypeContentSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for PageContentLayerXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = PageContentLayerXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod res {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    #[derive(Debug)]
    pub struct CtColorSpaceXType {
        pub type_: CtColorSpaceTypeXType,
        pub bits_per_component: i32,
        pub profile: Option<String>,
        pub palette: Option<CtColorSpacePaletteXElementType>,
    }
    impl CtColorSpaceXType {
        #[must_use]
        pub fn default_bits_per_component() -> i32 {
            8i32
        }
    }
    impl WithSerializer for CtColorSpaceXType {
        type Serializer<'x> = quick_xml_serialize::CtColorSpaceXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtColorSpaceXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtColorSpaceXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_ColorSpace"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtColorSpaceXType {
        type Deserializer = quick_xml_deserialize::CtColorSpaceXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtDrawParamXType {
        pub relative: Option<u32>,
        pub line_width: f64,
        pub join: String,
        pub cap: String,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub miter_limit: f64,
        pub fill_color: Option<super::page::CtColorXType>,
        pub stroke_color: Option<super::page::CtColorXType>,
    }
    impl CtDrawParamXType {
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_join() -> String {
            String::from("Miter")
        }
        #[must_use]
        pub fn default_cap() -> String {
            String::from("Butt")
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
    }
    impl WithSerializer for CtDrawParamXType {
        type Serializer<'x> = quick_xml_serialize::CtDrawParamXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtDrawParamXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtDrawParamXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_DrawParam"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtDrawParamXType {
        type Deserializer = quick_xml_deserialize::CtDrawParamXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtFontXType {
        pub font_name: String,
        pub family_name: Option<String>,
        pub charset: CtFontCharsetXType,
        pub italic: bool,
        pub bold: bool,
        pub serif: bool,
        pub fixed_width: bool,
        pub font_file: Option<String>,
    }
    impl CtFontXType {
        #[must_use]
        pub fn default_charset() -> CtFontCharsetXType {
            CtFontCharsetXType::Unicode
        }
        #[must_use]
        pub fn default_italic() -> bool {
            false
        }
        #[must_use]
        pub fn default_bold() -> bool {
            false
        }
        #[must_use]
        pub fn default_serif() -> bool {
            false
        }
        #[must_use]
        pub fn default_fixed_width() -> bool {
            false
        }
    }
    impl WithSerializer for CtFontXType {
        type Serializer<'x> = quick_xml_serialize::CtFontXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtFontXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtFontXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_Font"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtFontXType {
        type Deserializer = quick_xml_deserialize::CtFontXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtMultiMediaXType {
        pub type_: CtMultiMediaTypeXType,
        pub format: Option<String>,
        pub media_file: String,
    }
    impl WithSerializer for CtMultiMediaXType {
        type Serializer<'x> = quick_xml_serialize::CtMultiMediaXTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtMultiMediaXTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtMultiMediaXTypeSerializerState::Init__),
                name: name.unwrap_or("CT_MultiMedia"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtMultiMediaXType {
        type Deserializer = quick_xml_deserialize::CtMultiMediaXTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct CtVectorGxType {
        pub width: f64,
        pub height: f64,
        pub thumbnail: Option<u32>,
        pub substitution: Option<u32>,
        pub content: super::page::CtPageBlockXType,
    }
    impl WithSerializer for CtVectorGxType {
        type Serializer<'x> = quick_xml_serialize::CtVectorGxTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::CtVectorGxTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::CtVectorGxTypeSerializerState::Init__),
                name: name.unwrap_or("CT_VectorG"),
                is_root,
            })
        }
    }
    impl WithDeserializer for CtVectorGxType {
        type Deserializer = quick_xml_deserialize::CtVectorGxTypeDeserializer;
    }
    pub type Res = ResXElementType;
    #[derive(Debug)]
    pub struct ResXElementType {
        pub base_loc: String,
        pub content: Vec<ResXElementTypeContent>,
    }
    #[derive(Debug)]
    pub enum ResXElementTypeContent {
        ColorSpaces(ResColorSpacesXElementType),
        DrawParams(ResDrawParamsXElementType),
        Fonts(ResFontsXElementType),
        MultiMedias(ResMultiMediasXElementType),
        CompositeGraphicUnits(ResCompositeGraphicUnitsXElementType),
    }
    impl WithSerializer for ResXElementType {
        type Serializer<'x> = quick_xml_serialize::ResXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ResXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Res"),
                is_root,
            })
        }
    }
    impl WithSerializer for ResXElementTypeContent {
        type Serializer<'x> = quick_xml_serialize::ResXElementTypeContentSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            let _name = name;
            let _is_root = is_root;
            Ok(quick_xml_serialize::ResXElementTypeContentSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ResXElementTypeContentSerializerState::Init__),
            })
        }
    }
    impl WithDeserializer for ResXElementType {
        type Deserializer = quick_xml_deserialize::ResXElementTypeDeserializer;
    }
    impl WithDeserializer for ResXElementTypeContent {
        type Deserializer = quick_xml_deserialize::ResXElementTypeContentDeserializer;
    }
    #[derive(Debug)]
    pub enum CtColorSpaceTypeXType {
        Gray,
        Rgb,
        Cmyk,
    }
    impl SerializeBytes for CtColorSpaceTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Gray => Ok(Some(Cow::Borrowed("GRAY"))),
                Self::Rgb => Ok(Some(Cow::Borrowed("RGB"))),
                Self::Cmyk => Ok(Some(Cow::Borrowed("CMYK"))),
            }
        }
    }
    impl DeserializeBytes for CtColorSpaceTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"GRAY" => Ok(Self::Gray),
                b"RGB" => Ok(Self::Rgb),
                b"CMYK" => Ok(Self::Cmyk),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct CtColorSpacePaletteXElementType {
        pub cv: Vec<String>,
    }
    impl WithSerializer for CtColorSpacePaletteXElementType {
        type Serializer<'x> = quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::CtColorSpacePaletteXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("CtColorSpacePalette"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for CtColorSpacePaletteXElementType {
        type Deserializer = quick_xml_deserialize::CtColorSpacePaletteXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum CtFontCharsetXType {
        Symbol,
        Prc,
        Big5,
        ShiftIis,
        Wansung,
        Johab,
        Unicode,
    }
    impl SerializeBytes for CtFontCharsetXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Symbol => Ok(Some(Cow::Borrowed("symbol"))),
                Self::Prc => Ok(Some(Cow::Borrowed("prc"))),
                Self::Big5 => Ok(Some(Cow::Borrowed("big5"))),
                Self::ShiftIis => Ok(Some(Cow::Borrowed("shift-iis"))),
                Self::Wansung => Ok(Some(Cow::Borrowed("wansung"))),
                Self::Johab => Ok(Some(Cow::Borrowed("johab"))),
                Self::Unicode => Ok(Some(Cow::Borrowed("unicode"))),
            }
        }
    }
    impl DeserializeBytes for CtFontCharsetXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"symbol" => Ok(Self::Symbol),
                b"prc" => Ok(Self::Prc),
                b"big5" => Ok(Self::Big5),
                b"shift-iis" => Ok(Self::ShiftIis),
                b"wansung" => Ok(Self::Wansung),
                b"johab" => Ok(Self::Johab),
                b"unicode" => Ok(Self::Unicode),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub enum CtMultiMediaTypeXType {
        Image,
        Audio,
        Video,
    }
    impl SerializeBytes for CtMultiMediaTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Image => Ok(Some(Cow::Borrowed("Image"))),
                Self::Audio => Ok(Some(Cow::Borrowed("Audio"))),
                Self::Video => Ok(Some(Cow::Borrowed("Video"))),
            }
        }
    }
    impl DeserializeBytes for CtMultiMediaTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Image" => Ok(Self::Image),
                b"Audio" => Ok(Self::Audio),
                b"Video" => Ok(Self::Video),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct ResColorSpacesXElementType {
        pub color_space: Vec<ResColorSpacesColorSpaceXElementType>,
    }
    impl WithSerializer for ResColorSpacesXElementType {
        type Serializer<'x> = quick_xml_serialize::ResColorSpacesXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResColorSpacesXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ResColorSpacesXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ResColorSpaces"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ResColorSpacesXElementType {
        type Deserializer = quick_xml_deserialize::ResColorSpacesXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResDrawParamsXElementType {
        pub draw_param: Vec<ResDrawParamsDrawParamXElementType>,
    }
    impl WithSerializer for ResDrawParamsXElementType {
        type Serializer<'x> = quick_xml_serialize::ResDrawParamsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResDrawParamsXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ResDrawParamsXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ResDrawParams"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ResDrawParamsXElementType {
        type Deserializer = quick_xml_deserialize::ResDrawParamsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResFontsXElementType {
        pub font: Vec<ResFontsFontXElementType>,
    }
    impl WithSerializer for ResFontsXElementType {
        type Serializer<'x> = quick_xml_serialize::ResFontsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResFontsXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::ResFontsXElementTypeSerializerState::Init__),
                name: name.unwrap_or("ResFonts"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ResFontsXElementType {
        type Deserializer = quick_xml_deserialize::ResFontsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResMultiMediasXElementType {
        pub multi_media: Vec<ResMultiMediasMultiMediaXElementType>,
    }
    impl WithSerializer for ResMultiMediasXElementType {
        type Serializer<'x> = quick_xml_serialize::ResMultiMediasXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResMultiMediasXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ResMultiMediasXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ResMultiMedias"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ResMultiMediasXElementType {
        type Deserializer = quick_xml_deserialize::ResMultiMediasXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsXElementType {
        pub composite_graphic_unit: Vec<ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>,
    }
    impl WithSerializer for ResCompositeGraphicUnitsXElementType {
        type Serializer<'x> =
            quick_xml_serialize::ResCompositeGraphicUnitsXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: ResCompositeGraphicUnitsXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResCompositeGraphicUnitsXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResCompositeGraphicUnits") , is_root , })
        }
    }
    impl WithDeserializer for ResCompositeGraphicUnitsXElementType {
        type Deserializer = quick_xml_deserialize::ResCompositeGraphicUnitsXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResColorSpacesColorSpaceXElementType {
        pub type_: CtColorSpaceTypeXType,
        pub bits_per_component: i32,
        pub profile: Option<String>,
        pub id: u32,
        pub palette: Option<CtColorSpacePaletteXElementType>,
    }
    impl ResColorSpacesColorSpaceXElementType {
        #[must_use]
        pub fn default_bits_per_component() -> i32 {
            8i32
        }
    }
    impl WithSerializer for ResColorSpacesColorSpaceXElementType {
        type Serializer<'x> =
            quick_xml_serialize::ResColorSpacesColorSpaceXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: ResColorSpacesColorSpaceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResColorSpacesColorSpaceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResColorSpacesColorSpace") , is_root , })
        }
    }
    impl WithDeserializer for ResColorSpacesColorSpaceXElementType {
        type Deserializer = quick_xml_deserialize::ResColorSpacesColorSpaceXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResDrawParamsDrawParamXElementType {
        pub relative: Option<u32>,
        pub line_width: f64,
        pub join: String,
        pub cap: String,
        pub dash_offset: f64,
        pub dash_pattern: Option<String>,
        pub miter_limit: f64,
        pub id: u32,
        pub fill_color: Option<super::page::CtColorXType>,
        pub stroke_color: Option<super::page::CtColorXType>,
    }
    impl ResDrawParamsDrawParamXElementType {
        #[must_use]
        pub fn default_line_width() -> f64 {
            0.353f64
        }
        #[must_use]
        pub fn default_join() -> String {
            String::from("Miter")
        }
        #[must_use]
        pub fn default_cap() -> String {
            String::from("Butt")
        }
        #[must_use]
        pub fn default_dash_offset() -> f64 {
            0f64
        }
        #[must_use]
        pub fn default_miter_limit() -> f64 {
            4.234f64
        }
    }
    impl WithSerializer for ResDrawParamsDrawParamXElementType {
        type Serializer<'x> = quick_xml_serialize::ResDrawParamsDrawParamXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: ResDrawParamsDrawParamXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResDrawParamsDrawParamXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResDrawParamsDrawParam") , is_root , })
        }
    }
    impl WithDeserializer for ResDrawParamsDrawParamXElementType {
        type Deserializer = quick_xml_deserialize::ResDrawParamsDrawParamXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResFontsFontXElementType {
        pub font_name: String,
        pub family_name: Option<String>,
        pub charset: CtFontCharsetXType,
        pub italic: bool,
        pub bold: bool,
        pub serif: bool,
        pub fixed_width: bool,
        pub id: u32,
        pub font_file: Option<String>,
    }
    impl ResFontsFontXElementType {
        #[must_use]
        pub fn default_charset() -> CtFontCharsetXType {
            CtFontCharsetXType::Unicode
        }
        #[must_use]
        pub fn default_italic() -> bool {
            false
        }
        #[must_use]
        pub fn default_bold() -> bool {
            false
        }
        #[must_use]
        pub fn default_serif() -> bool {
            false
        }
        #[must_use]
        pub fn default_fixed_width() -> bool {
            false
        }
    }
    impl WithSerializer for ResFontsFontXElementType {
        type Serializer<'x> = quick_xml_serialize::ResFontsFontXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::ResFontsFontXElementTypeSerializer {
                value: self,
                state: Box::new(
                    quick_xml_serialize::ResFontsFontXElementTypeSerializerState::Init__,
                ),
                name: name.unwrap_or("ResFontsFont"),
                is_root,
            })
        }
    }
    impl WithDeserializer for ResFontsFontXElementType {
        type Deserializer = quick_xml_deserialize::ResFontsFontXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResMultiMediasMultiMediaXElementType {
        pub type_: CtMultiMediaTypeXType,
        pub format: Option<String>,
        pub id: u32,
        pub media_file: String,
    }
    impl WithSerializer for ResMultiMediasMultiMediaXElementType {
        type Serializer<'x> =
            quick_xml_serialize::ResMultiMediasMultiMediaXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: ResMultiMediasMultiMediaXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResMultiMediasMultiMediaXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResMultiMediasMultiMedia") , is_root , })
        }
    }
    impl WithDeserializer for ResMultiMediasMultiMediaXElementType {
        type Deserializer = quick_xml_deserialize::ResMultiMediasMultiMediaXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
        pub width: f64,
        pub height: f64,
        pub id: u32,
        pub thumbnail: Option<u32>,
        pub substitution: Option<u32>,
        pub content: super::page::CtPageBlockXType,
    }
    impl WithSerializer for ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
        type Serializer<'x> =
            quick_xml_serialize::ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<
                'x,
            >;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("ResCompositeGraphicUnitsCompositeGraphicUnit") , is_root , })
        }
    }
    impl WithDeserializer for ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
        type Deserializer = quick_xml_deserialize :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer ;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct CtColorSpaceXTypeDeserializer {
            type_: super::CtColorSpaceTypeXType,
            bits_per_component: i32,
            profile: Option<String>,
            palette: Option<super::CtColorSpacePaletteXElementType>,
            state__: Box<CtColorSpaceXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtColorSpaceXTypeDeserializerState {
            Init__,
            Palette(
                Option<<super::CtColorSpacePaletteXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtColorSpaceXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtColorSpaceTypeXType> = None;
                let mut bits_per_component: Option<i32> = None;
                let mut profile: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BitsPerComponent")
                    ) {
                        helper.read_attrib(
                            &mut bits_per_component,
                            b"BitsPerComponent",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Profile")
                    ) {
                        helper.read_attrib(&mut profile, b"Profile", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    bits_per_component: bits_per_component
                        .unwrap_or_else(super::CtColorSpaceXType::default_bits_per_component),
                    profile: profile,
                    palette: None,
                    state__: Box::new(CtColorSpaceXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtColorSpaceXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtColorSpaceXTypeDeserializerState as S;
                match state {
                    S::Palette(Some(deserializer)) => {
                        self.store_palette(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_palette(
                &mut self,
                value: super::CtColorSpacePaletteXElementType,
            ) -> Result<(), Error> {
                if self.palette.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Palette",
                    )))?;
                }
                self.palette = Some(value);
                Ok(())
            }
            fn handle_palette<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorSpacePaletteXElementType>,
                fallback: &mut Option<CtColorSpaceXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorSpaceXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Palette(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_palette(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Palette(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtColorSpaceXType> for CtColorSpaceXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorSpaceXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorSpaceXType> {
                use CtColorSpaceXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Palette(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_palette(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Palette(None);
                            event
                        }
                        (S::Palette(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Palette",
                                false,
                            )?;
                            match self.handle_palette(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtColorSpaceXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtColorSpaceXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtColorSpaceXType {
                    type_: self.type_,
                    bits_per_component: self.bits_per_component,
                    profile: self.profile,
                    palette: self.palette,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtDrawParamXTypeDeserializer {
            relative: Option<u32>,
            line_width: f64,
            join: String,
            cap: String,
            dash_offset: f64,
            dash_pattern: Option<String>,
            miter_limit: f64,
            fill_color: Option<super::super::page::CtColorXType>,
            stroke_color: Option<super::super::page::CtColorXType>,
            state__: Box<CtDrawParamXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtDrawParamXTypeDeserializerState {
            Init__,
            FillColor(Option<<super::super::page::CtColorXType as WithDeserializer>::Deserializer>),
            StrokeColor(
                Option<<super::super::page::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtDrawParamXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut relative: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut join: Option<String> = None;
                let mut cap: Option<String> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut miter_limit: Option<f64> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Relative")
                    ) {
                        helper.read_attrib(&mut relative, b"Relative", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    relative: relative,
                    line_width: line_width
                        .unwrap_or_else(super::CtDrawParamXType::default_line_width),
                    join: join.unwrap_or_else(super::CtDrawParamXType::default_join),
                    cap: cap.unwrap_or_else(super::CtDrawParamXType::default_cap),
                    dash_offset: dash_offset
                        .unwrap_or_else(super::CtDrawParamXType::default_dash_offset),
                    dash_pattern: dash_pattern,
                    miter_limit: miter_limit
                        .unwrap_or_else(super::CtDrawParamXType::default_miter_limit),
                    fill_color: None,
                    stroke_color: None,
                    state__: Box::new(CtDrawParamXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtDrawParamXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtDrawParamXTypeDeserializerState as S;
                match state {
                    S::FillColor(Some(deserializer)) => {
                        self.store_fill_color(deserializer.finish(helper)?)?
                    }
                    S::StrokeColor(Some(deserializer)) => {
                        self.store_stroke_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_fill_color(
                &mut self,
                value: super::super::page::CtColorXType,
            ) -> Result<(), Error> {
                if self.fill_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                self.fill_color = Some(value);
                Ok(())
            }
            fn store_stroke_color(
                &mut self,
                value: super::super::page::CtColorXType,
            ) -> Result<(), Error> {
                if self.stroke_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                self.stroke_color = Some(value);
                Ok(())
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtColorXType>,
                fallback: &mut Option<CtDrawParamXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDrawParamXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FillColor(None));
                    *self.state__ = S::StrokeColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fill_color(data)?;
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FillColor(Some(deserializer)));
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtColorXType>,
                fallback: &mut Option<CtDrawParamXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtDrawParamXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::StrokeColor(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_stroke_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::StrokeColor(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtDrawParamXType> for CtDrawParamXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDrawParamXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtDrawParamXType> {
                use CtDrawParamXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FillColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FillColor(None);
                            event
                        }
                        (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtDrawParamXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtDrawParamXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtDrawParamXType {
                    relative: self.relative,
                    line_width: self.line_width,
                    join: self.join,
                    cap: self.cap,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    miter_limit: self.miter_limit,
                    fill_color: self.fill_color,
                    stroke_color: self.stroke_color,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtFontXTypeDeserializer {
            font_name: String,
            family_name: Option<String>,
            charset: super::CtFontCharsetXType,
            italic: bool,
            bold: bool,
            serif: bool,
            fixed_width: bool,
            font_file: Option<String>,
            state__: Box<CtFontXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtFontXTypeDeserializerState {
            Init__,
            FontFile(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtFontXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut font_name: Option<String> = None;
                let mut family_name: Option<String> = None;
                let mut charset: Option<super::CtFontCharsetXType> = None;
                let mut italic: Option<bool> = None;
                let mut bold: Option<bool> = None;
                let mut serif: Option<bool> = None;
                let mut fixed_width: Option<bool> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FontName")
                    ) {
                        helper.read_attrib(&mut font_name, b"FontName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FamilyName")
                    ) {
                        helper.read_attrib(&mut family_name, b"FamilyName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Charset")
                    ) {
                        helper.read_attrib(&mut charset, b"Charset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Italic")
                    ) {
                        helper.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Bold")
                    ) {
                        helper.read_attrib(&mut bold, b"Bold", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Serif")
                    ) {
                        helper.read_attrib(&mut serif, b"Serif", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FixedWidth")
                    ) {
                        helper.read_attrib(&mut fixed_width, b"FixedWidth", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    font_name: font_name
                        .ok_or_else(|| ErrorKind::MissingAttribute("FontName".into()))?,
                    family_name: family_name,
                    charset: charset.unwrap_or_else(super::CtFontXType::default_charset),
                    italic: italic.unwrap_or_else(super::CtFontXType::default_italic),
                    bold: bold.unwrap_or_else(super::CtFontXType::default_bold),
                    serif: serif.unwrap_or_else(super::CtFontXType::default_serif),
                    fixed_width: fixed_width
                        .unwrap_or_else(super::CtFontXType::default_fixed_width),
                    font_file: None,
                    state__: Box::new(CtFontXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtFontXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtFontXTypeDeserializerState as S;
                match state {
                    S::FontFile(Some(deserializer)) => {
                        self.store_font_file(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_font_file(&mut self, value: String) -> Result<(), Error> {
                if self.font_file.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FontFile",
                    )))?;
                }
                self.font_file = Some(value);
                Ok(())
            }
            fn handle_font_file<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtFontXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtFontXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FontFile(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_font_file(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FontFile(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtFontXType> for CtFontXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtFontXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtFontXType> {
                use CtFontXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FontFile(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_font_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FontFile(None);
                            event
                        }
                        (S::FontFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FontFile",
                                false,
                            )?;
                            match self.handle_font_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtFontXType, Error> {
                let state = replace(&mut *self.state__, CtFontXTypeDeserializerState::Unknown__);
                self.finish_state(helper, state)?;
                Ok(super::CtFontXType {
                    font_name: self.font_name,
                    family_name: self.family_name,
                    charset: self.charset,
                    italic: self.italic,
                    bold: self.bold,
                    serif: self.serif,
                    fixed_width: self.fixed_width,
                    font_file: self.font_file,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtMultiMediaXTypeDeserializer {
            type_: super::CtMultiMediaTypeXType,
            format: Option<String>,
            media_file: Option<String>,
            state__: Box<CtMultiMediaXTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtMultiMediaXTypeDeserializerState {
            Init__,
            MediaFile(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtMultiMediaXTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtMultiMediaTypeXType> = None;
                let mut format: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Format")
                    ) {
                        helper.read_attrib(&mut format, b"Format", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    format: format,
                    media_file: None,
                    state__: Box::new(CtMultiMediaXTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtMultiMediaXTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtMultiMediaXTypeDeserializerState as S;
                match state {
                    S::MediaFile(Some(deserializer)) => {
                        self.store_media_file(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_media_file(&mut self, value: String) -> Result<(), Error> {
                if self.media_file.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"MediaFile",
                    )))?;
                }
                self.media_file = Some(value);
                Ok(())
            }
            fn handle_media_file<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtMultiMediaXTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtMultiMediaXTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::MediaFile(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_media_file(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::MediaFile(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtMultiMediaXType> for CtMultiMediaXTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtMultiMediaXType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtMultiMediaXType> {
                use CtMultiMediaXTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::MediaFile(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_media_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::MediaFile(None);
                            event
                        }
                        (S::MediaFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MediaFile",
                                false,
                            )?;
                            match self.handle_media_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtMultiMediaXType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtMultiMediaXTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtMultiMediaXType {
                    type_: self.type_,
                    format: self.format,
                    media_file: helper.finish_element("MediaFile", self.media_file)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct CtVectorGxTypeDeserializer {
            width: f64,
            height: f64,
            thumbnail: Option<u32>,
            substitution: Option<u32>,
            content: Option<super::super::page::CtPageBlockXType>,
            state__: Box<CtVectorGxTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtVectorGxTypeDeserializerState {
            Init__,
            Thumbnail(Option<<u32 as WithDeserializer>::Deserializer>),
            Substitution(Option<<u32 as WithDeserializer>::Deserializer>),
            Content(
                Option<<super::super::page::CtPageBlockXType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl CtVectorGxTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut width: Option<f64> = None;
                let mut height: Option<f64> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Width")
                    ) {
                        helper.read_attrib(&mut width, b"Width", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Height")
                    ) {
                        helper.read_attrib(&mut height, b"Height", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    width: width.ok_or_else(|| ErrorKind::MissingAttribute("Width".into()))?,
                    height: height.ok_or_else(|| ErrorKind::MissingAttribute("Height".into()))?,
                    thumbnail: None,
                    substitution: None,
                    content: None,
                    state__: Box::new(CtVectorGxTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtVectorGxTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtVectorGxTypeDeserializerState as S;
                match state {
                    S::Thumbnail(Some(deserializer)) => {
                        self.store_thumbnail(deserializer.finish(helper)?)?
                    }
                    S::Substitution(Some(deserializer)) => {
                        self.store_substitution(deserializer.finish(helper)?)?
                    }
                    S::Content(Some(deserializer)) => {
                        self.store_content(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_thumbnail(&mut self, value: u32) -> Result<(), Error> {
                if self.thumbnail.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Thumbnail",
                    )))?;
                }
                self.thumbnail = Some(value);
                Ok(())
            }
            fn store_substitution(&mut self, value: u32) -> Result<(), Error> {
                if self.substitution.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Substitution",
                    )))?;
                }
                self.substitution = Some(value);
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::super::page::CtPageBlockXType,
            ) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Content",
                    )))?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_thumbnail<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<CtVectorGxTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVectorGxTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Thumbnail(None));
                    *self.state__ = S::Substitution(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_thumbnail(data)?;
                        *self.state__ = S::Substitution(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Thumbnail(Some(deserializer)));
                        *self.state__ = S::Substitution(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_substitution<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<CtVectorGxTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVectorGxTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Substitution(None));
                    *self.state__ = S::Content(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_substitution(data)?;
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Substitution(Some(deserializer)));
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtPageBlockXType>,
                fallback: &mut Option<CtVectorGxTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtVectorGxTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Content(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Content(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtVectorGxType> for CtVectorGxTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVectorGxType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtVectorGxType> {
                use CtVectorGxTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Thumbnail(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_thumbnail(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Substitution(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_substitution(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Thumbnail(None);
                            event
                        }
                        (S::Thumbnail(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Thumbnail",
                                false,
                            )?;
                            match self.handle_thumbnail(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Substitution(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Substitution",
                                false,
                            )?;
                            match self.handle_substitution(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Content",
                                true,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtVectorGxType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtVectorGxTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtVectorGxType {
                    width: self.width,
                    height: self.height,
                    thumbnail: self.thumbnail,
                    substitution: self.substitution,
                    content: helper.finish_element("Content", self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResXElementTypeDeserializer {
            base_loc: String,
            content: Vec<super::ResXElementTypeContent>,
            state__: Box<ResXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResXElementTypeDeserializerState {
            Init__,
            Next__,
            Content__(<super::ResXElementTypeContent as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl ResXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut base_loc: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BaseLoc")
                    ) {
                        helper.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    base_loc: base_loc
                        .ok_or_else(|| ErrorKind::MissingAttribute("BaseLoc".into()))?,
                    content: Vec::new(),
                    state__: Box::new(ResXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let ResXElementTypeDeserializerState::Content__(deserializer) = state {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: super::ResXElementTypeContent) -> Result<(), Error> {
                self.content.push(value);
                Ok(())
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::ResXElementTypeContent>,
                fallback: &mut Option<ResXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    *self.state__ = fallback.take().unwrap_or(S::Next__);
                    return Ok(ElementHandlerOutput::from_event_end(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *fallback = Some(S::Content__(deserializer));
                        *self.state__ = S::Next__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResXElementType> for ResXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResXElementType> {
                use ResXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Content__(deserializer), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (_, Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (state @ (S::Init__ | S::Next__), event) => {
                            fallback.get_or_insert(state);
                            let output = <super::ResXElementTypeContent as WithDeserializer>::init(
                                helper, event,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                let artifact = DeserializerArtifact::Deserializer(self);
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResXElementType {
                    base_loc: self.base_loc,
                    content: helper.finish_vec(0usize, None, self.content)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResXElementTypeContentDeserializer {
            state__: Box<ResXElementTypeContentDeserializerState>,
        }
        #[derive(Debug)]
        pub enum ResXElementTypeContentDeserializerState {
            Init__,
            ColorSpaces(
                Option<super::ResColorSpacesXElementType>,
                Option<<super::ResColorSpacesXElementType as WithDeserializer>::Deserializer>,
                Option<<super::ResColorSpacesXElementType as WithDeserializer>::Deserializer>,
            ),
            DrawParams(
                Option<super::ResDrawParamsXElementType>,
                Option<<super::ResDrawParamsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::ResDrawParamsXElementType as WithDeserializer>::Deserializer>,
            ),
            Fonts(
                Option<super::ResFontsXElementType>,
                Option<<super::ResFontsXElementType as WithDeserializer>::Deserializer>,
                Option<<super::ResFontsXElementType as WithDeserializer>::Deserializer>,
            ),
            MultiMedias(
                Option<super::ResMultiMediasXElementType>,
                Option<<super::ResMultiMediasXElementType as WithDeserializer>::Deserializer>,
                Option<<super::ResMultiMediasXElementType as WithDeserializer>::Deserializer>,
            ),
            CompositeGraphicUnits(
                Option<super::ResCompositeGraphicUnitsXElementType>,
                Option<
                    <super::ResCompositeGraphicUnitsXElementType as WithDeserializer>::Deserializer,
                >,
                Option<
                    <super::ResCompositeGraphicUnitsXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__(super::ResXElementTypeContent),
            Unknown__,
        }
        impl ResXElementTypeContentDeserializer {
            fn find_suitable<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                if let Event::Start(x) | Event::Empty(x) = &event {
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"ColorSpaces")
                    ) {
                        let output = <super::ResColorSpacesXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_color_spaces(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"DrawParams")
                    ) {
                        let output = <super::ResDrawParamsXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_draw_params(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"Fonts")
                    ) {
                        let output =
                            <super::ResFontsXElementType as WithDeserializer>::init(helper, event)?;
                        return self.handle_fonts(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"MultiMedias")
                    ) {
                        let output = <super::ResMultiMediasXElementType as WithDeserializer>::init(
                            helper, event,
                        )?;
                        return self.handle_multi_medias(helper, Default::default(), None, output);
                    }
                    if matches!(
                        helper.resolve_local_name(x.name(), &super::super::NS_UNNAMED_2),
                        Some(b"CompositeGraphicUnits")
                    ) {
                        let output = < super :: ResCompositeGraphicUnitsXElementType as WithDeserializer > :: init (helper , event) ? ;
                        return self.handle_composite_graphic_units(
                            helper,
                            Default::default(),
                            None,
                            output,
                        );
                    }
                }
                *self.state__ = ResXElementTypeContentDeserializerState::Init__;
                Ok(ElementHandlerOutput::return_to_parent(event, false))
            }
            fn finish_state(
                helper: &mut DeserializeHelper,
                state: ResXElementTypeContentDeserializerState,
            ) -> Result<super::ResXElementTypeContent, Error> {
                use ResXElementTypeContentDeserializerState as S;
                match state {
                    S::Init__ => Err(ErrorKind::MissingContent.into()),
                    S::ColorSpaces(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_color_spaces(&mut values, value)?;
                        }
                        Ok(super::ResXElementTypeContent::ColorSpaces(
                            helper.finish_element("ColorSpaces", values)?,
                        ))
                    }
                    S::DrawParams(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_draw_params(&mut values, value)?;
                        }
                        Ok(super::ResXElementTypeContent::DrawParams(
                            helper.finish_element("DrawParams", values)?,
                        ))
                    }
                    S::Fonts(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_fonts(&mut values, value)?;
                        }
                        Ok(super::ResXElementTypeContent::Fonts(
                            helper.finish_element("Fonts", values)?,
                        ))
                    }
                    S::MultiMedias(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_multi_medias(&mut values, value)?;
                        }
                        Ok(super::ResXElementTypeContent::MultiMedias(
                            helper.finish_element("MultiMedias", values)?,
                        ))
                    }
                    S::CompositeGraphicUnits(mut values, None, deserializer) => {
                        if let Some(deserializer) = deserializer {
                            let value = deserializer.finish(helper)?;
                            Self::store_composite_graphic_units(&mut values, value)?;
                        }
                        Ok(super::ResXElementTypeContent::CompositeGraphicUnits(
                            helper.finish_element("CompositeGraphicUnits", values)?,
                        ))
                    }
                    S::Done__(data) => Ok(data),
                    _ => unreachable!(),
                }
            }
            fn store_color_spaces(
                values: &mut Option<super::ResColorSpacesXElementType>,
                value: super::ResColorSpacesXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"ColorSpaces",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_draw_params(
                values: &mut Option<super::ResDrawParamsXElementType>,
                value: super::ResDrawParamsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DrawParams",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_fonts(
                values: &mut Option<super::ResFontsXElementType>,
                value: super::ResFontsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Fonts",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_multi_medias(
                values: &mut Option<super::ResMultiMediasXElementType>,
                value: super::ResMultiMediasXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"MultiMedias",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn store_composite_graphic_units(
                values: &mut Option<super::ResCompositeGraphicUnitsXElementType>,
                value: super::ResCompositeGraphicUnitsXElementType,
            ) -> Result<(), Error> {
                if values.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CompositeGraphicUnits",
                    )))?;
                }
                *values = Some(value);
                Ok(())
            }
            fn handle_color_spaces<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::ResColorSpacesXElementType>,
                fallback: Option<
                    <super::ResColorSpacesXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::ResColorSpacesXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_color_spaces(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_color_spaces(&mut values, data)?;
                        let data = Self::finish_state(helper, S::ColorSpaces(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::ColorSpaces(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_draw_params<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::ResDrawParamsXElementType>,
                fallback: Option<
                    <super::ResDrawParamsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::ResDrawParamsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_draw_params(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_draw_params(&mut values, data)?;
                        let data = Self::finish_state(helper, S::DrawParams(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::DrawParams(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_fonts<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::ResFontsXElementType>,
                fallback: Option<<super::ResFontsXElementType as WithDeserializer>::Deserializer>,
                output: DeserializerOutput<'de, super::ResFontsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_fonts(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_fonts(&mut values, data)?;
                        let data = Self::finish_state(helper, S::Fonts(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Fonts(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_multi_medias<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::ResMultiMediasXElementType>,
                fallback: Option<
                    <super::ResMultiMediasXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::ResMultiMediasXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_multi_medias(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_multi_medias(&mut values, data)?;
                        let data = Self::finish_state(helper, S::MultiMedias(values, None, None))?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::MultiMedias(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
            fn handle_composite_graphic_units<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                mut values: Option<super::ResCompositeGraphicUnitsXElementType>,
                fallback: Option<
                    <super::ResCompositeGraphicUnitsXElementType as WithDeserializer>::Deserializer,
                >,
                output: DeserializerOutput<'de, super::ResCompositeGraphicUnitsXElementType>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResXElementTypeContentDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                }
                if let Some(deserializer) = fallback {
                    let data = deserializer.finish(helper)?;
                    Self::store_composite_graphic_units(&mut values, data)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        Self::store_composite_graphic_units(&mut values, data)?;
                        let data = Self::finish_state(
                            helper,
                            S::CompositeGraphicUnits(values, None, None),
                        )?;
                        *self.state__ = S::Done__(data);
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::CompositeGraphicUnits(values, None, Some(deserializer));
                        Ok(ElementHandlerOutput::break_(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResXElementTypeContent> for ResXElementTypeContentDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResXElementTypeContent> {
                let deserializer = Self {
                    state__: Box::new(ResXElementTypeContentDeserializerState::Init__),
                };
                let mut output = deserializer.next(helper, event)?;
                output.artifact = match output.artifact {
                    DeserializerArtifact::Deserializer(x)
                        if matches!(
                            &*x.state__,
                            ResXElementTypeContentDeserializerState::Init__
                        ) =>
                    {
                        DeserializerArtifact::None
                    }
                    artifact => artifact,
                };
                Ok(output)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResXElementTypeContent> {
                use ResXElementTypeContentDeserializerState as S;
                let mut event = event;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::ColorSpaces(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_color_spaces(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::DrawParams(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_draw_params(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::Fonts(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fonts(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::MultiMedias(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_multi_medias(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (S::CompositeGraphicUnits(values, fallback, Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self
                                .handle_composite_graphic_units(helper, values, fallback, output)?
                            {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state, event @ Event::End(_)) => {
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(Self::finish_state(
                                    helper, state,
                                )?),
                                event: DeserializerEvent::Continue(event),
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => match self.find_suitable(helper, event)? {
                            ElementHandlerOutput::Break { event, allow_any } => {
                                break (event, allow_any)
                            }
                            ElementHandlerOutput::Continue { event, .. } => event,
                        },
                        (
                            S::ColorSpaces(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ColorSpaces",
                                false,
                            )?;
                            match self.handle_color_spaces(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::DrawParams(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DrawParams",
                                true,
                            )?;
                            match self.handle_draw_params(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::Fonts(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Fonts",
                                false,
                            )?;
                            match self.handle_fonts(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::MultiMedias(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MultiMedias",
                                false,
                            )?;
                            match self.handle_multi_medias(helper, values, fallback, output)? {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (
                            S::CompositeGraphicUnits(values, fallback, None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeGraphicUnits",
                                false,
                            )?;
                            match self
                                .handle_composite_graphic_units(helper, values, fallback, output)?
                            {
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                                ElementHandlerOutput::Continue { event, .. } => event,
                            }
                        }
                        (state @ S::Done__(_), event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Continue(event), false);
                        }
                    }
                };
                let artifact = if matches!(&*self.state__, S::Done__(_)) {
                    DeserializerArtifact::Data(self.finish(helper)?)
                } else {
                    DeserializerArtifact::Deserializer(self)
                };
                Ok(DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                })
            }
            fn finish(
                self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResXElementTypeContent, Error> {
                Self::finish_state(helper, *self.state__)
            }
        }
        #[derive(Debug)]
        pub struct CtColorSpacePaletteXElementTypeDeserializer {
            cv: Vec<String>,
            state__: Box<CtColorSpacePaletteXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum CtColorSpacePaletteXElementTypeDeserializerState {
            Init__,
            Cv(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl CtColorSpacePaletteXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    cv: Vec::new(),
                    state__: Box::new(CtColorSpacePaletteXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: CtColorSpacePaletteXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use CtColorSpacePaletteXElementTypeDeserializerState as S;
                match state {
                    S::Cv(Some(deserializer)) => self.store_cv(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_cv(&mut self, value: String) -> Result<(), Error> {
                self.cv.push(value);
                Ok(())
            }
            fn handle_cv<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<CtColorSpacePaletteXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use CtColorSpacePaletteXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.cv.len() < 1usize {
                        fallback.get_or_insert(S::Cv(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Cv(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_cv(data)?;
                        *self.state__ = S::Cv(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Cv(Some(deserializer)));
                        *self.state__ = S::Cv(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::CtColorSpacePaletteXElementType>
            for CtColorSpacePaletteXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorSpacePaletteXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::CtColorSpacePaletteXElementType> {
                use CtColorSpacePaletteXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Cv(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_cv(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Cv(None);
                            event
                        }
                        (S::Cv(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CV",
                                false,
                            )?;
                            match self.handle_cv(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::CtColorSpacePaletteXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    CtColorSpacePaletteXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::CtColorSpacePaletteXElementType {
                    cv: helper.finish_vec(1usize, None, self.cv)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResColorSpacesXElementTypeDeserializer {
            color_space: Vec<super::ResColorSpacesColorSpaceXElementType>,
            state__: Box<ResColorSpacesXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResColorSpacesXElementTypeDeserializerState {
            Init__,
            ColorSpace(
                Option<
                    <super::ResColorSpacesColorSpaceXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl ResColorSpacesXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    color_space: Vec::new(),
                    state__: Box::new(ResColorSpacesXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResColorSpacesXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResColorSpacesXElementTypeDeserializerState as S;
                match state {
                    S::ColorSpace(Some(deserializer)) => {
                        self.store_color_space(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_color_space(
                &mut self,
                value: super::ResColorSpacesColorSpaceXElementType,
            ) -> Result<(), Error> {
                self.color_space.push(value);
                Ok(())
            }
            fn handle_color_space<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::ResColorSpacesColorSpaceXElementType>,
                fallback: &mut Option<ResColorSpacesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResColorSpacesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.color_space.len() < 1usize {
                        fallback.get_or_insert(S::ColorSpace(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::ColorSpace(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_color_space(data)?;
                        *self.state__ = S::ColorSpace(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::ColorSpace(Some(deserializer)));
                        *self.state__ = S::ColorSpace(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResColorSpacesXElementType>
            for ResColorSpacesXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResColorSpacesXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResColorSpacesXElementType> {
                use ResColorSpacesXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::ColorSpace(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_color_space(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::ColorSpace(None);
                            event
                        }
                        (S::ColorSpace(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"ColorSpace",
                                false,
                            )?;
                            match self.handle_color_space(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResColorSpacesXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResColorSpacesXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResColorSpacesXElementType {
                    color_space: helper.finish_vec(1usize, None, self.color_space)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResDrawParamsXElementTypeDeserializer {
            draw_param: Vec<super::ResDrawParamsDrawParamXElementType>,
            state__: Box<ResDrawParamsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResDrawParamsXElementTypeDeserializerState {
            Init__,
            DrawParam(
                Option<
                    <super::ResDrawParamsDrawParamXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl ResDrawParamsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    draw_param: Vec::new(),
                    state__: Box::new(ResDrawParamsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResDrawParamsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResDrawParamsXElementTypeDeserializerState as S;
                match state {
                    S::DrawParam(Some(deserializer)) => {
                        self.store_draw_param(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_draw_param(
                &mut self,
                value: super::ResDrawParamsDrawParamXElementType,
            ) -> Result<(), Error> {
                self.draw_param.push(value);
                Ok(())
            }
            fn handle_draw_param<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::ResDrawParamsDrawParamXElementType>,
                fallback: &mut Option<ResDrawParamsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResDrawParamsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.draw_param.len() < 1usize {
                        fallback.get_or_insert(S::DrawParam(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::DrawParam(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_draw_param(data)?;
                        *self.state__ = S::DrawParam(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DrawParam(Some(deserializer)));
                        *self.state__ = S::DrawParam(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResDrawParamsXElementType>
            for ResDrawParamsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResDrawParamsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResDrawParamsXElementType> {
                use ResDrawParamsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::DrawParam(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_draw_param(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::DrawParam(None);
                            event
                        }
                        (S::DrawParam(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DrawParam",
                                true,
                            )?;
                            match self.handle_draw_param(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResDrawParamsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResDrawParamsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResDrawParamsXElementType {
                    draw_param: helper.finish_vec(1usize, None, self.draw_param)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResFontsXElementTypeDeserializer {
            font: Vec<super::ResFontsFontXElementType>,
            state__: Box<ResFontsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResFontsXElementTypeDeserializerState {
            Init__,
            Font(Option<<super::ResFontsFontXElementType as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ResFontsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    font: Vec::new(),
                    state__: Box::new(ResFontsXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResFontsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResFontsXElementTypeDeserializerState as S;
                match state {
                    S::Font(Some(deserializer)) => self.store_font(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_font(&mut self, value: super::ResFontsFontXElementType) -> Result<(), Error> {
                self.font.push(value);
                Ok(())
            }
            fn handle_font<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::ResFontsFontXElementType>,
                fallback: &mut Option<ResFontsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResFontsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.font.len() < 1usize {
                        fallback.get_or_insert(S::Font(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Font(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_font(data)?;
                        *self.state__ = S::Font(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Font(Some(deserializer)));
                        *self.state__ = S::Font(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResFontsXElementType> for ResFontsXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResFontsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResFontsXElementType> {
                use ResFontsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Font(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_font(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Font(None);
                            event
                        }
                        (S::Font(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Font",
                                false,
                            )?;
                            match self.handle_font(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResFontsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResFontsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResFontsXElementType {
                    font: helper.finish_vec(1usize, None, self.font)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResMultiMediasXElementTypeDeserializer {
            multi_media: Vec<super::ResMultiMediasMultiMediaXElementType>,
            state__: Box<ResMultiMediasXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResMultiMediasXElementTypeDeserializerState {
            Init__,
            MultiMedia(
                Option<
                    <super::ResMultiMediasMultiMediaXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl ResMultiMediasXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    multi_media: Vec::new(),
                    state__: Box::new(ResMultiMediasXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResMultiMediasXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResMultiMediasXElementTypeDeserializerState as S;
                match state {
                    S::MultiMedia(Some(deserializer)) => {
                        self.store_multi_media(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_multi_media(
                &mut self,
                value: super::ResMultiMediasMultiMediaXElementType,
            ) -> Result<(), Error> {
                self.multi_media.push(value);
                Ok(())
            }
            fn handle_multi_media<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::ResMultiMediasMultiMediaXElementType>,
                fallback: &mut Option<ResMultiMediasXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResMultiMediasXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.multi_media.len() < 1usize {
                        fallback.get_or_insert(S::MultiMedia(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::MultiMedia(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_multi_media(data)?;
                        *self.state__ = S::MultiMedia(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::MultiMedia(Some(deserializer)));
                        *self.state__ = S::MultiMedia(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResMultiMediasXElementType>
            for ResMultiMediasXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResMultiMediasXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResMultiMediasXElementType> {
                use ResMultiMediasXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::MultiMedia(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_multi_media(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::MultiMedia(None);
                            event
                        }
                        (S::MultiMedia(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MultiMedia",
                                false,
                            )?;
                            match self.handle_multi_media(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResMultiMediasXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResMultiMediasXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResMultiMediasXElementType {
                    multi_media: helper.finish_vec(1usize, None, self.multi_media)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResCompositeGraphicUnitsXElementTypeDeserializer {
            composite_graphic_unit:
                Vec<super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>,
            state__: Box<ResCompositeGraphicUnitsXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResCompositeGraphicUnitsXElementTypeDeserializerState {
            Init__ , CompositeGraphicUnit (Option << super :: ResCompositeGraphicUnitsCompositeGraphicUnitXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl ResCompositeGraphicUnitsXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    composite_graphic_unit: Vec::new(),
                    state__: Box::new(
                        ResCompositeGraphicUnitsXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResCompositeGraphicUnitsXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResCompositeGraphicUnitsXElementTypeDeserializerState as S;
                match state {
                    S::CompositeGraphicUnit(Some(deserializer)) => {
                        self.store_composite_graphic_unit(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_composite_graphic_unit(
                &mut self,
                value: super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            ) -> Result<(), Error> {
                self.composite_graphic_unit.push(value);
                Ok(())
            }
            fn handle_composite_graphic_unit<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<
                    'de,
                    super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
                >,
                fallback: &mut Option<ResCompositeGraphicUnitsXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResCompositeGraphicUnitsXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.composite_graphic_unit.len() < 1usize {
                        fallback.get_or_insert(S::CompositeGraphicUnit(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::CompositeGraphicUnit(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_composite_graphic_unit(data)?;
                        *self.state__ = S::CompositeGraphicUnit(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CompositeGraphicUnit(Some(deserializer)));
                        *self.state__ = S::CompositeGraphicUnit(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResCompositeGraphicUnitsXElementType>
            for ResCompositeGraphicUnitsXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResCompositeGraphicUnitsXElementType> {
                use ResCompositeGraphicUnitsXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CompositeGraphicUnit(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_composite_graphic_unit(
                                helper,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CompositeGraphicUnit(None);
                            event
                        }
                        (
                            S::CompositeGraphicUnit(None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CompositeGraphicUnit",
                                false,
                            )?;
                            match self.handle_composite_graphic_unit(
                                helper,
                                output,
                                &mut fallback,
                            )? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResCompositeGraphicUnitsXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResCompositeGraphicUnitsXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResCompositeGraphicUnitsXElementType {
                    composite_graphic_unit: helper.finish_vec(
                        1usize,
                        None,
                        self.composite_graphic_unit,
                    )?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResColorSpacesColorSpaceXElementTypeDeserializer {
            type_: super::CtColorSpaceTypeXType,
            bits_per_component: i32,
            profile: Option<String>,
            id: u32,
            palette: Option<super::CtColorSpacePaletteXElementType>,
            state__: Box<ResColorSpacesColorSpaceXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResColorSpacesColorSpaceXElementTypeDeserializerState {
            Init__,
            Palette(
                Option<<super::CtColorSpacePaletteXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl ResColorSpacesColorSpaceXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtColorSpaceTypeXType> = None;
                let mut bits_per_component: Option<i32> = None;
                let mut profile: Option<String> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BitsPerComponent")
                    ) {
                        helper.read_attrib(
                            &mut bits_per_component,
                            b"BitsPerComponent",
                            &attrib.value,
                        )?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Profile")
                    ) {
                        helper.read_attrib(&mut profile, b"Profile", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    bits_per_component: bits_per_component.unwrap_or_else(
                        super::ResColorSpacesColorSpaceXElementType::default_bits_per_component,
                    ),
                    profile: profile,
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    palette: None,
                    state__: Box::new(
                        ResColorSpacesColorSpaceXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResColorSpacesColorSpaceXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResColorSpacesColorSpaceXElementTypeDeserializerState as S;
                match state {
                    S::Palette(Some(deserializer)) => {
                        self.store_palette(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_palette(
                &mut self,
                value: super::CtColorSpacePaletteXElementType,
            ) -> Result<(), Error> {
                if self.palette.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Palette",
                    )))?;
                }
                self.palette = Some(value);
                Ok(())
            }
            fn handle_palette<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::CtColorSpacePaletteXElementType>,
                fallback: &mut Option<ResColorSpacesColorSpaceXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResColorSpacesColorSpaceXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Palette(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_palette(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Palette(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResColorSpacesColorSpaceXElementType>
            for ResColorSpacesColorSpaceXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResColorSpacesColorSpaceXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResColorSpacesColorSpaceXElementType> {
                use ResColorSpacesColorSpaceXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Palette(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_palette(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Palette(None);
                            event
                        }
                        (S::Palette(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Palette",
                                false,
                            )?;
                            match self.handle_palette(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResColorSpacesColorSpaceXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResColorSpacesColorSpaceXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResColorSpacesColorSpaceXElementType {
                    type_: self.type_,
                    bits_per_component: self.bits_per_component,
                    profile: self.profile,
                    id: self.id,
                    palette: self.palette,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResDrawParamsDrawParamXElementTypeDeserializer {
            relative: Option<u32>,
            line_width: f64,
            join: String,
            cap: String,
            dash_offset: f64,
            dash_pattern: Option<String>,
            miter_limit: f64,
            id: u32,
            fill_color: Option<super::super::page::CtColorXType>,
            stroke_color: Option<super::super::page::CtColorXType>,
            state__: Box<ResDrawParamsDrawParamXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResDrawParamsDrawParamXElementTypeDeserializerState {
            Init__,
            FillColor(Option<<super::super::page::CtColorXType as WithDeserializer>::Deserializer>),
            StrokeColor(
                Option<<super::super::page::CtColorXType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl ResDrawParamsDrawParamXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut relative: Option<u32> = None;
                let mut line_width: Option<f64> = None;
                let mut join: Option<String> = None;
                let mut cap: Option<String> = None;
                let mut dash_offset: Option<f64> = None;
                let mut dash_pattern: Option<String> = None;
                let mut miter_limit: Option<f64> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Relative")
                    ) {
                        helper.read_attrib(&mut relative, b"Relative", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"LineWidth")
                    ) {
                        helper.read_attrib(&mut line_width, b"LineWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Join")
                    ) {
                        helper.read_attrib(&mut join, b"Join", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Cap")
                    ) {
                        helper.read_attrib(&mut cap, b"Cap", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashOffset")
                    ) {
                        helper.read_attrib(&mut dash_offset, b"DashOffset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"DashPattern")
                    ) {
                        helper.read_attrib(&mut dash_pattern, b"DashPattern", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"MiterLimit")
                    ) {
                        helper.read_attrib(&mut miter_limit, b"MiterLimit", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    relative: relative,
                    line_width: line_width.unwrap_or_else(
                        super::ResDrawParamsDrawParamXElementType::default_line_width,
                    ),
                    join: join
                        .unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_join),
                    cap: cap.unwrap_or_else(super::ResDrawParamsDrawParamXElementType::default_cap),
                    dash_offset: dash_offset.unwrap_or_else(
                        super::ResDrawParamsDrawParamXElementType::default_dash_offset,
                    ),
                    dash_pattern: dash_pattern,
                    miter_limit: miter_limit.unwrap_or_else(
                        super::ResDrawParamsDrawParamXElementType::default_miter_limit,
                    ),
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    fill_color: None,
                    stroke_color: None,
                    state__: Box::new(ResDrawParamsDrawParamXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResDrawParamsDrawParamXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
                match state {
                    S::FillColor(Some(deserializer)) => {
                        self.store_fill_color(deserializer.finish(helper)?)?
                    }
                    S::StrokeColor(Some(deserializer)) => {
                        self.store_stroke_color(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_fill_color(
                &mut self,
                value: super::super::page::CtColorXType,
            ) -> Result<(), Error> {
                if self.fill_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FillColor",
                    )))?;
                }
                self.fill_color = Some(value);
                Ok(())
            }
            fn store_stroke_color(
                &mut self,
                value: super::super::page::CtColorXType,
            ) -> Result<(), Error> {
                if self.stroke_color.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"StrokeColor",
                    )))?;
                }
                self.stroke_color = Some(value);
                Ok(())
            }
            fn handle_fill_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtColorXType>,
                fallback: &mut Option<ResDrawParamsDrawParamXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FillColor(None));
                    *self.state__ = S::StrokeColor(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_fill_color(data)?;
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FillColor(Some(deserializer)));
                        *self.state__ = S::StrokeColor(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_stroke_color<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtColorXType>,
                fallback: &mut Option<ResDrawParamsDrawParamXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::StrokeColor(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_stroke_color(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::StrokeColor(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResDrawParamsDrawParamXElementType>
            for ResDrawParamsDrawParamXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResDrawParamsDrawParamXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResDrawParamsDrawParamXElementType> {
                use ResDrawParamsDrawParamXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FillColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FillColor(None);
                            event
                        }
                        (S::FillColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FillColor",
                                true,
                            )?;
                            match self.handle_fill_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StrokeColor(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StrokeColor",
                                true,
                            )?;
                            match self.handle_stroke_color(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResDrawParamsDrawParamXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResDrawParamsDrawParamXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResDrawParamsDrawParamXElementType {
                    relative: self.relative,
                    line_width: self.line_width,
                    join: self.join,
                    cap: self.cap,
                    dash_offset: self.dash_offset,
                    dash_pattern: self.dash_pattern,
                    miter_limit: self.miter_limit,
                    id: self.id,
                    fill_color: self.fill_color,
                    stroke_color: self.stroke_color,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResFontsFontXElementTypeDeserializer {
            font_name: String,
            family_name: Option<String>,
            charset: super::CtFontCharsetXType,
            italic: bool,
            bold: bool,
            serif: bool,
            fixed_width: bool,
            id: u32,
            font_file: Option<String>,
            state__: Box<ResFontsFontXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResFontsFontXElementTypeDeserializerState {
            Init__,
            FontFile(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ResFontsFontXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut font_name: Option<String> = None;
                let mut family_name: Option<String> = None;
                let mut charset: Option<super::CtFontCharsetXType> = None;
                let mut italic: Option<bool> = None;
                let mut bold: Option<bool> = None;
                let mut serif: Option<bool> = None;
                let mut fixed_width: Option<bool> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FontName")
                    ) {
                        helper.read_attrib(&mut font_name, b"FontName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FamilyName")
                    ) {
                        helper.read_attrib(&mut family_name, b"FamilyName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Charset")
                    ) {
                        helper.read_attrib(&mut charset, b"Charset", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Italic")
                    ) {
                        helper.read_attrib(&mut italic, b"Italic", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Bold")
                    ) {
                        helper.read_attrib(&mut bold, b"Bold", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Serif")
                    ) {
                        helper.read_attrib(&mut serif, b"Serif", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FixedWidth")
                    ) {
                        helper.read_attrib(&mut fixed_width, b"FixedWidth", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    font_name: font_name
                        .ok_or_else(|| ErrorKind::MissingAttribute("FontName".into()))?,
                    family_name: family_name,
                    charset: charset
                        .unwrap_or_else(super::ResFontsFontXElementType::default_charset),
                    italic: italic.unwrap_or_else(super::ResFontsFontXElementType::default_italic),
                    bold: bold.unwrap_or_else(super::ResFontsFontXElementType::default_bold),
                    serif: serif.unwrap_or_else(super::ResFontsFontXElementType::default_serif),
                    fixed_width: fixed_width
                        .unwrap_or_else(super::ResFontsFontXElementType::default_fixed_width),
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    font_file: None,
                    state__: Box::new(ResFontsFontXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResFontsFontXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResFontsFontXElementTypeDeserializerState as S;
                match state {
                    S::FontFile(Some(deserializer)) => {
                        self.store_font_file(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_font_file(&mut self, value: String) -> Result<(), Error> {
                if self.font_file.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FontFile",
                    )))?;
                }
                self.font_file = Some(value);
                Ok(())
            }
            fn handle_font_file<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<ResFontsFontXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResFontsFontXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FontFile(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_font_file(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FontFile(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResFontsFontXElementType>
            for ResFontsFontXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResFontsFontXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResFontsFontXElementType> {
                use ResFontsFontXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FontFile(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_font_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FontFile(None);
                            event
                        }
                        (S::FontFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FontFile",
                                false,
                            )?;
                            match self.handle_font_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResFontsFontXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResFontsFontXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResFontsFontXElementType {
                    font_name: self.font_name,
                    family_name: self.family_name,
                    charset: self.charset,
                    italic: self.italic,
                    bold: self.bold,
                    serif: self.serif,
                    fixed_width: self.fixed_width,
                    id: self.id,
                    font_file: self.font_file,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResMultiMediasMultiMediaXElementTypeDeserializer {
            type_: super::CtMultiMediaTypeXType,
            format: Option<String>,
            id: u32,
            media_file: Option<String>,
            state__: Box<ResMultiMediasMultiMediaXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResMultiMediasMultiMediaXElementTypeDeserializerState {
            Init__,
            MediaFile(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl ResMultiMediasMultiMediaXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut type_: Option<super::CtMultiMediaTypeXType> = None;
                let mut format: Option<String> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Format")
                    ) {
                        helper.read_attrib(&mut format, b"Format", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    type_: type_.ok_or_else(|| ErrorKind::MissingAttribute("Type".into()))?,
                    format: format,
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    media_file: None,
                    state__: Box::new(
                        ResMultiMediasMultiMediaXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResMultiMediasMultiMediaXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResMultiMediasMultiMediaXElementTypeDeserializerState as S;
                match state {
                    S::MediaFile(Some(deserializer)) => {
                        self.store_media_file(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_media_file(&mut self, value: String) -> Result<(), Error> {
                if self.media_file.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"MediaFile",
                    )))?;
                }
                self.media_file = Some(value);
                Ok(())
            }
            fn handle_media_file<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<ResMultiMediasMultiMediaXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResMultiMediasMultiMediaXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::MediaFile(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_media_file(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::MediaFile(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResMultiMediasMultiMediaXElementType>
            for ResMultiMediasMultiMediaXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResMultiMediasMultiMediaXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::ResMultiMediasMultiMediaXElementType> {
                use ResMultiMediasMultiMediaXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::MediaFile(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_media_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::MediaFile(None);
                            event
                        }
                        (S::MediaFile(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MediaFile",
                                false,
                            )?;
                            match self.handle_media_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResMultiMediasMultiMediaXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    ResMultiMediasMultiMediaXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::ResMultiMediasMultiMediaXElementType {
                    type_: self.type_,
                    format: self.format,
                    id: self.id,
                    media_file: helper.finish_element("MediaFile", self.media_file)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer {
            width: f64,
            height: f64,
            id: u32,
            thumbnail: Option<u32>,
            substitution: Option<u32>,
            content: Option<super::super::page::CtPageBlockXType>,
            state__: Box<ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState {
            Init__,
            Thumbnail(Option<<u32 as WithDeserializer>::Deserializer>),
            Substitution(Option<<u32 as WithDeserializer>::Deserializer>),
            Content(
                Option<<super::super::page::CtPageBlockXType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut width: Option<f64> = None;
                let mut height: Option<f64> = None;
                let mut id: Option<u32> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Width")
                    ) {
                        helper.read_attrib(&mut width, b"Width", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Height")
                    ) {
                        helper.read_attrib(&mut height, b"Height", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok (Self { width : width . ok_or_else (|| ErrorKind :: MissingAttribute ("Width" . into ())) ? , height : height . ok_or_else (|| ErrorKind :: MissingAttribute ("Height" . into ())) ? , id : id . ok_or_else (|| ErrorKind :: MissingAttribute ("ID" . into ())) ? , thumbnail : None , substitution : None , content : None , state__ : Box :: new (ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Init__) , })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
                match state {
                    S::Thumbnail(Some(deserializer)) => {
                        self.store_thumbnail(deserializer.finish(helper)?)?
                    }
                    S::Substitution(Some(deserializer)) => {
                        self.store_substitution(deserializer.finish(helper)?)?
                    }
                    S::Content(Some(deserializer)) => {
                        self.store_content(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_thumbnail(&mut self, value: u32) -> Result<(), Error> {
                if self.thumbnail.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Thumbnail",
                    )))?;
                }
                self.thumbnail = Some(value);
                Ok(())
            }
            fn store_substitution(&mut self, value: u32) -> Result<(), Error> {
                if self.substitution.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Substitution",
                    )))?;
                }
                self.substitution = Some(value);
                Ok(())
            }
            fn store_content(
                &mut self,
                value: super::super::page::CtPageBlockXType,
            ) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Content",
                    )))?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_thumbnail<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<
                    ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Thumbnail(None));
                    *self.state__ = S::Substitution(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_thumbnail(data)?;
                        *self.state__ = S::Substitution(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Thumbnail(Some(deserializer)));
                        *self.state__ = S::Substitution(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_substitution<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, u32>,
                fallback: &mut Option<
                    ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Substitution(None));
                    *self.state__ = S::Content(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_substitution(data)?;
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Substitution(Some(deserializer)));
                        *self.state__ = S::Content(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_content<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::super::page::CtPageBlockXType>,
                fallback: &mut Option<
                    ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Content(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Content(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType>
            for ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<
                'de,
                super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            > {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<
                'de,
                super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            > {
                use ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Thumbnail(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_thumbnail(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Substitution(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_substitution(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Thumbnail(None);
                            event
                        }
                        (S::Thumbnail(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Thumbnail",
                                false,
                            )?;
                            match self.handle_thumbnail(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Substitution(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Substitution",
                                false,
                            )?;
                            match self.handle_substitution(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Content(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Content",
                                true,
                            )?;
                            match self.handle_content(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType, Error>
            {
                let state = replace (& mut * self . state__ , ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeDeserializerState :: Unknown__) ;
                self.finish_state(helper, state)?;
                Ok(
                    super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType {
                        width: self.width,
                        height: self.height,
                        id: self.id,
                        thumbnail: self.thumbnail,
                        substitution: self.substitution,
                        content: helper.finish_element("Content", self.content)?,
                    },
                )
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct CtColorSpaceXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtColorSpaceXType,
            pub(super) state: Box<CtColorSpaceXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtColorSpaceXTypeSerializerState<'ser> {
            Init__,
            Palette(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtColorSpacePaletteXElementType>,
                    super::CtColorSpacePaletteXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtColorSpaceXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtColorSpaceXTypeSerializerState::Init__ => {
                            *self.state =
                                CtColorSpaceXTypeSerializerState::Palette(IterSerializer::new(
                                    self.value.palette.as_ref(),
                                    Some("Palette"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib(
                                &mut bytes,
                                "BitsPerComponent",
                                &self.value.bits_per_component,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Profile", &self.value.profile)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtColorSpaceXTypeSerializerState::Palette(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtColorSpaceXTypeSerializerState::End__,
                            }
                        }
                        CtColorSpaceXTypeSerializerState::End__ => {
                            *self.state = CtColorSpaceXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtColorSpaceXTypeSerializerState::Done__ => return Ok(None),
                        CtColorSpaceXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtColorSpaceXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtColorSpaceXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtDrawParamXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtDrawParamXType,
            pub(super) state: Box<CtDrawParamXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtDrawParamXTypeSerializerState<'ser> {
            Init__,
            FillColor(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtColorXType>,
                    super::super::page::CtColorXType,
                >,
            ),
            StrokeColor(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtColorXType>,
                    super::super::page::CtColorXType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtDrawParamXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtDrawParamXTypeSerializerState::Init__ => {
                            *self.state =
                                CtDrawParamXTypeSerializerState::FillColor(IterSerializer::new(
                                    self.value.fill_color.as_ref(),
                                    Some("FillColor"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Relative",
                                &self.value.relative,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtDrawParamXTypeSerializerState::FillColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtDrawParamXTypeSerializerState::StrokeColor(
                                        IterSerializer::new(
                                            self.value.stroke_color.as_ref(),
                                            Some("StrokeColor"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtDrawParamXTypeSerializerState::StrokeColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtDrawParamXTypeSerializerState::End__,
                            }
                        }
                        CtDrawParamXTypeSerializerState::End__ => {
                            *self.state = CtDrawParamXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtDrawParamXTypeSerializerState::Done__ => return Ok(None),
                        CtDrawParamXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtDrawParamXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtDrawParamXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtFontXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtFontXType,
            pub(super) state: Box<CtFontXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtFontXTypeSerializerState<'ser> {
            Init__,
            FontFile(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtFontXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtFontXTypeSerializerState::Init__ => {
                            *self.state =
                                CtFontXTypeSerializerState::FontFile(IterSerializer::new(
                                    self.value.font_file.as_ref(),
                                    Some("FontFile"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "FontName", &self.value.font_name)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "FamilyName",
                                &self.value.family_name,
                            )?;
                            helper.write_attrib(&mut bytes, "Charset", &self.value.charset)?;
                            helper.write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                            helper.write_attrib(&mut bytes, "Bold", &self.value.bold)?;
                            helper.write_attrib(&mut bytes, "Serif", &self.value.serif)?;
                            helper.write_attrib(
                                &mut bytes,
                                "FixedWidth",
                                &self.value.fixed_width,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtFontXTypeSerializerState::FontFile(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtFontXTypeSerializerState::End__,
                            }
                        }
                        CtFontXTypeSerializerState::End__ => {
                            *self.state = CtFontXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtFontXTypeSerializerState::Done__ => return Ok(None),
                        CtFontXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtFontXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtFontXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtMultiMediaXTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtMultiMediaXType,
            pub(super) state: Box<CtMultiMediaXTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtMultiMediaXTypeSerializerState<'ser> {
            Init__,
            MediaFile(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtMultiMediaXTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtMultiMediaXTypeSerializerState::Init__ => {
                            *self.state = CtMultiMediaXTypeSerializerState::MediaFile(
                                WithSerializer::serializer(
                                    &self.value.media_file,
                                    Some("MediaFile"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtMultiMediaXTypeSerializerState::MediaFile(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtMultiMediaXTypeSerializerState::End__,
                            }
                        }
                        CtMultiMediaXTypeSerializerState::End__ => {
                            *self.state = CtMultiMediaXTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtMultiMediaXTypeSerializerState::Done__ => return Ok(None),
                        CtMultiMediaXTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtMultiMediaXTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtMultiMediaXTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtVectorGxTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtVectorGxType,
            pub(super) state: Box<CtVectorGxTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtVectorGxTypeSerializerState<'ser> {
            Init__,
            Thumbnail(IterSerializer<'ser, Option<&'ser u32>, u32>),
            Substitution(IterSerializer<'ser, Option<&'ser u32>, u32>),
            Content(<super::super::page::CtPageBlockXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtVectorGxTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtVectorGxTypeSerializerState::Init__ => {
                            *self.state =
                                CtVectorGxTypeSerializerState::Thumbnail(IterSerializer::new(
                                    self.value.thumbnail.as_ref(),
                                    Some("Thumbnail"),
                                    false,
                                ));
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Width", &self.value.width)?;
                            helper.write_attrib(&mut bytes, "Height", &self.value.height)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtVectorGxTypeSerializerState::Thumbnail(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVectorGxTypeSerializerState::Substitution(
                                        IterSerializer::new(
                                            self.value.substitution.as_ref(),
                                            Some("Substitution"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        CtVectorGxTypeSerializerState::Substitution(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = CtVectorGxTypeSerializerState::Content(
                                        WithSerializer::serializer(
                                            &self.value.content,
                                            Some("Content"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        CtVectorGxTypeSerializerState::Content(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = CtVectorGxTypeSerializerState::End__,
                            }
                        }
                        CtVectorGxTypeSerializerState::End__ => {
                            *self.state = CtVectorGxTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtVectorGxTypeSerializerState::Done__ => return Ok(None),
                        CtVectorGxTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtVectorGxTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtVectorGxTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResXElementType,
            pub(super) state: Box<ResXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResXElementTypeSerializerState<'ser> {
            Init__,
            Content__(
                IterSerializer<
                    'ser,
                    &'ser [super::ResXElementTypeContent],
                    super::ResXElementTypeContent,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResXElementTypeSerializerState::Init__ => {
                            *self.state = ResXElementTypeSerializerState::Content__(
                                IterSerializer::new(&self.value.content[..], None, false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeSerializerState::End__,
                            }
                        }
                        ResXElementTypeSerializerState::End__ => {
                            *self.state = ResXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResXElementTypeSerializerState::Done__ => return Ok(None),
                        ResXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResXElementTypeContentSerializer<'ser> {
            pub(super) value: &'ser super::ResXElementTypeContent,
            pub(super) state: Box<ResXElementTypeContentSerializerState<'ser>>,
        }
        #[derive(Debug)]
        pub(super) enum ResXElementTypeContentSerializerState<'ser> {
            Init__,
            ColorSpaces(<super::ResColorSpacesXElementType as WithSerializer>::Serializer<'ser>),
            DrawParams(<super::ResDrawParamsXElementType as WithSerializer>::Serializer<'ser>),
            Fonts(<super::ResFontsXElementType as WithSerializer>::Serializer<'ser>),
            MultiMedias(<super::ResMultiMediasXElementType as WithSerializer>::Serializer<'ser>),
            CompositeGraphicUnits(
                <super::ResCompositeGraphicUnitsXElementType as WithSerializer>::Serializer<'ser>,
            ),
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResXElementTypeContentSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResXElementTypeContentSerializerState::Init__ => match self.value {
                            super::ResXElementTypeContent::ColorSpaces(x) => {
                                *self.state = ResXElementTypeContentSerializerState::ColorSpaces(
                                    WithSerializer::serializer(x, Some("ColorSpaces"), false)?,
                                )
                            }
                            super::ResXElementTypeContent::DrawParams(x) => {
                                *self.state = ResXElementTypeContentSerializerState::DrawParams(
                                    WithSerializer::serializer(x, Some("DrawParams"), false)?,
                                )
                            }
                            super::ResXElementTypeContent::Fonts(x) => {
                                *self.state = ResXElementTypeContentSerializerState::Fonts(
                                    WithSerializer::serializer(x, Some("Fonts"), false)?,
                                )
                            }
                            super::ResXElementTypeContent::MultiMedias(x) => {
                                *self.state = ResXElementTypeContentSerializerState::MultiMedias(
                                    WithSerializer::serializer(x, Some("MultiMedias"), false)?,
                                )
                            }
                            super::ResXElementTypeContent::CompositeGraphicUnits(x) => {
                                *self.state =
                                    ResXElementTypeContentSerializerState::CompositeGraphicUnits(
                                        WithSerializer::serializer(
                                            x,
                                            Some("CompositeGraphicUnits"),
                                            false,
                                        )?,
                                    )
                            }
                        },
                        ResXElementTypeContentSerializerState::ColorSpaces(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeContentSerializerState::Done__,
                            }
                        }
                        ResXElementTypeContentSerializerState::DrawParams(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeContentSerializerState::Done__,
                            }
                        }
                        ResXElementTypeContentSerializerState::Fonts(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeContentSerializerState::Done__,
                            }
                        }
                        ResXElementTypeContentSerializerState::MultiMedias(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeContentSerializerState::Done__,
                            }
                        }
                        ResXElementTypeContentSerializerState::CompositeGraphicUnits(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResXElementTypeContentSerializerState::Done__,
                            }
                        }
                        ResXElementTypeContentSerializerState::Done__ => return Ok(None),
                        ResXElementTypeContentSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResXElementTypeContentSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResXElementTypeContentSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct CtColorSpacePaletteXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::CtColorSpacePaletteXElementType,
            pub(super) state: Box<CtColorSpacePaletteXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum CtColorSpacePaletteXElementTypeSerializerState<'ser> {
            Init__,
            Cv(IterSerializer<'ser, &'ser [String], String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> CtColorSpacePaletteXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        CtColorSpacePaletteXElementTypeSerializerState::Init__ => {
                            *self.state = CtColorSpacePaletteXElementTypeSerializerState::Cv(
                                IterSerializer::new(&self.value.cv[..], Some("CV"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        CtColorSpacePaletteXElementTypeSerializerState::Cv(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        CtColorSpacePaletteXElementTypeSerializerState::End__
                                }
                            }
                        }
                        CtColorSpacePaletteXElementTypeSerializerState::End__ => {
                            *self.state = CtColorSpacePaletteXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        CtColorSpacePaletteXElementTypeSerializerState::Done__ => return Ok(None),
                        CtColorSpacePaletteXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for CtColorSpacePaletteXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = CtColorSpacePaletteXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResColorSpacesXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResColorSpacesXElementType,
            pub(super) state: Box<ResColorSpacesXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResColorSpacesXElementTypeSerializerState<'ser> {
            Init__,
            ColorSpace(
                IterSerializer<
                    'ser,
                    &'ser [super::ResColorSpacesColorSpaceXElementType],
                    super::ResColorSpacesColorSpaceXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResColorSpacesXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResColorSpacesXElementTypeSerializerState::Init__ => {
                            *self.state = ResColorSpacesXElementTypeSerializerState::ColorSpace(
                                IterSerializer::new(
                                    &self.value.color_space[..],
                                    Some("ColorSpace"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResColorSpacesXElementTypeSerializerState::ColorSpace(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResColorSpacesXElementTypeSerializerState::End__,
                        },
                        ResColorSpacesXElementTypeSerializerState::End__ => {
                            *self.state = ResColorSpacesXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResColorSpacesXElementTypeSerializerState::Done__ => return Ok(None),
                        ResColorSpacesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResColorSpacesXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResColorSpacesXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResDrawParamsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResDrawParamsXElementType,
            pub(super) state: Box<ResDrawParamsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResDrawParamsXElementTypeSerializerState<'ser> {
            Init__,
            DrawParam(
                IterSerializer<
                    'ser,
                    &'ser [super::ResDrawParamsDrawParamXElementType],
                    super::ResDrawParamsDrawParamXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResDrawParamsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResDrawParamsXElementTypeSerializerState::Init__ => {
                            *self.state = ResDrawParamsXElementTypeSerializerState::DrawParam(
                                IterSerializer::new(
                                    &self.value.draw_param[..],
                                    Some("DrawParam"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResDrawParamsXElementTypeSerializerState::DrawParam(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResDrawParamsXElementTypeSerializerState::End__,
                        },
                        ResDrawParamsXElementTypeSerializerState::End__ => {
                            *self.state = ResDrawParamsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResDrawParamsXElementTypeSerializerState::Done__ => return Ok(None),
                        ResDrawParamsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResDrawParamsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResDrawParamsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResFontsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResFontsXElementType,
            pub(super) state: Box<ResFontsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResFontsXElementTypeSerializerState<'ser> {
            Init__,
            Font(
                IterSerializer<
                    'ser,
                    &'ser [super::ResFontsFontXElementType],
                    super::ResFontsFontXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResFontsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResFontsXElementTypeSerializerState::Init__ => {
                            *self.state = ResFontsXElementTypeSerializerState::Font(
                                IterSerializer::new(&self.value.font[..], Some("Font"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResFontsXElementTypeSerializerState::Font(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = ResFontsXElementTypeSerializerState::End__,
                            }
                        }
                        ResFontsXElementTypeSerializerState::End__ => {
                            *self.state = ResFontsXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResFontsXElementTypeSerializerState::Done__ => return Ok(None),
                        ResFontsXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResFontsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResFontsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResMultiMediasXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResMultiMediasXElementType,
            pub(super) state: Box<ResMultiMediasXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResMultiMediasXElementTypeSerializerState<'ser> {
            Init__,
            MultiMedia(
                IterSerializer<
                    'ser,
                    &'ser [super::ResMultiMediasMultiMediaXElementType],
                    super::ResMultiMediasMultiMediaXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResMultiMediasXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResMultiMediasXElementTypeSerializerState::Init__ => {
                            *self.state = ResMultiMediasXElementTypeSerializerState::MultiMedia(
                                IterSerializer::new(
                                    &self.value.multi_media[..],
                                    Some("MultiMedia"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResMultiMediasXElementTypeSerializerState::MultiMedia(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResMultiMediasXElementTypeSerializerState::End__,
                        },
                        ResMultiMediasXElementTypeSerializerState::End__ => {
                            *self.state = ResMultiMediasXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResMultiMediasXElementTypeSerializerState::Done__ => return Ok(None),
                        ResMultiMediasXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResMultiMediasXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResMultiMediasXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResCompositeGraphicUnitsXElementType,
            pub(super) state: Box<ResCompositeGraphicUnitsXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResCompositeGraphicUnitsXElementTypeSerializerState<'ser> {
            Init__,
            CompositeGraphicUnit(
                IterSerializer<
                    'ser,
                    &'ser [super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType],
                    super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { ResCompositeGraphicUnitsXElementTypeSerializerState :: Init__ => { * self . state = ResCompositeGraphicUnitsXElementTypeSerializerState :: CompositeGraphicUnit (IterSerializer :: new (& self . value . composite_graphic_unit [..] , Some ("CompositeGraphicUnit") , false)) ; let mut bytes = BytesStart :: new (self . name) ; helper . begin_ns_scope () ; helper . write_xmlns (& mut bytes , None , & super :: super :: NS_UNNAMED_2) ; return Ok (Some (Event :: Start (bytes))) } ResCompositeGraphicUnitsXElementTypeSerializerState :: CompositeGraphicUnit (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsXElementTypeSerializerState :: End__ , } ResCompositeGraphicUnitsXElementTypeSerializerState :: End__ => { * self . state = ResCompositeGraphicUnitsXElementTypeSerializerState :: Done__ ; helper . end_ns_scope () ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } ResCompositeGraphicUnitsXElementTypeSerializerState :: Done__ => return Ok (None) , ResCompositeGraphicUnitsXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResCompositeGraphicUnitsXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResCompositeGraphicUnitsXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResColorSpacesColorSpaceXElementType,
            pub(super) state: Box<ResColorSpacesColorSpaceXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResColorSpacesColorSpaceXElementTypeSerializerState<'ser> {
            Init__,
            Palette(
                IterSerializer<
                    'ser,
                    Option<&'ser super::CtColorSpacePaletteXElementType>,
                    super::CtColorSpacePaletteXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResColorSpacesColorSpaceXElementTypeSerializerState::Init__ => {
                            *self.state =
                                ResColorSpacesColorSpaceXElementTypeSerializerState::Palette(
                                    IterSerializer::new(
                                        self.value.palette.as_ref(),
                                        Some("Palette"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib(
                                &mut bytes,
                                "BitsPerComponent",
                                &self.value.bits_per_component,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Profile", &self.value.profile)?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResColorSpacesColorSpaceXElementTypeSerializerState::Palette(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        ResColorSpacesColorSpaceXElementTypeSerializerState::End__
                                }
                            }
                        }
                        ResColorSpacesColorSpaceXElementTypeSerializerState::End__ => {
                            *self.state =
                                ResColorSpacesColorSpaceXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResColorSpacesColorSpaceXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        ResColorSpacesColorSpaceXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResColorSpacesColorSpaceXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResColorSpacesColorSpaceXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResDrawParamsDrawParamXElementType,
            pub(super) state: Box<ResDrawParamsDrawParamXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResDrawParamsDrawParamXElementTypeSerializerState<'ser> {
            Init__,
            FillColor(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtColorXType>,
                    super::super::page::CtColorXType,
                >,
            ),
            StrokeColor(
                IterSerializer<
                    'ser,
                    Option<&'ser super::super::page::CtColorXType>,
                    super::super::page::CtColorXType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResDrawParamsDrawParamXElementTypeSerializerState::Init__ => {
                            *self.state =
                                ResDrawParamsDrawParamXElementTypeSerializerState::FillColor(
                                    IterSerializer::new(
                                        self.value.fill_color.as_ref(),
                                        Some("FillColor"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib_opt(
                                &mut bytes,
                                "Relative",
                                &self.value.relative,
                            )?;
                            helper.write_attrib(&mut bytes, "LineWidth", &self.value.line_width)?;
                            helper.write_attrib(&mut bytes, "Join", &self.value.join)?;
                            helper.write_attrib(&mut bytes, "Cap", &self.value.cap)?;
                            helper.write_attrib(
                                &mut bytes,
                                "DashOffset",
                                &self.value.dash_offset,
                            )?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "DashPattern",
                                &self.value.dash_pattern,
                            )?;
                            helper.write_attrib(
                                &mut bytes,
                                "MiterLimit",
                                &self.value.miter_limit,
                            )?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResDrawParamsDrawParamXElementTypeSerializerState::FillColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state =
                                    ResDrawParamsDrawParamXElementTypeSerializerState::StrokeColor(
                                        IterSerializer::new(
                                            self.value.stroke_color.as_ref(),
                                            Some("StrokeColor"),
                                            false,
                                        ),
                                    ),
                            }
                        }
                        ResDrawParamsDrawParamXElementTypeSerializerState::StrokeColor(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        ResDrawParamsDrawParamXElementTypeSerializerState::End__
                                }
                            }
                        }
                        ResDrawParamsDrawParamXElementTypeSerializerState::End__ => {
                            *self.state = ResDrawParamsDrawParamXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResDrawParamsDrawParamXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        ResDrawParamsDrawParamXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResDrawParamsDrawParamXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResDrawParamsDrawParamXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResFontsFontXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResFontsFontXElementType,
            pub(super) state: Box<ResFontsFontXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResFontsFontXElementTypeSerializerState<'ser> {
            Init__,
            FontFile(IterSerializer<'ser, Option<&'ser String>, String>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResFontsFontXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResFontsFontXElementTypeSerializerState::Init__ => {
                            *self.state = ResFontsFontXElementTypeSerializerState::FontFile(
                                IterSerializer::new(
                                    self.value.font_file.as_ref(),
                                    Some("FontFile"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "FontName", &self.value.font_name)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "FamilyName",
                                &self.value.family_name,
                            )?;
                            helper.write_attrib(&mut bytes, "Charset", &self.value.charset)?;
                            helper.write_attrib(&mut bytes, "Italic", &self.value.italic)?;
                            helper.write_attrib(&mut bytes, "Bold", &self.value.bold)?;
                            helper.write_attrib(&mut bytes, "Serif", &self.value.serif)?;
                            helper.write_attrib(
                                &mut bytes,
                                "FixedWidth",
                                &self.value.fixed_width,
                            )?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResFontsFontXElementTypeSerializerState::FontFile(x) => match x
                            .next(helper)
                            .transpose()?
                        {
                            Some(event) => return Ok(Some(event)),
                            None => *self.state = ResFontsFontXElementTypeSerializerState::End__,
                        },
                        ResFontsFontXElementTypeSerializerState::End__ => {
                            *self.state = ResFontsFontXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResFontsFontXElementTypeSerializerState::Done__ => return Ok(None),
                        ResFontsFontXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResFontsFontXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResFontsFontXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResMultiMediasMultiMediaXElementType,
            pub(super) state: Box<ResMultiMediasMultiMediaXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResMultiMediasMultiMediaXElementTypeSerializerState<'ser> {
            Init__,
            MediaFile(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        ResMultiMediasMultiMediaXElementTypeSerializerState::Init__ => {
                            *self.state =
                                ResMultiMediasMultiMediaXElementTypeSerializerState::MediaFile(
                                    WithSerializer::serializer(
                                        &self.value.media_file,
                                        Some("MediaFile"),
                                        false,
                                    )?,
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib_opt(&mut bytes, "Format", &self.value.format)?;
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        ResMultiMediasMultiMediaXElementTypeSerializerState::MediaFile(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        ResMultiMediasMultiMediaXElementTypeSerializerState::End__
                                }
                            }
                        }
                        ResMultiMediasMultiMediaXElementTypeSerializerState::End__ => {
                            *self.state =
                                ResMultiMediasMultiMediaXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        ResMultiMediasMultiMediaXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        ResMultiMediasMultiMediaXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for ResMultiMediasMultiMediaXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = ResMultiMediasMultiMediaXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::ResCompositeGraphicUnitsCompositeGraphicUnitXElementType,
            pub(super) state:
                Box<ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState<
            'ser,
        > {
            Init__,
            Thumbnail(IterSerializer<'ser, Option<&'ser u32>, u32>),
            Substitution(IterSerializer<'ser, Option<&'ser u32>, u32>),
            Content(<super::super::page::CtPageBlockXType as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Init__ => { * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Thumbnail (IterSerializer :: new (self . value . thumbnail . as_ref () , Some ("Thumbnail") , false)) ; let mut bytes = BytesStart :: new (self . name) ; helper . begin_ns_scope () ; helper . write_xmlns (& mut bytes , None , & super :: super :: NS_UNNAMED_2) ; helper . write_attrib (& mut bytes , "Width" , & self . value . width) ? ; helper . write_attrib (& mut bytes , "Height" , & self . value . height) ? ; helper . write_attrib (& mut bytes , "ID" , & self . value . id) ? ; return Ok (Some (Event :: Start (bytes))) } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Thumbnail (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Substitution (IterSerializer :: new (self . value . substitution . as_ref () , Some ("Substitution") , false)) , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Substitution (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Content (WithSerializer :: serializer (& self . value . content , Some ("Content") , false) ?) , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Content (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: End__ , } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: End__ => { * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ ; helper . end_ns_scope () ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ => return Ok (None) , ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser>
            for ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializer<'ser>
        {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        * self . state = ResCompositeGraphicUnitsCompositeGraphicUnitXElementTypeSerializerState :: Done__ ;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod signature {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    pub type Sianature = SianatureXElementType;
    #[derive(Debug)]
    pub struct SianatureXElementType {
        pub siqned_info: SianatureSiqnedInfoXElementType,
        pub signed_value: String,
    }
    impl WithSerializer for SianatureXElementType {
        type Serializer<'x> = quick_xml_serialize::SianatureXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SianatureXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SianatureXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Sianature"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SianatureXElementType {
        type Deserializer = quick_xml_deserialize::SianatureXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoXElementType {
        pub provider: SianatureSiqnedInfoProviderXElementType,
        pub signature_method: Option<String>,
        pub sianature_date_time: Option<String>,
        pub references: SianatureSiqnedInfoReferencesXElementType,
        pub stamp_annot: Vec<SianatureSiqnedInfoStampAnnotXElementType>,
        pub seal: Option<SianatureSiqnedInfoSealXElementType>,
    }
    impl WithSerializer for SianatureSiqnedInfoXElementType {
        type Serializer<'x> = quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::SianatureSiqnedInfoXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("SianatureSiqnedInfo"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoXElementType {
        type Deserializer = quick_xml_deserialize::SianatureSiqnedInfoXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoProviderXElementType {
        pub provider_name: String,
        pub version: Option<String>,
        pub company: Option<String>,
    }
    impl WithSerializer for SianatureSiqnedInfoProviderXElementType {
        type Serializer<'x> =
            quick_xml_serialize::SianatureSiqnedInfoProviderXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: SianatureSiqnedInfoProviderXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoProviderXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoProvider") , is_root , })
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoProviderXElementType {
        type Deserializer =
            quick_xml_deserialize::SianatureSiqnedInfoProviderXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesXElementType {
        pub check_method: SianatureSiqnedInfoReferencesCheckMethodXType,
        pub reference: Vec<SianatureSiqnedInfoReferencesReferenceXElementType>,
    }
    impl SianatureSiqnedInfoReferencesXElementType {
        #[must_use]
        pub fn default_check_method() -> SianatureSiqnedInfoReferencesCheckMethodXType {
            SianatureSiqnedInfoReferencesCheckMethodXType::Md5
        }
    }
    impl WithSerializer for SianatureSiqnedInfoReferencesXElementType {
        type Serializer<'x> =
            quick_xml_serialize::SianatureSiqnedInfoReferencesXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: SianatureSiqnedInfoReferencesXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoReferencesXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoReferences") , is_root , })
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoReferencesXElementType {
        type Deserializer =
            quick_xml_deserialize::SianatureSiqnedInfoReferencesXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoStampAnnotXElementType {
        pub id: String,
        pub page_ref: u32,
        pub boundary: String,
        pub clip: Option<String>,
    }
    impl WithSerializer for SianatureSiqnedInfoStampAnnotXElementType {
        type Serializer<'x> =
            quick_xml_serialize::SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: SianatureSiqnedInfoStampAnnotXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoStampAnnotXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoStampAnnot") , is_root , })
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoStampAnnotXElementType {
        type Deserializer =
            quick_xml_deserialize::SianatureSiqnedInfoStampAnnotXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoSealXElementType {
        pub base_loc: String,
    }
    impl WithSerializer for SianatureSiqnedInfoSealXElementType {
        type Serializer<'x> =
            quick_xml_serialize::SianatureSiqnedInfoSealXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: SianatureSiqnedInfoSealXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoSealXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoSeal") , is_root , })
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoSealXElementType {
        type Deserializer = quick_xml_deserialize::SianatureSiqnedInfoSealXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum SianatureSiqnedInfoReferencesCheckMethodXType {
        Md5,
        Sha1,
    }
    impl SerializeBytes for SianatureSiqnedInfoReferencesCheckMethodXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Md5 => Ok(Some(Cow::Borrowed("MD5"))),
                Self::Sha1 => Ok(Some(Cow::Borrowed("SHA1"))),
            }
        }
    }
    impl DeserializeBytes for SianatureSiqnedInfoReferencesCheckMethodXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"MD5" => Ok(Self::Md5),
                b"SHA1" => Ok(Self::Sha1),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    #[derive(Debug)]
    pub struct SianatureSiqnedInfoReferencesReferenceXElementType {
        pub file_ref: String,
        pub check_value: String,
    }
    impl WithSerializer for SianatureSiqnedInfoReferencesReferenceXElementType {
        type Serializer<'x> =
            quick_xml_serialize::SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("SianatureSiqnedInfoReferencesReference") , is_root , })
        }
    }
    impl WithDeserializer for SianatureSiqnedInfoReferencesReferenceXElementType {
        type Deserializer =
            quick_xml_deserialize::SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct SianatureXElementTypeDeserializer {
            siqned_info: Option<super::SianatureSiqnedInfoXElementType>,
            signed_value: Option<String>,
            state__: Box<SianatureXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureXElementTypeDeserializerState {
            Init__,
            SiqnedInfo(
                Option<<super::SianatureSiqnedInfoXElementType as WithDeserializer>::Deserializer>,
            ),
            SignedValue(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl SianatureXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    siqned_info: None,
                    signed_value: None,
                    state__: Box::new(SianatureXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SianatureXElementTypeDeserializerState as S;
                match state {
                    S::SiqnedInfo(Some(deserializer)) => {
                        self.store_siqned_info(deserializer.finish(helper)?)?
                    }
                    S::SignedValue(Some(deserializer)) => {
                        self.store_signed_value(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_siqned_info(
                &mut self,
                value: super::SianatureSiqnedInfoXElementType,
            ) -> Result<(), Error> {
                if self.siqned_info.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"SiqnedInfo",
                    )))?;
                }
                self.siqned_info = Some(value);
                Ok(())
            }
            fn store_signed_value(&mut self, value: String) -> Result<(), Error> {
                if self.signed_value.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"SignedValue",
                    )))?;
                }
                self.signed_value = Some(value);
                Ok(())
            }
            fn handle_siqned_info<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SianatureSiqnedInfoXElementType>,
                fallback: &mut Option<SianatureXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::SiqnedInfo(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_siqned_info(data)?;
                        *self.state__ = S::SignedValue(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::SiqnedInfo(Some(deserializer)));
                        *self.state__ = S::SignedValue(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_signed_value<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SianatureXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::SignedValue(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_signed_value(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::SignedValue(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SianatureXElementType> for SianatureXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureXElementType> {
                use SianatureXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::SiqnedInfo(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_siqned_info(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::SignedValue(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_signed_value(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::SiqnedInfo(None);
                            event
                        }
                        (S::SiqnedInfo(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"SiqnedInfo",
                                false,
                            )?;
                            match self.handle_siqned_info(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::SignedValue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"SignedValue",
                                false,
                            )?;
                            match self.handle_signed_value(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureXElementType {
                    siqned_info: helper.finish_element("SiqnedInfo", self.siqned_info)?,
                    signed_value: helper.finish_element("SignedValue", self.signed_value)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoXElementTypeDeserializer {
            provider: Option<super::SianatureSiqnedInfoProviderXElementType>,
            signature_method: Option<String>,
            sianature_date_time: Option<String>,
            references: Option<super::SianatureSiqnedInfoReferencesXElementType>,
            stamp_annot: Vec<super::SianatureSiqnedInfoStampAnnotXElementType>,
            seal: Option<super::SianatureSiqnedInfoSealXElementType>,
            state__: Box<SianatureSiqnedInfoXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoXElementTypeDeserializerState {
            Init__ , Provider (Option << super :: SianatureSiqnedInfoProviderXElementType as WithDeserializer > :: Deserializer >) , SignatureMethod (Option << String as WithDeserializer > :: Deserializer >) , SianatureDateTime (Option << String as WithDeserializer > :: Deserializer >) , References (Option << super :: SianatureSiqnedInfoReferencesXElementType as WithDeserializer > :: Deserializer >) , StampAnnot (Option << super :: SianatureSiqnedInfoStampAnnotXElementType as WithDeserializer > :: Deserializer >) , Seal (Option << super :: SianatureSiqnedInfoSealXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl SianatureSiqnedInfoXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    provider: None,
                    signature_method: None,
                    sianature_date_time: None,
                    references: None,
                    stamp_annot: Vec::new(),
                    seal: None,
                    state__: Box::new(SianatureSiqnedInfoXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                match state {
                    S::Provider(Some(deserializer)) => {
                        self.store_provider(deserializer.finish(helper)?)?
                    }
                    S::SignatureMethod(Some(deserializer)) => {
                        self.store_signature_method(deserializer.finish(helper)?)?
                    }
                    S::SianatureDateTime(Some(deserializer)) => {
                        self.store_sianature_date_time(deserializer.finish(helper)?)?
                    }
                    S::References(Some(deserializer)) => {
                        self.store_references(deserializer.finish(helper)?)?
                    }
                    S::StampAnnot(Some(deserializer)) => {
                        self.store_stamp_annot(deserializer.finish(helper)?)?
                    }
                    S::Seal(Some(deserializer)) => self.store_seal(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_provider(
                &mut self,
                value: super::SianatureSiqnedInfoProviderXElementType,
            ) -> Result<(), Error> {
                if self.provider.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"Provider",
                    )))?;
                }
                self.provider = Some(value);
                Ok(())
            }
            fn store_signature_method(&mut self, value: String) -> Result<(), Error> {
                if self.signature_method.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"SignatureMethod",
                    )))?;
                }
                self.signature_method = Some(value);
                Ok(())
            }
            fn store_sianature_date_time(&mut self, value: String) -> Result<(), Error> {
                if self.sianature_date_time.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"SianatureDateTime",
                    )))?;
                }
                self.sianature_date_time = Some(value);
                Ok(())
            }
            fn store_references(
                &mut self,
                value: super::SianatureSiqnedInfoReferencesXElementType,
            ) -> Result<(), Error> {
                if self.references.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"References",
                    )))?;
                }
                self.references = Some(value);
                Ok(())
            }
            fn store_stamp_annot(
                &mut self,
                value: super::SianatureSiqnedInfoStampAnnotXElementType,
            ) -> Result<(), Error> {
                self.stamp_annot.push(value);
                Ok(())
            }
            fn store_seal(
                &mut self,
                value: super::SianatureSiqnedInfoSealXElementType,
            ) -> Result<(), Error> {
                if self.seal.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(b"Seal")))?;
                }
                self.seal = Some(value);
                Ok(())
            }
            fn handle_provider<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SianatureSiqnedInfoProviderXElementType>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Provider(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_provider(data)?;
                        *self.state__ = S::SignatureMethod(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Provider(Some(deserializer)));
                        *self.state__ = S::SignatureMethod(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_signature_method<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::SignatureMethod(None));
                    *self.state__ = S::SianatureDateTime(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_signature_method(data)?;
                        *self.state__ = S::SianatureDateTime(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::SignatureMethod(Some(deserializer)));
                        *self.state__ = S::SianatureDateTime(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_sianature_date_time<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::SianatureDateTime(None));
                    *self.state__ = S::References(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_sianature_date_time(data)?;
                        *self.state__ = S::References(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::SianatureDateTime(Some(deserializer)));
                        *self.state__ = S::References(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_references<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SianatureSiqnedInfoReferencesXElementType>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::References(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_references(data)?;
                        *self.state__ = S::StampAnnot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::References(Some(deserializer)));
                        *self.state__ = S::StampAnnot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_stamp_annot<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SianatureSiqnedInfoStampAnnotXElementType>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::StampAnnot(None));
                    *self.state__ = S::Seal(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_stamp_annot(data)?;
                        *self.state__ = S::StampAnnot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::StampAnnot(Some(deserializer)));
                        *self.state__ = S::StampAnnot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_seal<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SianatureSiqnedInfoSealXElementType>,
                fallback: &mut Option<SianatureSiqnedInfoXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Seal(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_seal(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Seal(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoXElementType>
            for SianatureSiqnedInfoXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoXElementType> {
                use SianatureSiqnedInfoXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Provider(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_provider(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::SignatureMethod(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_signature_method(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::SianatureDateTime(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_sianature_date_time(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::References(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_references(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StampAnnot(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_stamp_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Seal(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_seal(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Provider(None);
                            event
                        }
                        (S::Provider(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Provider",
                                false,
                            )?;
                            match self.handle_provider(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::SignatureMethod(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"SignatureMethod",
                                false,
                            )?;
                            match self.handle_signature_method(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (
                            S::SianatureDateTime(None),
                            event @ (Event::Start(_) | Event::Empty(_)),
                        ) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"SianatureDateTime",
                                false,
                            )?;
                            match self.handle_sianature_date_time(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::References(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"References",
                                false,
                            )?;
                            match self.handle_references(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::StampAnnot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"StampAnnot",
                                false,
                            )?;
                            match self.handle_stamp_annot(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Seal(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Seal",
                                false,
                            )?;
                            match self.handle_seal(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoXElementType {
                    provider: helper.finish_element("Provider", self.provider)?,
                    signature_method: self.signature_method,
                    sianature_date_time: self.sianature_date_time,
                    references: helper.finish_element("References", self.references)?,
                    stamp_annot: self.stamp_annot,
                    seal: self.seal,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoProviderXElementTypeDeserializer {
            provider_name: String,
            version: Option<String>,
            company: Option<String>,
            state__: Box<SianatureSiqnedInfoProviderXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoProviderXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl SianatureSiqnedInfoProviderXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut provider_name: Option<String> = None;
                let mut version: Option<String> = None;
                let mut company: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ProviderName")
                    ) {
                        helper.read_attrib(&mut provider_name, b"ProviderName", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Version")
                    ) {
                        helper.read_attrib(&mut version, b"Version", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Company")
                    ) {
                        helper.read_attrib(&mut company, b"Company", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    provider_name: provider_name
                        .ok_or_else(|| ErrorKind::MissingAttribute("ProviderName".into()))?,
                    version: version,
                    company: company,
                    state__: Box::new(
                        SianatureSiqnedInfoProviderXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoProviderXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoProviderXElementType>
            for SianatureSiqnedInfoProviderXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoProviderXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoProviderXElementType>
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoProviderXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoProviderXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoProviderXElementType {
                    provider_name: self.provider_name,
                    version: self.version,
                    company: self.company,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoReferencesXElementTypeDeserializer {
            check_method: super::SianatureSiqnedInfoReferencesCheckMethodXType,
            reference: Vec<super::SianatureSiqnedInfoReferencesReferenceXElementType>,
            state__: Box<SianatureSiqnedInfoReferencesXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoReferencesXElementTypeDeserializerState {
            Init__ , Reference (Option << super :: SianatureSiqnedInfoReferencesReferenceXElementType as WithDeserializer > :: Deserializer >) , Done__ , Unknown__ , }
        impl SianatureSiqnedInfoReferencesXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut check_method: Option<super::SianatureSiqnedInfoReferencesCheckMethodXType> =
                    None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CheckMethod")
                    ) {
                        helper.read_attrib(&mut check_method, b"CheckMethod", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    check_method: check_method.unwrap_or_else(
                        super::SianatureSiqnedInfoReferencesXElementType::default_check_method,
                    ),
                    reference: Vec::new(),
                    state__: Box::new(
                        SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoReferencesXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SianatureSiqnedInfoReferencesXElementTypeDeserializerState as S;
                match state {
                    S::Reference(Some(deserializer)) => {
                        self.store_reference(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_reference(
                &mut self,
                value: super::SianatureSiqnedInfoReferencesReferenceXElementType,
            ) -> Result<(), Error> {
                self.reference.push(value);
                Ok(())
            }
            fn handle_reference<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<
                    'de,
                    super::SianatureSiqnedInfoReferencesReferenceXElementType,
                >,
                fallback: &mut Option<SianatureSiqnedInfoReferencesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoReferencesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.reference.len() < 1usize {
                        fallback.get_or_insert(S::Reference(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::Reference(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_reference(data)?;
                        *self.state__ = S::Reference(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Reference(Some(deserializer)));
                        *self.state__ = S::Reference(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoReferencesXElementType>
            for SianatureSiqnedInfoReferencesXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesXElementType>
            {
                use SianatureSiqnedInfoReferencesXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::Reference(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_reference(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::Reference(None);
                            event
                        }
                        (S::Reference(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Reference",
                                false,
                            )?;
                            match self.handle_reference(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoReferencesXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoReferencesXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoReferencesXElementType {
                    check_method: self.check_method,
                    reference: helper.finish_vec(1usize, None, self.reference)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoStampAnnotXElementTypeDeserializer {
            id: String,
            page_ref: u32,
            boundary: String,
            clip: Option<String>,
            state__: Box<SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl SianatureSiqnedInfoStampAnnotXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut page_ref: Option<u32> = None;
                let mut boundary: Option<String> = None;
                let mut clip: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"PageRef")
                    ) {
                        helper.read_attrib(&mut page_ref, b"PageRef", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Boundary")
                    ) {
                        helper.read_attrib(&mut boundary, b"Boundary", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Clip")
                    ) {
                        helper.read_attrib(&mut clip, b"Clip", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    page_ref: page_ref
                        .ok_or_else(|| ErrorKind::MissingAttribute("PageRef".into()))?,
                    boundary: boundary
                        .ok_or_else(|| ErrorKind::MissingAttribute("Boundary".into()))?,
                    clip: clip,
                    state__: Box::new(
                        SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
            for SianatureSiqnedInfoStampAnnotXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoStampAnnotXElementType>
            {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoStampAnnotXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoStampAnnotXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoStampAnnotXElementType {
                    id: self.id,
                    page_ref: self.page_ref,
                    boundary: self.boundary,
                    clip: self.clip,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoSealXElementTypeDeserializer {
            base_loc: Option<String>,
            state__: Box<SianatureSiqnedInfoSealXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoSealXElementTypeDeserializerState {
            Init__,
            BaseLoc(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl SianatureSiqnedInfoSealXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    base_loc: None,
                    state__: Box::new(SianatureSiqnedInfoSealXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoSealXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SianatureSiqnedInfoSealXElementTypeDeserializerState as S;
                match state {
                    S::BaseLoc(Some(deserializer)) => {
                        self.store_base_loc(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_base_loc(&mut self, value: String) -> Result<(), Error> {
                if self.base_loc.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"BaseLoc",
                    )))?;
                }
                self.base_loc = Some(value);
                Ok(())
            }
            fn handle_base_loc<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SianatureSiqnedInfoSealXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoSealXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::BaseLoc(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_base_loc(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::BaseLoc(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoSealXElementType>
            for SianatureSiqnedInfoSealXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoSealXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoSealXElementType> {
                use SianatureSiqnedInfoSealXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::BaseLoc(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_base_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::BaseLoc(None);
                            event
                        }
                        (S::BaseLoc(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"BaseLoc",
                                false,
                            )?;
                            match self.handle_base_loc(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoSealXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoSealXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoSealXElementType {
                    base_loc: helper.finish_element("BaseLoc", self.base_loc)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer {
            file_ref: String,
            check_value: Option<String>,
            state__: Box<SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState {
            Init__,
            CheckValue(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut file_ref: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"FileRef")
                    ) {
                        helper.read_attrib(&mut file_ref, b"FileRef", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    file_ref: file_ref
                        .ok_or_else(|| ErrorKind::MissingAttribute("FileRef".into()))?,
                    check_value: None,
                    state__: Box::new(
                        SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Init__,
                    ),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState as S;
                match state {
                    S::CheckValue(Some(deserializer)) => {
                        self.store_check_value(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_check_value(&mut self, value: String) -> Result<(), Error> {
                if self.check_value.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"CheckValue",
                    )))?;
                }
                self.check_value = Some(value);
                Ok(())
            }
            fn handle_check_value<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<
                    SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState,
                >,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::CheckValue(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_check_value(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::CheckValue(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
            for SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
            {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SianatureSiqnedInfoReferencesReferenceXElementType>
            {
                use SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::CheckValue(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_check_value(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::CheckValue(None);
                            event
                        }
                        (S::CheckValue(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"CheckValue",
                                false,
                            )?;
                            match self.handle_check_value(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SianatureSiqnedInfoReferencesReferenceXElementType, Error>
            {
                let state = replace(
                    &mut *self.state__,
                    SianatureSiqnedInfoReferencesReferenceXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SianatureSiqnedInfoReferencesReferenceXElementType {
                    file_ref: self.file_ref,
                    check_value: helper.finish_element("CheckValue", self.check_value)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct SianatureXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureXElementType,
            pub(super) state: Box<SianatureXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureXElementTypeSerializerState<'ser> {
            Init__,
            SiqnedInfo(
                <super::SianatureSiqnedInfoXElementType as WithSerializer>::Serializer<'ser>,
            ),
            SignedValue(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SianatureXElementTypeSerializerState::Init__ => {
                            *self.state = SianatureXElementTypeSerializerState::SiqnedInfo(
                                WithSerializer::serializer(
                                    &self.value.siqned_info,
                                    Some("SiqnedInfo"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SianatureXElementTypeSerializerState::SiqnedInfo(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = SianatureXElementTypeSerializerState::SignedValue(
                                        WithSerializer::serializer(
                                            &self.value.signed_value,
                                            Some("SignedValue"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        SianatureXElementTypeSerializerState::SignedValue(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SianatureXElementTypeSerializerState::End__,
                            }
                        }
                        SianatureXElementTypeSerializerState::End__ => {
                            *self.state = SianatureXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SianatureXElementTypeSerializerState::Done__ => return Ok(None),
                        SianatureXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SianatureXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoXElementType,
            pub(super) state: Box<SianatureSiqnedInfoXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoXElementTypeSerializerState<'ser> {
            Init__,
            Provider(
                <super::SianatureSiqnedInfoProviderXElementType as WithSerializer>::Serializer<
                    'ser,
                >,
            ),
            SignatureMethod(IterSerializer<'ser, Option<&'ser String>, String>),
            SianatureDateTime(IterSerializer<'ser, Option<&'ser String>, String>),
            References(
                <super::SianatureSiqnedInfoReferencesXElementType as WithSerializer>::Serializer<
                    'ser,
                >,
            ),
            StampAnnot(
                IterSerializer<
                    'ser,
                    &'ser [super::SianatureSiqnedInfoStampAnnotXElementType],
                    super::SianatureSiqnedInfoStampAnnotXElementType,
                >,
            ),
            Seal(
                IterSerializer<
                    'ser,
                    Option<&'ser super::SianatureSiqnedInfoSealXElementType>,
                    super::SianatureSiqnedInfoSealXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { SianatureSiqnedInfoXElementTypeSerializerState :: Init__ => { * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: Provider (WithSerializer :: serializer (& self . value . provider , Some ("Provider") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; helper . begin_ns_scope () ; helper . write_xmlns (& mut bytes , None , & super :: super :: NS_UNNAMED_2) ; return Ok (Some (Event :: Start (bytes))) } SianatureSiqnedInfoXElementTypeSerializerState :: Provider (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: SignatureMethod (IterSerializer :: new (self . value . signature_method . as_ref () , Some ("SignatureMethod") , false)) , } SianatureSiqnedInfoXElementTypeSerializerState :: SignatureMethod (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: SianatureDateTime (IterSerializer :: new (self . value . sianature_date_time . as_ref () , Some ("SianatureDateTime") , false)) , } SianatureSiqnedInfoXElementTypeSerializerState :: SianatureDateTime (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: References (WithSerializer :: serializer (& self . value . references , Some ("References") , false) ?) , } SianatureSiqnedInfoXElementTypeSerializerState :: References (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: StampAnnot (IterSerializer :: new (& self . value . stamp_annot [..] , Some ("StampAnnot") , false)) , } SianatureSiqnedInfoXElementTypeSerializerState :: StampAnnot (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: Seal (IterSerializer :: new (self . value . seal . as_ref () , Some ("Seal") , false)) , } SianatureSiqnedInfoXElementTypeSerializerState :: Seal (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: End__ , } SianatureSiqnedInfoXElementTypeSerializerState :: End__ => { * self . state = SianatureSiqnedInfoXElementTypeSerializerState :: Done__ ; helper . end_ns_scope () ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SianatureSiqnedInfoXElementTypeSerializerState :: Done__ => return Ok (None) , SianatureSiqnedInfoXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SianatureSiqnedInfoXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoProviderXElementType,
            pub(super) state: Box<SianatureSiqnedInfoProviderXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoProviderXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SianatureSiqnedInfoProviderXElementTypeSerializerState::Init__ => {
                            *self.state =
                                SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "ProviderName",
                                &self.value.provider_name,
                            )?;
                            helper.write_attrib_opt(&mut bytes, "Version", &self.value.version)?;
                            helper.write_attrib_opt(&mut bytes, "Company", &self.value.company)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        SianatureSiqnedInfoProviderXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoProviderXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            SianatureSiqnedInfoProviderXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoReferencesXElementType,
            pub(super) state: Box<SianatureSiqnedInfoReferencesXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoReferencesXElementTypeSerializerState<'ser> {
            Init__,
            Reference(
                IterSerializer<
                    'ser,
                    &'ser [super::SianatureSiqnedInfoReferencesReferenceXElementType],
                    super::SianatureSiqnedInfoReferencesReferenceXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SianatureSiqnedInfoReferencesXElementTypeSerializerState::Init__ => {
                            *self.state =
                                SianatureSiqnedInfoReferencesXElementTypeSerializerState::Reference(
                                    IterSerializer::new(
                                        &self.value.reference[..],
                                        Some("Reference"),
                                        false,
                                    ),
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(
                                &mut bytes,
                                "CheckMethod",
                                &self.value.check_method,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SianatureSiqnedInfoReferencesXElementTypeSerializerState::Reference(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state =
                                    SianatureSiqnedInfoReferencesXElementTypeSerializerState::End__,
                            }
                        }
                        SianatureSiqnedInfoReferencesXElementTypeSerializerState::End__ => {
                            *self.state =
                                SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        SianatureSiqnedInfoReferencesXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoReferencesXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            SianatureSiqnedInfoReferencesXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoStampAnnotXElementType,
            pub(super) state: Box<SianatureSiqnedInfoStampAnnotXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoStampAnnotXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Init__ => {
                            *self.state =
                                SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "PageRef", &self.value.page_ref)?;
                            helper.write_attrib(&mut bytes, "Boundary", &self.value.boundary)?;
                            helper.write_attrib_opt(&mut bytes, "Clip", &self.value.clip)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoStampAnnotXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state =
                            SianatureSiqnedInfoStampAnnotXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoSealXElementType,
            pub(super) state: Box<SianatureSiqnedInfoSealXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoSealXElementTypeSerializerState<'ser> {
            Init__,
            BaseLoc(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SianatureSiqnedInfoSealXElementTypeSerializerState::Init__ => {
                            *self.state =
                                SianatureSiqnedInfoSealXElementTypeSerializerState::BaseLoc(
                                    WithSerializer::serializer(
                                        &self.value.base_loc,
                                        Some("BaseLoc"),
                                        false,
                                    )?,
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SianatureSiqnedInfoSealXElementTypeSerializerState::BaseLoc(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        SianatureSiqnedInfoSealXElementTypeSerializerState::End__
                                }
                            }
                        }
                        SianatureSiqnedInfoSealXElementTypeSerializerState::End__ => {
                            *self.state =
                                SianatureSiqnedInfoSealXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SianatureSiqnedInfoSealXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        SianatureSiqnedInfoSealXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoSealXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SianatureSiqnedInfoSealXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SianatureSiqnedInfoReferencesReferenceXElementType,
            pub(super) state:
                Box<SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState<'ser> {
            Init__,
            CheckValue(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match & mut * self . state { SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Init__ => { * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: CheckValue (WithSerializer :: serializer (& self . value . check_value , Some ("CheckValue") , false) ?) ; let mut bytes = BytesStart :: new (self . name) ; helper . begin_ns_scope () ; helper . write_xmlns (& mut bytes , None , & super :: super :: NS_UNNAMED_2) ; helper . write_attrib (& mut bytes , "FileRef" , & self . value . file_ref) ? ; return Ok (Some (Event :: Start (bytes))) } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: CheckValue (x) => match x . next (helper) . transpose () ? { Some (event) => return Ok (Some (event)) , None => * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: End__ , } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: End__ => { * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Done__ ; helper . end_ns_scope () ; return Ok (Some (Event :: End (BytesEnd :: new (self . name)))) ; } SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Done__ => return Ok (None) , SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Phantom__ (_) => unreachable ! () , }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SianatureSiqnedInfoReferencesReferenceXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        * self . state = SianatureSiqnedInfoReferencesReferenceXElementTypeSerializerState :: Done__ ;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod signatures {
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, ErrorKind, RawByteStr, SerializeBytes,
        SerializeHelper, WithDeserializer, WithSerializer,
    };
    pub type Siqnatures = SiqnaturesXElementType;
    #[derive(Debug)]
    pub struct SiqnaturesXElementType {
        pub max_sign_id: Option<String>,
        pub signature: Vec<SiqnaturesSignatureXElementType>,
    }
    impl WithSerializer for SiqnaturesXElementType {
        type Serializer<'x> = quick_xml_serialize::SiqnaturesXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::SiqnaturesXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::SiqnaturesXElementTypeSerializerState::Init__),
                name: name.unwrap_or("Siqnatures"),
                is_root,
            })
        }
    }
    impl WithDeserializer for SiqnaturesXElementType {
        type Deserializer = quick_xml_deserialize::SiqnaturesXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct SiqnaturesSignatureXElementType {
        pub id: String,
        pub type_: SiqnaturesSignatureTypeXType,
        pub base_loc: String,
    }
    impl SiqnaturesSignatureXElementType {
        #[must_use]
        pub fn default_type_() -> SiqnaturesSignatureTypeXType {
            SiqnaturesSignatureTypeXType::Seal
        }
    }
    impl WithSerializer for SiqnaturesSignatureXElementType {
        type Serializer<'x> = quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::SiqnaturesSignatureXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("SiqnaturesSignature"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for SiqnaturesSignatureXElementType {
        type Deserializer = quick_xml_deserialize::SiqnaturesSignatureXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub enum SiqnaturesSignatureTypeXType {
        Seal,
        Siqn,
    }
    impl SerializeBytes for SiqnaturesSignatureTypeXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            match self {
                Self::Seal => Ok(Some(Cow::Borrowed("Seal"))),
                Self::Siqn => Ok(Some(Cow::Borrowed("Siqn"))),
            }
        }
    }
    impl DeserializeBytes for SiqnaturesSignatureTypeXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            match bytes {
                b"Seal" => Ok(Self::Seal),
                b"Siqn" => Ok(Self::Siqn),
                x => Err(Error::from(ErrorKind::UnknownOrInvalidValue(
                    RawByteStr::from_slice(x),
                ))),
            }
        }
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, DeserializeHelper, Deserializer, DeserializerArtifact, DeserializerEvent,
            DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error, ErrorKind, Event,
            RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct SiqnaturesXElementTypeDeserializer {
            max_sign_id: Option<String>,
            signature: Vec<super::SiqnaturesSignatureXElementType>,
            state__: Box<SiqnaturesXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SiqnaturesXElementTypeDeserializerState {
            Init__,
            MaxSignId(Option<<String as WithDeserializer>::Deserializer>),
            Signature(
                Option<<super::SiqnaturesSignatureXElementType as WithDeserializer>::Deserializer>,
            ),
            Done__,
            Unknown__,
        }
        impl SiqnaturesXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    max_sign_id: None,
                    signature: Vec::new(),
                    state__: Box::new(SiqnaturesXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SiqnaturesXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use SiqnaturesXElementTypeDeserializerState as S;
                match state {
                    S::MaxSignId(Some(deserializer)) => {
                        self.store_max_sign_id(deserializer.finish(helper)?)?
                    }
                    S::Signature(Some(deserializer)) => {
                        self.store_signature(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_max_sign_id(&mut self, value: String) -> Result<(), Error> {
                if self.max_sign_id.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"MaxSignId",
                    )))?;
                }
                self.max_sign_id = Some(value);
                Ok(())
            }
            fn store_signature(
                &mut self,
                value: super::SiqnaturesSignatureXElementType,
            ) -> Result<(), Error> {
                self.signature.push(value);
                Ok(())
            }
            fn handle_max_sign_id<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<SiqnaturesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SiqnaturesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::MaxSignId(None));
                    *self.state__ = S::Signature(None);
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_max_sign_id(data)?;
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::MaxSignId(Some(deserializer)));
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_signature<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::SiqnaturesSignatureXElementType>,
                fallback: &mut Option<SiqnaturesXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use SiqnaturesXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::Signature(None));
                    *self.state__ = S::Done__;
                    return Ok(ElementHandlerOutput::from_event(event, allow_any));
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_signature(data)?;
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::Signature(Some(deserializer)));
                        *self.state__ = S::Signature(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::SiqnaturesXElementType> for SiqnaturesXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SiqnaturesXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SiqnaturesXElementType> {
                use SiqnaturesXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::MaxSignId(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_max_sign_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signature(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_signature(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::MaxSignId(None);
                            event
                        }
                        (S::MaxSignId(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"MaxSignId",
                                false,
                            )?;
                            match self.handle_max_sign_id(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Signature(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"Signature",
                                false,
                            )?;
                            match self.handle_signature(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SiqnaturesXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SiqnaturesXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SiqnaturesXElementType {
                    max_sign_id: self.max_sign_id,
                    signature: self.signature,
                })
            }
        }
        #[derive(Debug)]
        pub struct SiqnaturesSignatureXElementTypeDeserializer {
            id: String,
            type_: super::SiqnaturesSignatureTypeXType,
            base_loc: String,
            state__: Box<SiqnaturesSignatureXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum SiqnaturesSignatureXElementTypeDeserializerState {
            Init__,
            Unknown__,
        }
        impl SiqnaturesSignatureXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut type_: Option<super::SiqnaturesSignatureTypeXType> = None;
                let mut base_loc: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Type")
                    ) {
                        helper.read_attrib(&mut type_, b"Type", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"BaseLoc")
                    ) {
                        helper.read_attrib(&mut base_loc, b"BaseLoc", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    type_: type_
                        .unwrap_or_else(super::SiqnaturesSignatureXElementType::default_type_),
                    base_loc: base_loc
                        .ok_or_else(|| ErrorKind::MissingAttribute("BaseLoc".into()))?,
                    state__: Box::new(SiqnaturesSignatureXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: SiqnaturesSignatureXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                Ok(())
            }
        }
        impl<'de> Deserializer<'de, super::SiqnaturesSignatureXElementType>
            for SiqnaturesSignatureXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SiqnaturesSignatureXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::SiqnaturesSignatureXElementType> {
                if let Event::End(_) = &event {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Data(self.finish(helper)?),
                        event: DeserializerEvent::None,
                        allow_any: false,
                    })
                } else {
                    Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::Deserializer(self),
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    })
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::SiqnaturesSignatureXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    SiqnaturesSignatureXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::SiqnaturesSignatureXElementType {
                    id: self.id,
                    type_: self.type_,
                    base_loc: self.base_loc,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
        };
        #[derive(Debug)]
        pub struct SiqnaturesXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SiqnaturesXElementType,
            pub(super) state: Box<SiqnaturesXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SiqnaturesXElementTypeSerializerState<'ser> {
            Init__,
            MaxSignId(IterSerializer<'ser, Option<&'ser String>, String>),
            Signature(
                IterSerializer<
                    'ser,
                    &'ser [super::SiqnaturesSignatureXElementType],
                    super::SiqnaturesSignatureXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SiqnaturesXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SiqnaturesXElementTypeSerializerState::Init__ => {
                            *self.state = SiqnaturesXElementTypeSerializerState::MaxSignId(
                                IterSerializer::new(
                                    self.value.max_sign_id.as_ref(),
                                    Some("MaxSignId"),
                                    false,
                                ),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        SiqnaturesXElementTypeSerializerState::MaxSignId(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = SiqnaturesXElementTypeSerializerState::Signature(
                                        IterSerializer::new(
                                            &self.value.signature[..],
                                            Some("Signature"),
                                            false,
                                        ),
                                    )
                                }
                            }
                        }
                        SiqnaturesXElementTypeSerializerState::Signature(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = SiqnaturesXElementTypeSerializerState::End__,
                            }
                        }
                        SiqnaturesXElementTypeSerializerState::End__ => {
                            *self.state = SiqnaturesXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        SiqnaturesXElementTypeSerializerState::Done__ => return Ok(None),
                        SiqnaturesXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SiqnaturesXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SiqnaturesXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct SiqnaturesSignatureXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::SiqnaturesSignatureXElementType,
            pub(super) state: Box<SiqnaturesSignatureXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum SiqnaturesSignatureXElementTypeSerializerState<'ser> {
            Init__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> SiqnaturesSignatureXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        SiqnaturesSignatureXElementTypeSerializerState::Init__ => {
                            *self.state = SiqnaturesSignatureXElementTypeSerializerState::Done__;
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib(&mut bytes, "Type", &self.value.type_)?;
                            helper.write_attrib(&mut bytes, "BaseLoc", &self.value.base_loc)?;
                            helper.end_ns_scope();
                            return Ok(Some(Event::Empty(bytes)));
                        }
                        SiqnaturesSignatureXElementTypeSerializerState::Done__ => return Ok(None),
                        SiqnaturesSignatureXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for SiqnaturesSignatureXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = SiqnaturesSignatureXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod version {
    use xsd_parser_types::quick_xml::{Error, WithDeserializer, WithSerializer};
    pub type DocVersion = DocVersionXElementType;
    #[derive(Debug)]
    pub struct DocVersionXElementType {
        pub id: String,
        pub version: Option<String>,
        pub name: Option<String>,
        pub creation_date: Option<String>,
        pub file_list: DocVersionFileListXElementType,
        pub doc_root: String,
    }
    impl WithSerializer for DocVersionXElementType {
        type Serializer<'x> = quick_xml_serialize::DocVersionXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(quick_xml_serialize::DocVersionXElementTypeSerializer {
                value: self,
                state: Box::new(quick_xml_serialize::DocVersionXElementTypeSerializerState::Init__),
                name: name.unwrap_or("DocVersion"),
                is_root,
            })
        }
    }
    impl WithDeserializer for DocVersionXElementType {
        type Deserializer = quick_xml_deserialize::DocVersionXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocVersionFileListXElementType {
        pub file: Vec<DocVersionFileListFileXElementType>,
    }
    impl WithSerializer for DocVersionFileListXElementType {
        type Serializer<'x> = quick_xml_serialize::DocVersionFileListXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok(
                quick_xml_serialize::DocVersionFileListXElementTypeSerializer {
                    value: self,
                    state: Box::new(
                        quick_xml_serialize::DocVersionFileListXElementTypeSerializerState::Init__,
                    ),
                    name: name.unwrap_or("DocVersionFileList"),
                    is_root,
                },
            )
        }
    }
    impl WithDeserializer for DocVersionFileListXElementType {
        type Deserializer = quick_xml_deserialize::DocVersionFileListXElementTypeDeserializer;
    }
    #[derive(Debug)]
    pub struct DocVersionFileListFileXElementType {
        pub id: String,
        pub content: String,
    }
    impl WithSerializer for DocVersionFileListFileXElementType {
        type Serializer<'x> = quick_xml_serialize::DocVersionFileListFileXElementTypeSerializer<'x>;
        fn serializer<'ser>(
            &'ser self,
            name: Option<&'ser str>,
            is_root: bool,
        ) -> Result<Self::Serializer<'ser>, Error> {
            Ok (quick_xml_serialize :: DocVersionFileListFileXElementTypeSerializer { value : self , state : Box :: new (quick_xml_serialize :: DocVersionFileListFileXElementTypeSerializerState :: Init__) , name : name . unwrap_or ("DocVersionFileListFile") , is_root , })
        }
    }
    impl WithDeserializer for DocVersionFileListFileXElementType {
        type Deserializer = quick_xml_deserialize::DocVersionFileListFileXElementTypeDeserializer;
    }
    pub mod quick_xml_deserialize {
        use core::mem::replace;
        use xsd_parser_types::quick_xml::{
            BytesStart, ContentDeserializer, DeserializeHelper, Deserializer, DeserializerArtifact,
            DeserializerEvent, DeserializerOutput, DeserializerResult, ElementHandlerOutput, Error,
            ErrorKind, Event, RawByteStr, WithDeserializer,
        };
        #[derive(Debug)]
        pub struct DocVersionXElementTypeDeserializer {
            id: String,
            version: Option<String>,
            name: Option<String>,
            creation_date: Option<String>,
            file_list: Option<super::DocVersionFileListXElementType>,
            doc_root: Option<String>,
            state__: Box<DocVersionXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocVersionXElementTypeDeserializerState {
            Init__,
            FileList(
                Option<<super::DocVersionFileListXElementType as WithDeserializer>::Deserializer>,
            ),
            DocRoot(Option<<String as WithDeserializer>::Deserializer>),
            Done__,
            Unknown__,
        }
        impl DocVersionXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                let mut version: Option<String> = None;
                let mut name: Option<String> = None;
                let mut creation_date: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Version")
                    ) {
                        helper.read_attrib(&mut version, b"Version", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"Name")
                    ) {
                        helper.read_attrib(&mut name, b"Name", &attrib.value)?;
                    } else if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"CreationDate")
                    ) {
                        helper.read_attrib(&mut creation_date, b"CreationDate", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    version: version,
                    name: name,
                    creation_date: creation_date,
                    file_list: None,
                    doc_root: None,
                    state__: Box::new(DocVersionXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocVersionXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocVersionXElementTypeDeserializerState as S;
                match state {
                    S::FileList(Some(deserializer)) => {
                        self.store_file_list(deserializer.finish(helper)?)?
                    }
                    S::DocRoot(Some(deserializer)) => {
                        self.store_doc_root(deserializer.finish(helper)?)?
                    }
                    _ => (),
                }
                Ok(())
            }
            fn store_file_list(
                &mut self,
                value: super::DocVersionFileListXElementType,
            ) -> Result<(), Error> {
                if self.file_list.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"FileList",
                    )))?;
                }
                self.file_list = Some(value);
                Ok(())
            }
            fn store_doc_root(&mut self, value: String) -> Result<(), Error> {
                if self.doc_root.is_some() {
                    Err(ErrorKind::DuplicateElement(RawByteStr::from_slice(
                        b"DocRoot",
                    )))?;
                }
                self.doc_root = Some(value);
                Ok(())
            }
            fn handle_file_list<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocVersionFileListXElementType>,
                fallback: &mut Option<DocVersionXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocVersionXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::FileList(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_file_list(data)?;
                        *self.state__ = S::DocRoot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::FileList(Some(deserializer)));
                        *self.state__ = S::DocRoot(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
            fn handle_doc_root<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
                fallback: &mut Option<DocVersionXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocVersionXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    fallback.get_or_insert(S::DocRoot(None));
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else {
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_doc_root(data)?;
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::DocRoot(Some(deserializer)));
                        *self.state__ = S::Done__;
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocVersionXElementType> for DocVersionXElementTypeDeserializer {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionXElementType> {
                use DocVersionXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::FileList(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_file_list(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocRoot(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_doc_root(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::FileList(None);
                            event
                        }
                        (S::FileList(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"FileList",
                                false,
                            )?;
                            match self.handle_file_list(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::DocRoot(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"DocRoot",
                                false,
                            )?;
                            match self.handle_doc_root(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocVersionXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocVersionXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocVersionXElementType {
                    id: self.id,
                    version: self.version,
                    name: self.name,
                    creation_date: self.creation_date,
                    file_list: helper.finish_element("FileList", self.file_list)?,
                    doc_root: helper.finish_element("DocRoot", self.doc_root)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocVersionFileListXElementTypeDeserializer {
            file: Vec<super::DocVersionFileListFileXElementType>,
            state__: Box<DocVersionFileListXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocVersionFileListXElementTypeDeserializerState {
            Init__,
            File(
                Option<
                    <super::DocVersionFileListFileXElementType as WithDeserializer>::Deserializer,
                >,
            ),
            Done__,
            Unknown__,
        }
        impl DocVersionFileListXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    helper.raise_unexpected_attrib_checked(&attrib)?;
                }
                Ok(Self {
                    file: Vec::new(),
                    state__: Box::new(DocVersionFileListXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocVersionFileListXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                use DocVersionFileListXElementTypeDeserializerState as S;
                match state {
                    S::File(Some(deserializer)) => self.store_file(deserializer.finish(helper)?)?,
                    _ => (),
                }
                Ok(())
            }
            fn store_file(
                &mut self,
                value: super::DocVersionFileListFileXElementType,
            ) -> Result<(), Error> {
                self.file.push(value);
                Ok(())
            }
            fn handle_file<'de>(
                &mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, super::DocVersionFileListFileXElementType>,
                fallback: &mut Option<DocVersionFileListXElementTypeDeserializerState>,
            ) -> Result<ElementHandlerOutput<'de>, Error> {
                use DocVersionFileListXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                if artifact.is_none() {
                    if matches!(&fallback, Some(S::Init__)) {
                        return Ok(ElementHandlerOutput::break_(event, allow_any));
                    } else if self.file.len() < 1usize {
                        fallback.get_or_insert(S::File(None));
                        return Ok(ElementHandlerOutput::return_to_root(event, allow_any));
                    } else {
                        fallback.get_or_insert(S::File(None));
                        *self.state__ = S::Done__;
                        return Ok(ElementHandlerOutput::from_event(event, allow_any));
                    }
                }
                if let Some(fallback) = fallback.take() {
                    self.finish_state(helper, fallback)?;
                }
                match artifact {
                    DeserializerArtifact::None => unreachable!(),
                    DeserializerArtifact::Data(data) => {
                        self.store_file(data)?;
                        *self.state__ = S::File(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        fallback.get_or_insert(S::File(Some(deserializer)));
                        *self.state__ = S::File(None);
                        Ok(ElementHandlerOutput::from_event(event, allow_any))
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocVersionFileListXElementType>
            for DocVersionFileListXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionFileListXElementType> {
                helper.init_deserializer_from_start_event(event, Self::from_bytes_start)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionFileListXElementType> {
                use DocVersionFileListXElementTypeDeserializerState as S;
                let mut event = event;
                let mut fallback = None;
                let mut allow_any_element = false;
                let (event, allow_any) = loop {
                    let state = replace(&mut *self.state__, S::Unknown__);
                    event = match (state, event) {
                        (S::Unknown__, _) => unreachable!(),
                        (S::File(Some(deserializer)), event) => {
                            let output = deserializer.next(helper, event)?;
                            match self.handle_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (_, Event::End(_)) => {
                            if let Some(fallback) = fallback.take() {
                                self.finish_state(helper, fallback)?;
                            }
                            return Ok(DeserializerOutput {
                                artifact: DeserializerArtifact::Data(self.finish(helper)?),
                                event: DeserializerEvent::None,
                                allow_any: false,
                            });
                        }
                        (S::Init__, event) => {
                            fallback.get_or_insert(S::Init__);
                            *self.state__ = S::File(None);
                            event
                        }
                        (S::File(None), event @ (Event::Start(_) | Event::Empty(_))) => {
                            let output = helper.init_start_tag_deserializer(
                                event,
                                Some(&super::super::NS_UNNAMED_2),
                                b"File",
                                false,
                            )?;
                            match self.handle_file(helper, output, &mut fallback)? {
                                ElementHandlerOutput::Continue { event, allow_any } => {
                                    allow_any_element = allow_any_element || allow_any;
                                    event
                                }
                                ElementHandlerOutput::Break { event, allow_any } => {
                                    break (event, allow_any)
                                }
                            }
                        }
                        (S::Done__, event) => {
                            *self.state__ = S::Done__;
                            break (DeserializerEvent::Continue(event), allow_any_element);
                        }
                        (state, event) => {
                            *self.state__ = state;
                            break (DeserializerEvent::Break(event), false);
                        }
                    }
                };
                if let Some(fallback) = fallback {
                    *self.state__ = fallback;
                }
                Ok(DeserializerOutput {
                    artifact: DeserializerArtifact::Deserializer(self),
                    event,
                    allow_any,
                })
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocVersionFileListXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocVersionFileListXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocVersionFileListXElementType {
                    file: helper.finish_vec(1usize, None, self.file)?,
                })
            }
        }
        #[derive(Debug)]
        pub struct DocVersionFileListFileXElementTypeDeserializer {
            id: String,
            content: Option<String>,
            state__: Box<DocVersionFileListFileXElementTypeDeserializerState>,
        }
        #[derive(Debug)]
        enum DocVersionFileListFileXElementTypeDeserializerState {
            Init__,
            Content__(<String as WithDeserializer>::Deserializer),
            Unknown__,
        }
        impl DocVersionFileListFileXElementTypeDeserializer {
            fn from_bytes_start(
                helper: &mut DeserializeHelper,
                bytes_start: &BytesStart<'_>,
            ) -> Result<Self, Error> {
                let mut id: Option<String> = None;
                for attrib in helper.filter_xmlns_attributes(bytes_start) {
                    let attrib = attrib?;
                    if matches!(
                        helper.resolve_local_name(attrib.key, &super::super::NS_UNNAMED_2),
                        Some(b"ID")
                    ) {
                        helper.read_attrib(&mut id, b"ID", &attrib.value)?;
                    } else {
                        helper.raise_unexpected_attrib_checked(&attrib)?;
                    }
                }
                Ok(Self {
                    id: id.ok_or_else(|| ErrorKind::MissingAttribute("ID".into()))?,
                    content: None,
                    state__: Box::new(DocVersionFileListFileXElementTypeDeserializerState::Init__),
                })
            }
            fn finish_state(
                &mut self,
                helper: &mut DeserializeHelper,
                state: DocVersionFileListFileXElementTypeDeserializerState,
            ) -> Result<(), Error> {
                if let DocVersionFileListFileXElementTypeDeserializerState::Content__(
                    deserializer,
                ) = state
                {
                    self.store_content(deserializer.finish(helper)?)?;
                }
                Ok(())
            }
            fn store_content(&mut self, value: String) -> Result<(), Error> {
                if self.content.is_some() {
                    Err(ErrorKind::DuplicateContent)?;
                }
                self.content = Some(value);
                Ok(())
            }
            fn handle_content<'de>(
                mut self,
                helper: &mut DeserializeHelper,
                output: DeserializerOutput<'de, String>,
            ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType> {
                use DocVersionFileListFileXElementTypeDeserializerState as S;
                let DeserializerOutput {
                    artifact,
                    event,
                    allow_any,
                } = output;
                match artifact {
                    DeserializerArtifact::None => Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event,
                        allow_any,
                    }),
                    DeserializerArtifact::Data(data) => {
                        self.store_content(data)?;
                        let data = self.finish(helper)?;
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Data(data),
                            event,
                            allow_any,
                        })
                    }
                    DeserializerArtifact::Deserializer(deserializer) => {
                        *self.state__ = S::Content__(deserializer);
                        Ok(DeserializerOutput {
                            artifact: DeserializerArtifact::Deserializer(self),
                            event,
                            allow_any,
                        })
                    }
                }
            }
        }
        impl<'de> Deserializer<'de, super::DocVersionFileListFileXElementType>
            for DocVersionFileListFileXElementTypeDeserializer
        {
            fn init(
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType> {
                let (Event::Start(x) | Event::Empty(x)) = &event else {
                    return Ok(DeserializerOutput {
                        artifact: DeserializerArtifact::None,
                        event: DeserializerEvent::Break(event),
                        allow_any: false,
                    });
                };
                Self::from_bytes_start(helper, x)?.next(helper, event)
            }
            fn next(
                mut self,
                helper: &mut DeserializeHelper,
                event: Event<'de>,
            ) -> DeserializerResult<'de, super::DocVersionFileListFileXElementType> {
                use DocVersionFileListFileXElementTypeDeserializerState as S;
                match replace(&mut *self.state__, S::Unknown__) {
                    S::Unknown__ => unreachable!(),
                    S::Init__ => {
                        let output = ContentDeserializer::init(helper, event)?;
                        self.handle_content(helper, output)
                    }
                    S::Content__(deserializer) => {
                        let output = deserializer.next(helper, event)?;
                        self.handle_content(helper, output)
                    }
                }
            }
            fn finish(
                mut self,
                helper: &mut DeserializeHelper,
            ) -> Result<super::DocVersionFileListFileXElementType, Error> {
                let state = replace(
                    &mut *self.state__,
                    DocVersionFileListFileXElementTypeDeserializerState::Unknown__,
                );
                self.finish_state(helper, state)?;
                Ok(super::DocVersionFileListFileXElementType {
                    id: self.id,
                    content: helper.finish_content(self.content)?,
                })
            }
        }
    }
    pub mod quick_xml_serialize {
        use xsd_parser_types::quick_xml::{
            BytesEnd, BytesStart, Error, Event, IterSerializer, SerializeHelper, Serializer,
            WithSerializer,
        };
        #[derive(Debug)]
        pub struct DocVersionXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocVersionXElementType,
            pub(super) state: Box<DocVersionXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocVersionXElementTypeSerializerState<'ser> {
            Init__,
            FileList(<super::DocVersionFileListXElementType as WithSerializer>::Serializer<'ser>),
            DocRoot(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocVersionXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocVersionXElementTypeSerializerState::Init__ => {
                            *self.state = DocVersionXElementTypeSerializerState::FileList(
                                WithSerializer::serializer(
                                    &self.value.file_list,
                                    Some("FileList"),
                                    false,
                                )?,
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            helper.write_attrib_opt(&mut bytes, "Version", &self.value.version)?;
                            helper.write_attrib_opt(&mut bytes, "Name", &self.value.name)?;
                            helper.write_attrib_opt(
                                &mut bytes,
                                "CreationDate",
                                &self.value.creation_date,
                            )?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocVersionXElementTypeSerializerState::FileList(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state = DocVersionXElementTypeSerializerState::DocRoot(
                                        WithSerializer::serializer(
                                            &self.value.doc_root,
                                            Some("DocRoot"),
                                            false,
                                        )?,
                                    )
                                }
                            }
                        }
                        DocVersionXElementTypeSerializerState::DocRoot(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => *self.state = DocVersionXElementTypeSerializerState::End__,
                            }
                        }
                        DocVersionXElementTypeSerializerState::End__ => {
                            *self.state = DocVersionXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocVersionXElementTypeSerializerState::Done__ => return Ok(None),
                        DocVersionXElementTypeSerializerState::Phantom__(_) => unreachable!(),
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocVersionXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocVersionXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocVersionFileListXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocVersionFileListXElementType,
            pub(super) state: Box<DocVersionFileListXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocVersionFileListXElementTypeSerializerState<'ser> {
            Init__,
            File(
                IterSerializer<
                    'ser,
                    &'ser [super::DocVersionFileListFileXElementType],
                    super::DocVersionFileListFileXElementType,
                >,
            ),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocVersionFileListXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocVersionFileListXElementTypeSerializerState::Init__ => {
                            *self.state = DocVersionFileListXElementTypeSerializerState::File(
                                IterSerializer::new(&self.value.file[..], Some("File"), false),
                            );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocVersionFileListXElementTypeSerializerState::File(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocVersionFileListXElementTypeSerializerState::End__
                                }
                            }
                        }
                        DocVersionFileListXElementTypeSerializerState::End__ => {
                            *self.state = DocVersionFileListXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocVersionFileListXElementTypeSerializerState::Done__ => return Ok(None),
                        DocVersionFileListXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocVersionFileListXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocVersionFileListXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
        #[derive(Debug)]
        pub struct DocVersionFileListFileXElementTypeSerializer<'ser> {
            pub(super) value: &'ser super::DocVersionFileListFileXElementType,
            pub(super) state: Box<DocVersionFileListFileXElementTypeSerializerState<'ser>>,
            pub(super) name: &'ser str,
            pub(super) is_root: bool,
        }
        #[derive(Debug)]
        pub(super) enum DocVersionFileListFileXElementTypeSerializerState<'ser> {
            Init__,
            Content__(<String as WithSerializer>::Serializer<'ser>),
            End__,
            Done__,
            Phantom__(&'ser ()),
        }
        impl<'ser> DocVersionFileListFileXElementTypeSerializer<'ser> {
            fn next_event(
                &mut self,
                helper: &mut SerializeHelper,
            ) -> Result<Option<Event<'ser>>, Error> {
                loop {
                    match &mut *self.state {
                        DocVersionFileListFileXElementTypeSerializerState::Init__ => {
                            *self.state =
                                DocVersionFileListFileXElementTypeSerializerState::Content__(
                                    WithSerializer::serializer(&self.value.content, None, false)?,
                                );
                            let mut bytes = BytesStart::new(self.name);
                            helper.begin_ns_scope();
                            helper.write_xmlns(&mut bytes, None, &super::super::NS_UNNAMED_2);
                            helper.write_attrib(&mut bytes, "ID", &self.value.id)?;
                            return Ok(Some(Event::Start(bytes)));
                        }
                        DocVersionFileListFileXElementTypeSerializerState::Content__(x) => {
                            match x.next(helper).transpose()? {
                                Some(event) => return Ok(Some(event)),
                                None => {
                                    *self.state =
                                        DocVersionFileListFileXElementTypeSerializerState::End__
                                }
                            }
                        }
                        DocVersionFileListFileXElementTypeSerializerState::End__ => {
                            *self.state = DocVersionFileListFileXElementTypeSerializerState::Done__;
                            helper.end_ns_scope();
                            return Ok(Some(Event::End(BytesEnd::new(self.name))));
                        }
                        DocVersionFileListFileXElementTypeSerializerState::Done__ => {
                            return Ok(None)
                        }
                        DocVersionFileListFileXElementTypeSerializerState::Phantom__(_) => {
                            unreachable!()
                        }
                    }
                }
            }
        }
        impl<'ser> Serializer<'ser> for DocVersionFileListFileXElementTypeSerializer<'ser> {
            fn next(&mut self, helper: &mut SerializeHelper) -> Option<Result<Event<'ser>, Error>> {
                match self.next_event(helper) {
                    Ok(Some(event)) => Some(Ok(event)),
                    Ok(None) => None,
                    Err(error) => {
                        *self.state = DocVersionFileListFileXElementTypeSerializerState::Done__;
                        Some(Err(error))
                    }
                }
            }
        }
    }
}
pub mod xs {
    use core::num::{NonZeroIsize, NonZeroUsize};
    use num::{BigInt, BigUint};
    use std::borrow::Cow;
    use xsd_parser_types::quick_xml::{
        DeserializeBytes, DeserializeHelper, Error, SerializeBytes, SerializeHelper,
    };
    #[derive(Debug, Default)]
    pub struct EntitiesXType(pub Vec<String>);
    impl SerializeBytes for EntitiesXType {
        fn serialize_bytes(
            &self,
            helper: &mut SerializeHelper,
        ) -> Result<Option<Cow<'_, str>>, Error> {
            if self.0.is_empty() {
                return Ok(None);
            }
            let mut data = String::new();
            for item in &self.0 {
                if let Some(bytes) = item.serialize_bytes(helper)? {
                    if !data.is_empty() {
                        data.push(' ');
                    }
                    data.push_str(&bytes);
                }
            }
            Ok(Some(Cow::Owned(data)))
        }
    }
    impl DeserializeBytes for EntitiesXType {
        fn deserialize_bytes(helper: &mut DeserializeHelper, bytes: &[u8]) -> Result<Self, Error> {
            Ok(Self(helper.deserialize_list(bytes)?))
        }
    }
    pub type EntityXType = EntitiesXType;
    pub type IdXType = String;
    pub type IdrefXType = String;
    pub type IdrefsXType = EntitiesXType;
    pub type NcNameXType = String;
    pub type NmtokenXType = String;
    pub type NmtokensXType = EntitiesXType;
    pub type NotationXType = String;
    pub type NameXType = String;
    pub type QNameXType = String;
    pub type AnySimpleTypeXType = String;
    pub type AnyUriXType = String;
    pub type Base64BinaryXType = String;
    pub type BooleanXType = bool;
    pub type ByteXType = i8;
    pub type DateXType = String;
    pub type DateTimeXType = String;
    pub type DecimalXType = f64;
    pub type DoubleXType = f64;
    pub type DurationXType = String;
    pub type FloatXType = f32;
    pub type GDayXType = String;
    pub type GMonthXType = String;
    pub type GMonthDayXType = String;
    pub type GYearXType = String;
    pub type GYearMonthXType = String;
    pub type HexBinaryXType = String;
    pub type IntXType = i32;
    pub type IntegerXType = BigInt;
    pub type LanguageXType = String;
    pub type LongXType = i64;
    pub type NegativeIntegerXType = NonZeroIsize;
    pub type NonNegativeIntegerXType = BigUint;
    pub type NonPositiveIntegerXType = BigInt;
    pub type NormalizedStringXType = String;
    pub type PositiveIntegerXType = NonZeroUsize;
    pub type ShortXType = i16;
    pub type StringXType = String;
    pub type TimeXType = String;
    pub type TokenXType = String;
    pub type UnsignedByteXType = u8;
    pub type UnsignedIntXType = u32;
    pub type UnsignedLongXType = u64;
    pub type UnsignedShortXType = u16;
}
